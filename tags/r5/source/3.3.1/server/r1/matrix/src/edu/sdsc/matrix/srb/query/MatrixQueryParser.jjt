/* ====================================================================
 * SDSC Matrix Software License, Version 1.0
 *
 * Copyright (c) 2003 San Diego Supercomputer Center (SDSC), San Diego, USA.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that ALL the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        SDSC Matrix Project (http://www.npaci.edu/DICE/SRB/matrix/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "SDSC" and "SDSC Matrix" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact arun@sdsc.edu or srb-chat@sdsc.edu.
 *
 * 5. Products derived from this software may not be called "SDSC",
 *    nor may "SDSC" appear in their name, without prior written
 *    permission of the SDSC.
 *
 * 6. License is not granted for commercial resale, in whole or in part, 
 *	  without the prior written permission from SDSC.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL SDSC OR
 * ITS CONTRIBUTORS (SDSC Matrix Team) BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software is intended to consist of voluntary contributions made by many
 * individuals for the SDSC Matrix Project.
 *
 * SDSC Matrix.  
 * Designer & Architect: Arun swaran Jagatheesan (arun@sdsc.edu)
 *
 * Authors (Credits 02/SEP/2003):
 * Allen Ding (alding@sdsc.edu)
 * Arun Jagatheesan (arun@sdsc.edu)
 * Reena Mathew	(rmathew@sdsc.edu)
 * Erik Vandekieft (evk@sdsc.edu)
 */




/*
 * Copyright Â© 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 * intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation,
 * these intellectual property rights may include one or more of the U.S.
 * patents listed at http://www.sun.com/patents and one or more additional
 * patents or pending patent applications in the U.S. and in other countries.
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.  Use is subject to license terms.
 * Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 * product is covered and controlled by U.S. Export Control laws and may be
 * subject to the export or import laws in other countries.  Nuclear, missile,
 * chemical biological weapons or nuclear maritime end uses or end users,
 * whether direct or indirect, are strictly prohibited.  Export or reexport
 * to countries subject to U.S. embargo or to entities identified on U.S.
 * export exclusion lists, including, but not limited to, the denied persons
 * and specially designated nationals lists is strictly prohibited.
 */


/*
 *	This is grammar for the Xquery implementation for Matrix
 *  The integration with Matrix API is dependent on the feature currently
 *  supported by Matrix.  
 */

options {
  MULTI=true;
  VISITOR=true;
  NODE_DEFAULT_VOID=true;  
}

PARSER_BEGIN(MatrixQueryParser)
package edu.sdsc.matrix.srb.query;

import java.io.StringReader;
import edu.sdsc.matrix.srb.util.MatrixUtil;

public class MatrixQueryParser {

	// Initialize MatrixQuery
       public static MatrixQueryProcessor queryProcessor =  new MatrixQueryProcessor();			
	   public static boolean isReturnClauseInProcess = false; 	
  public static void main(String args[]) {
  
    System.out.println("Reading from standard input...");
   // MatrixQueryParser t = new MatrixQueryParser(System.in);
    String queryString = "for $coll in collection(\"testCollection\") where $coll/MT/SIZE>1000 return $coll/MT/OFFSET";
    MatrixQueryParser t = new MatrixQueryParser(new StringReader(queryString));
    try {
     
      
    
      ASTStart n = t.Start();
      MatrixQueryParserVisitor v = new MatrixQueryParserDumpVisitor();
      n.jjtAccept(v, null);
      System.out.println("Thank you.");
      queryProcessor.process();
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
    
  }
}

PARSER_END(MatrixQueryParser)


SKIP :{ "\u0020" | "\u0009" | "\n" | "\r" }

TOKEN : {  <ANDHASH: "&#"> }
TOKEN : {  <x: "x"> }
TOKEN : {  <e: "e"> }
TOKEN : {  <E: "E"> }
TOKEN : {  <LPAR: "("> }
TOKEN : {  <RPAR: ")"> }
TOKEN : {  <SEMICOLON: ";"> }
TOKEN : {  <COLON: ":"> }
TOKEN : {  <COLONCOLON: "::"> }
TOKEN : {  <PRAGMA: "pragma"> }
TOKEN : {  <EXTENSION: "extension"> }
TOKEN : {  <DOT: "."> }
TOKEN : {  <LAX: "lax"> }
TOKEN : {  <STRICT: "strict"> }
TOKEN : {  <SKIPTOKEN:"skip"> }
TOKEN : {  <TYPE: "type"> }
TOKEN : {  <ANDSYMBOL: "&"> }
TOKEN : {  <AMP: "amp"> }
TOKEN : {  <QUOT: "quot"> }
TOKEN : {  <APOS: "apos"> }
TOKEN : {  <HASH: "#"> }
TOKEN : { <XQUERY: "xquery">}
TOKEN : { <VERSION: "version">}
TOKEN : { <IMPORT: "import">}
TOKEN : {  <MODULE: "module"> }
TOKEN : { <NAMESPACE: "namespace">}
TOKEN : { <EQUAL: "=">}
TOKEN : { <AT: "at">}
TOKEN : { <DEFINE: "define">}
TOKEN : { <VARIABLE: "variable">}
TOKEN : {  <DOLLAR: "$"> }
TOKEN : {  <LCURLYBRACE: "{"> }
TOKEN : {  <RCURLYBRACE: "}"> }
TOKEN : {  <EXTERNAL: "external"> }
TOKEN : {  <COMMA: ","> }
TOKEN : {  <RETURN: "return"> }
TOKEN : {  <FOR: "for"> }
TOKEN : {  <IN: "in"> }
TOKEN : {  <LET: "let"> }
TOKEN : {  <WHERE: "where"> }
TOKEN : {  <ORDER: "order"> }
TOKEN : {  <BY: "by"> }
TOKEN : {  <STABLE: "stable"> }
TOKEN : {  <ASCENDING: "ascending"> }
TOKEN : {  <DESCENDING: "descending"> }
TOKEN : {  <EMPTY: "empty"> }
TOKEN : {  <GREATEST: "greatest"> }
TOKEN : {  <LEAST: "least"> }
TOKEN : {  <COLLATION: "collation"> }
TOKEN : {  <SOME: "some"> }
TOKEN : {  <EVERY: "every"> }
TOKEN : {  <SATISFIES: "satisfies"> }
TOKEN : {  <TYPESWITCH: "typeswitich"> }
TOKEN : {  <DEFAULTTOKEN: "default"> }
TOKEN : {  <CASE: "case"> }
TOKEN : {  <AS: "as"> }
TOKEN : {  <IF: "if"> }
TOKEN : {  <THEN: "then"> }
TOKEN : {  <ELSE: "else"> }
TOKEN : {  <OR: "or"> }
TOKEN : {  <AND: "and"> }
TOKEN : {  <INSTANCE: "instance"> }
TOKEN : {  <OF: "of"> }
TOKEN : {  <TREAT: "treat"> }
TOKEN : {  <CASTABLE: "castable"> }
TOKEN : {  <CAST: "cast"> }
TOKEN : {  <TO: "to"> }
TOKEN : {  <PLUS: "+"> }
TOKEN : {  <MINUS: "-"> }
TOKEN : {  <MULT: "*"> }
TOKEN : {  <DIV: "div"> }
TOKEN : {  <IDIV: "idiv"> }
TOKEN : {  <MOD: "mod"> }
TOKEN : {  <UNION: "union"> }
TOKEN : {  <ORSYMBOL: "|"> }
TOKEN : {  <INTERSECT: "intersect"> }
TOKEN : {  <EXCEPT: "except"> }
TOKEN : {  <FSLASH: "/"> }
TOKEN : {  <BSLASH: "\\"> }
TOKEN : {  <LBRACKET: "["> }
TOKEN : {  <RBRACKET: "]"> }
TOKEN : {  <VALIDATE: "validate"> }
TOKEN : {  <GLOBAL: "global"> }
TOKEN : {  <CONTEXT: "context"> }
TOKEN : {  <NOTEQUAL: "!="> }
TOKEN : {  <LESSTHAN: "<"> }
TOKEN : {  <LESSTHANEQUAL: "<="> }
TOKEN : {  <GREATERTHAN: ">"> }
TOKEN : {  <GREATERTHANEQUAL: ">="> }
TOKEN : {  <EQ: "eq"> }
TOKEN : {  <NE: "ne"> }
TOKEN : {  <LT: "lt"> }
TOKEN : {  <LE: "le"> }
TOKEN : {  <GT: "gt"> }
TOKEN : {  <GE: "ge"> }
TOKEN : {  <IS: "is"> }
TOKEN : {  <ISNOT: "isnot"> }
TOKEN : {  <LESSTHANLESSTHAN: "<<"> }
TOKEN : {  <GREATERTHANGREATERTHAN: ">>"> }
TOKEN : {  <ATSYMBOL: "@"> }
TOKEN : {  <DOTDOT: ".."> }
TOKEN : {  <CHILD: "child"> }
TOKEN : {  <DESCENDANT: "descendant"> }
TOKEN : {  <ATTRIBUTE: "attribute"> }
TOKEN : {  <SELF: "self"> }
TOKEN : {  <DESCENDANT_OR_SELF: "descendant-or-self"> }
TOKEN : {  <PARENT: "parent"> }
TOKEN : {  <DOCUMENT: "document"> }
TOKEN : {  <ELEMENT: "element"> }
TOKEN : {  <TEXT: "text"> }
TOKEN : {  <CDATASTART: "<![CDATA["> }
TOKEN : {  <CDATAEND: "]]>"> }
TOKEN : {  <PROCESSINGINSTRSTART: "<?"> }
TOKEN : {  <PROCESSINGINSTREND: "?>"> }
TOKEN : {  <COMMENTSTART: "<!--"> }
TOKEN : {  <COMMENTEND: "-->"> }
TOKEN : {  <OPENQUOTE: "\""> }
TOKEN : {  <OPENAPOS: "'"> }
TOKEN : {  <DECLARE: "declare"> }
TOKEN : {  <XMLSPACE: "xmlspace"> }
TOKEN : {  <PRESERVE: "preserve"> }
TOKEN : {  <STRIP: "strip"> }
TOKEN : {  <FUNCTION: "function"> }
TOKEN : {  <ITEM: "item"> }
TOKEN : {  <NILLABLE: "nillable"> }
TOKEN : {  <PROCESSINGINSTRUCTION: "processing-instruction"> }
TOKEN : {  <DOCUMENTNODE: "document-node"> }
TOKEN : {  <COMMENT: "comment"> }
TOKEN : {  <NODE: "node"> }
TOKEN : {  <QUESTION: "?"> }
TOKEN : {  <SCHEMA: "schema"> }
TOKEN : {  <VALIDATION: "validation"> }

// Tokens for JARGON Query Operators
TOKEN : {  <LIKE_OPERATOR: "LIKE"> }
TOKEN : {  <NOT_LIKE_OPERATOR: "NOT LIKE"> }
TOKEN : {  <SOUNDS_LIKE_OPERATOR: "SOUNDS LIKE"> }
TOKEN : {  <SOUNDS_NOT_LIKE_OPERATOR: "SOUNDS NOT LIKE"> }
TOKEN : {  <IN_OPERATOR: "IN"> }
TOKEN : {  <NOT_IN_OPERATOR: "NOT IN"> }
TOKEN : {  <BETWEEN_OPERATOR: "BETWEEN"> }
TOKEN : {  <NOT_BETWEEN_OPERATOR: "NOT BETWEEN"> }

// NC NAME DEFINITION

/* definesc NCName */
TOKEN:
{
	<NCNAME: (<Letter> | "_") (<NCNameChar>)* >
|	<#NCNameChar: <Letter> | <Digit> | "." | "-" | "_" | <CombiningChar> | <Extender> >
|	<#Letter: <BaseChar> | <Ideographic> >
	
|	<#BaseChar:
		  ["\u0041"-"\u005A"] | ["\u0061"-"\u007A"] | ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"]
		| ["\u00F8"-"\u00FF"] | ["\u0100"-"\u0131"] | ["\u0134"-"\u013E"] | ["\u0141"-"\u0148"]
		| ["\u014A"-"\u017E"] | ["\u0180"-"\u01C3"] | ["\u01CD"-"\u01F0"] | ["\u01F4"-"\u01F5"]
		| ["\u01FA"-"\u0217"] | ["\u0250"-"\u02A8"] | ["\u02BB"-"\u02C1"] | "\u0386" | ["\u0388"-"\u038A"]
		| "\u038C" | ["\u038E"-"\u03A1"] | ["\u03A3"-"\u03CE"] | ["\u03D0"-"\u03D6"] | "\u03DA"
		| "\u03DC" | "\u03DE" | "\u03E0" | ["\u03E2"-"\u03F3"] | ["\u0401"-"\u040C"] | ["\u040E"-"\u044F"]
		| ["\u0451"-"\u045C"] | ["\u045E"-"\u0481"] | ["\u0490"-"\u04C4"] | ["\u04C7"-"\u04C8"]
		| ["\u04CB"-"\u04CC"] | ["\u04D0"-"\u04EB"] | ["\u04EE"-"\u04F5"] | ["\u04F8"-"\u04F9"]
		| ["\u0531"-"\u0556"] | "\u0559" | ["\u0561"-"\u0586"] | ["\u05D0"-"\u05EA"] | ["\u05F0"-"\u05F2"]
		| ["\u0621"-"\u063A"] | ["\u0641"-"\u064A"] | ["\u0671"-"\u06B7"] | ["\u06BA"-"\u06BE"]
		| ["\u06C0"-"\u06CE"] | ["\u06D0"-"\u06D3"] | "\u06D5" | ["\u06E5"-"\u06E6"] | ["\u0905"-"\u0939"]
		| "\u093D" | ["\u0958"-"\u0961"] | ["\u0985"-"\u098C"] | ["\u098F"-"\u0990"] | ["\u0993"-"\u09A8"]
		| ["\u09AA"-"\u09B0"] | "\u09B2" | ["\u09B6"-"\u09B9"] | ["\u09DC"-"\u09DD"] | ["\u09DF"-"\u09E1"]
		| ["\u09F0"-"\u09F1"] | ["\u0A05"-"\u0A0A"] | ["\u0A0F"-"\u0A10"] | ["\u0A13"-"\u0A28"]
		| ["\u0A2A"-"\u0A30"] | ["\u0A32"-"\u0A33"] | ["\u0A35"-"\u0A36"] | ["\u0A38"-"\u0A39"]
		| ["\u0A59"-"\u0A5C"] | "\u0A5E" | ["\u0A72"-"\u0A74"] | ["\u0A85"-"\u0A8B"] | "\u0A8D"
		| ["\u0A8F"-"\u0A91"] | ["\u0A93"-"\u0AA8"] | ["\u0AAA"-"\u0AB0"] | ["\u0AB2"-"\u0AB3"]
		| ["\u0AB5"-"\u0AB9"] | "\u0ABD" | "\u0AE0" | ["\u0B05"-"\u0B0C"] | ["\u0B0F"-"\u0B10"]
		| ["\u0B13"-"\u0B28"] | ["\u0B2A"-"\u0B30"] | ["\u0B32"-"\u0B33"] | ["\u0B36"-"\u0B39"]
		| "\u0B3D" | ["\u0B5C"-"\u0B5D"] | ["\u0B5F"-"\u0B61"] | ["\u0B85"-"\u0B8A"]
		| ["\u0B8E"-"\u0B90"] | ["\u0B92"-"\u0B95"] | ["\u0B99"-"\u0B9A"] | "\u0B9C" | ["\u0B9E"-"\u0B9F"]
		| ["\u0BA3"-"\u0BA4"] | ["\u0BA8"-"\u0BAA"] | ["\u0BAE"-"\u0BB5"] | ["\u0BB7"-"\u0BB9"]
		| ["\u0C05"-"\u0C0C"] | ["\u0C0E"-"\u0C10"] | ["\u0C12"-"\u0C28"] | ["\u0C2A"-"\u0C33"]
		| ["\u0C35"-"\u0C39"] | ["\u0C60"-"\u0C61"] | ["\u0C85"-"\u0C8C"] | ["\u0C8E"-"\u0C90"]
		| ["\u0C92"-"\u0CA8"] | ["\u0CAA"-"\u0CB3"] | ["\u0CB5"-"\u0CB9"] | "\u0CDE" | ["\u0CE0"-"\u0CE1"]
		| ["\u0D05"-"\u0D0C"] | ["\u0D0E"-"\u0D10"] | ["\u0D12"-"\u0D28"] | ["\u0D2A"-"\u0D39"]
		| ["\u0D60"-"\u0D61"] | ["\u0E01"-"\u0E2E"] | "\u0E30" | ["\u0E32"-"\u0E33"] | ["\u0E40"-"\u0E45"]
		| ["\u0E81"-"\u0E82"] | "\u0E84" | ["\u0E87"-"\u0E88"] | "\u0E8A" | "\u0E8D" | ["\u0E94"-"\u0E97"]
		| ["\u0E99"-"\u0E9F"] | ["\u0EA1"-"\u0EA3"] | "\u0EA5" | "\u0EA7" | ["\u0EAA"-"\u0EAB"]
		| ["\u0EAD"-"\u0EAE"] | "\u0EB0" | ["\u0EB2"-"\u0EB3"] | "\u0EBD" | ["\u0EC0"-"\u0EC4"]
		| ["\u0F40"-"\u0F47"] | ["\u0F49"-"\u0F69"] | ["\u10A0"-"\u10C5"] | ["\u10D0"-"\u10F6"] | "\u1100"
		| ["\u1102"-"\u1103"] | ["\u1105"-"\u1107"] | "\u1109" | ["\u110B"-"\u110C"] | ["\u110E"-"\u1112"]
		| "\u113C" | "\u113E" | "\u1140" | "\u114C" | "\u114E" | "\u1150" | ["\u1154"-"\u1155"] | "\u1159"
		| ["\u115F"-"\u1161"] | "\u1163" | "\u1165" | "\u1167" | "\u1169" | ["\u116D"-"\u116E"]
		| ["\u1172"-"\u1173"] | "\u1175" | "\u119E" | "\u11A8" | "\u11AB" | ["\u11AE"-"\u11AF"]
		| ["\u11B7"-"\u11B8"] | "\u11BA" | ["\u11BC"-"\u11C2"] | "\u11EB" | "\u11F0" | "\u11F9"
		| ["\u1E00"-"\u1E9B"] | ["\u1EA0"-"\u1EF9"] | ["\u1F00"-"\u1F15"] | ["\u1F18"-"\u1F1D"]
		| ["\u1F20"-"\u1F45"] | ["\u1F48"-"\u1F4D"] | ["\u1F50"-"\u1F57"] | "\u1F59" | "\u1F5B" | "\u1F5D"
		| ["\u1F5F"-"\u1F7D"] | ["\u1F80"-"\u1FB4"] | ["\u1FB6"-"\u1FBC"] | "\u1FBE" | ["\u1FC2"-"\u1FC4"]
		| ["\u1FC6"-"\u1FCC"] | ["\u1FD0"-"\u1FD3"] | ["\u1FD6"-"\u1FDB"] | ["\u1FE0"-"\u1FEC"]
		| ["\u1FF2"-"\u1FF4"] | ["\u1FF6"-"\u1FFC"] | "\u2126" | ["\u212A"-"\u212B"] | "\u212E"
		| ["\u2180"-"\u2182"] | ["\u3041"-"\u3094"] | ["\u30A1"-"\u30FA"] | ["\u3105"-"\u312C"]
		| ["\uAC00"-"\uD7A3"] >
|	<#Ideographic :    ["\u4E00"-"\u9FA5"] | "\u3007" | ["\u3021"-"\u3029"] > 
|	<#CombiningChar :
		  ["\u0300"-"\u0345"] | ["\u0360"-"\u0361"] | ["\u0483"-"\u0486"] | ["\u0591"-"\u05A1"]
		| ["\u05A3"-"\u05B9"] | ["\u05BB"-"\u05BD"] | "\u05BF" | ["\u05C1"-"\u05C2"] | "\u05C4"
		| ["\u064B"-"\u0652"] | "\u0670" | ["\u06D6"-"\u06DC"] | ["\u06DD"-"\u06DF"]
		| ["\u06E0"-"\u06E4"] | ["\u06E7"-"\u06E8"] | ["\u06EA"-"\u06ED"] | ["\u0901"-"\u0903"]
		| "\u093C" | ["\u093E"-"\u094C"] | "\u094D" | ["\u0951"-"\u0954"] | ["\u0962"-"\u0963"]
		| ["\u0981"-"\u0983"] | "\u09BC" | "\u09BE" | "\u09BF" | ["\u09C0"-"\u09C4"] | ["\u09C7"-"\u09C8"]
		| ["\u09CB"-"\u09CD"] | "\u09D7" | ["\u09E2"-"\u09E3"] | "\u0A02" | "\u0A3C" | "\u0A3E"
		| "\u0A3F" | ["\u0A40"-"\u0A42"] | ["\u0A47"-"\u0A48"] | ["\u0A4B"-"\u0A4D"] | ["\u0A70"-"\u0A71"]
		| ["\u0A81"-"\u0A83"] | "\u0ABC" | ["\u0ABE"-"\u0AC5"] | ["\u0AC7"-"\u0AC9"] | ["\u0ACB"-"\u0ACD"]
		| ["\u0B01"-"\u0B03"] | "\u0B3C" | ["\u0B3E"-"\u0B43"] | ["\u0B47"-"\u0B48"] | ["\u0B4B"-"\u0B4D"]
		| ["\u0B56"-"\u0B57"] | ["\u0B82"-"\u0B83"] | ["\u0BBE"-"\u0BC2"] | ["\u0BC6"-"\u0BC8"]
		| ["\u0BCA"-"\u0BCD"] | "\u0BD7" | ["\u0C01"-"\u0C03"] | ["\u0C3E"-"\u0C44"] | ["\u0C46"-"\u0C48"]
		| ["\u0C4A"-"\u0C4D"] | ["\u0C55"-"\u0C56"] | ["\u0C82"-"\u0C83"] | ["\u0CBE"-"\u0CC4"]
		| ["\u0CC6"-"\u0CC8"] | ["\u0CCA"-"\u0CCD"] | ["\u0CD5"-"\u0CD6"] | ["\u0D02"-"\u0D03"]
		| ["\u0D3E"-"\u0D43"] | ["\u0D46"-"\u0D48"] | ["\u0D4A"-"\u0D4D"] | "\u0D57" | "\u0E31"
		| ["\u0E34"-"\u0E3A"] | ["\u0E47"-"\u0E4E"] | "\u0EB1" | ["\u0EB4"-"\u0EB9"]
		| ["\u0EBB"-"\u0EBC"] | ["\u0EC8"-"\u0ECD"] | ["\u0F18"-"\u0F19"] | "\u0F35" | "\u0F37" | "\u0F39"
		| "\u0F3E" | "\u0F3F" | ["\u0F71"-"\u0F84"] | ["\u0F86"-"\u0F8B"] | ["\u0F90"-"\u0F95"] | "\u0F97"
		| ["\u0F99"-"\u0FAD"] | ["\u0FB1"-"\u0FB7"] | "\u0FB9" | ["\u20D0"-"\u20DC"] | "\u20E1"
		| ["\u302A"-"\u302F"] | "\u3099" | "\u309A" >
|	<#Digit:
		  ["\u0030"-"\u0039"] | ["\u0660"-"\u0669"] | ["\u06F0"-"\u06F9"] | ["\u0966"-"\u096F"]
		| ["\u09E6"-"\u09EF"] | ["\u0A66"-"\u0A6F"] | ["\u0AE6"-"\u0AEF"] | ["\u0B66"-"\u0B6F"]
		| ["\u0BE7"-"\u0BEF"] | ["\u0C66"-"\u0C6F"] | ["\u0CE6"-"\u0CEF"] | ["\u0D66"-"\u0D6F"]
		| ["\u0E50"-"\u0E59"] | ["\u0ED0"-"\u0ED9"] | ["\u0F20"-"\u0F29"] >
|	<#Extender :
		  "\u00B7" | "\u02D0" | "\u02D1" | "\u0387" | "\u0640" | "\u0E46" | "\u0EC6" | "\u3005"
		| ["\u3031"-"\u3035"] | ["\u309D"-"\u309E"] | ["\u30FC"-"\u30FE"] >

}


TOKEN : /* S */
{
  < S: "\u0020" | "\u0009" | "\n" | "\r" >
}


TOKEN :{
	<Literal : <StringLiteral> | <NumericLiteral> >
|   <#StringLiteral :   (("\"" (~["\""])* "\"") | ("'" (~["'"])* "'")) >
|   <#NumericLiteral : <IntegerLiteral> | <DecimalLiteral> |<DoubleLiteral> >
|   <#IntegerLiteral :   <Digits> >
|   <#DecimalLiteral :   ("." <Digits>) | ( <Digits> "." (["0" - "9"])* ) >
|   <#DoubleLiteral :    ( ("." <Digits>) | ( <Digits> ("." ( ["0" - "9"])*)? )) ( ["e","E"] ) ([ "+","-" ])? <Digits> >
|   <#Digits : (["0" - "9"])+  >
}

TOKEN : /* Char - 10000-10FFFF*/
{
  < CHAR: "\u0009" | "\n" | "\r" |["\u0020"-"\uD7FF"]|["\uE000"-"\uFFFD"]  >
}


TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}

TOKEN : /* DIGIT */
{
  < DIGIT: (["0"-"9"])+>  
}

TOKEN : /* IDENTIFIER_LETTER */
{
  < IDENTIFIER_LETTER: ["_","a"-"z","A"-"Z"]>
}


TOKEN : /* IDENTIFIER */
{
  < IDENTIFIER: <IDENTIFIER_LETTER> (<IDENTIFIER_LETTER>|<DIGIT>)* >
}

TOKEN : /* HEXDIGIT */
{
  < HEXDIGIT: (["0"-"9","a"-"f","A"-"F"])+>
}



TOKEN : /* STRING_LITERAL */
{
< STRING_LITERAL1:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

TOKEN : /* STRING_LITERAL */
{
< STRING_LITERAL:(("\"" (~["\""])* "\"") | ("'" (~["'"])* "'")) >
}


ASTStart Start() #Start : {}
{
  MatrixQueryExpression() /*";"*/
  { return jjtThis; }
}


void MatrixQueryExpression() : {}
{
  Module()
}

void Module() : {}
{
  (MainModule() | LibraryModule())
}

void MainModule() : {}
{
	Prolog() QueryBody()
}

void LibraryModule(): {}
{
	(ModuleDecl() Prolog())
}


void ModuleDecl()#NotSupported:
{
	Token t1;
}
{
	t1= <MODULE> StringLiteral()
	{
		throw new ParseException("ModuleDecl - Feature Not Supported in Matrix: "+t1);
	}
}

void Prolog() : {}
{
	(Version())? (NamespaceDecl()| XmlSpaceDecl() | DefaultNamespaceDecl() | DefaultCollationDecl() | SchemaImport() | ModuleImport() | VarDefn() | ValidationDecl() )* (FunctionDefn())*
}

void Version() #NotSupported:
{
	Token t1;
}
{
	t1 = <XQUERY> <VERSION> StringLiteral() 	
	{
		throw new ParseException("Version - Feature Not Supported in Matrix:"+t1);
	}
}

void ModuleImport() #NotSupported: 
{
	Token t1;
}
{
	t1 = <IMPORT> <MODULE> (<NAMESPACE> NCName() <EQUAL>)? 	
	{
		throw new ParseException("ModuleImport - Feature Not Supported in Matrix:"+t1);
	}
}

void VarDefn(): {}
{
	//("VarDefn ")
	<DEFINE> S() <VARIABLE> <DOLLAR> VarName() (TypeDeclaration())? ((<LCURLYBRACE> Expr() <RCURLYBRACE>) | <EXTERNAL>)
}

void QueryBody() : {}
{
	Expr()
}

String Expr() : 
{
	String expr="";
	String tempExpr="";
	Token tok;
}
{
	expr = ExprSingle() 
	(
		tok = <COMMA> 
		{expr += tok.image;}
		tempExpr = ExprSingle()
		{expr+=tempExpr;}
	)*
	{return expr;}
}

String ExprSingle() : 
{
	String expression = null; 
}
{
	(
	FLWORExpr() 
	| QuantifiedExpr() 
	| TypeswitchExpr() 
	| IfExpr() 
	| expression =OrExpr()
	)
	{MatrixUtil.toLog("MatrixQueryParser-ExprSingle()- isReturnClauseInProcess:"+isReturnClauseInProcess,MatrixUtil.DEBUG_LOG);}
	{MatrixUtil.toLog("EXPR SINGLE expression:"+expression,MatrixUtil.DEBUG_LOG);}
	{
		// Processing Selection Fields For Return Clause
		if(isReturnClauseInProcess)
		{
			if(expression!=null)
			{
				if(expression.trim().length()>0)
					queryProcessor.getReturnClause().addSelectionFieldName(expression);
			}	
		}	
	}
	{MatrixUtil.toLog("EXPR SINGLE expression:"+expression,MatrixUtil.DEBUG_LOG);}
	{ return expression; }
}

void FLWORExpr() : 
{
	String returnExpression;
}
{
	( ForClause() | LetClause())+  (WhereClause())? (OrderByClause())? <RETURN>
	{isReturnClauseInProcess = true;}  
	returnExpression = ExprSingle()
	{MatrixUtil.toLog("RETURN EXPRESSION :"+returnExpression,MatrixUtil.DEBUG_LOG);}
	{isReturnClauseInProcess = false;}  
	{queryProcessor.getReturnClause().setReturnExpression(returnExpression);}
	{queryProcessor.getReturnClause().fixToRemoveReturnExpresionFromSelectionFieldNames();}
}

void ForClause() : 
{ 
	String varName;
	String forExpression ="";
}
{
	<FOR><DOLLAR> 
	varName = VarName() 
	(TypeDeclaration())? (PositionalVar())? <IN>  
	forExpression = ExprSingle() 
	(<COMMA> <DOLLAR> VarName() (TypeDeclaration())? (PositionalVar())? <IN> ExprSingle())*
	{ 
		
		queryProcessor.getForClause().setVariableName(varName);
		queryProcessor.getForClause().setFunctionName(forExpression.substring(0,forExpression.indexOf('(')));
		queryProcessor.getForClause().setFunctionParameter(forExpression.substring(forExpression.indexOf('"')+1,forExpression.lastIndexOf('"')));
		
		
	}
}

void PositionalVar() : {}
{
	(<AT> <DOLLAR>VarName())
}

void LetClause() : {}
{
	<LET> <DOLLAR>VarName() (TypeDeclaration())? <COLON><EQUAL> ExprSingle() (<COMMA> <DOLLAR>VarName() (TypeDeclaration())? <COLON><EQUAL> ExprSingle())*
}

void WhereClause() : 
{
	String whereExpression;
}
{
	( 
		<WHERE> 
		whereExpression = Expr() 
		
		{queryProcessor.getWhereClause().setWhereExpression(whereExpression);}
	)
}

void OrderByClause() : {}
{
	((<ORDER> <BY>)|(<STABLE> <ORDER> <BY>)) OrderSpecList()
}

void OrderSpecList() : {}
{
	OrderSpec() (<COMMA> OrderSpec())*
}

void OrderSpec() : {}
{
	ExprSingle() OrderModifier() 
}

void OrderModifier() : {}
{
	(<ASCENDING>|<DESCENDING>)? ((<EMPTY> <GREATEST>) |( <EMPTY> <LEAST>))? (<COLLATION> StringLiteral())?
}

void QuantifiedExpr() : {}
{
	((<SOME> <DOLLAR>) | (<EVERY> <DOLLAR>)) VarName() (TypeDeclaration())? <IN> ExprSingle() (<COMMA> <DOLLAR>VarName() (TypeDeclaration())? <IN> ExprSingle())* <SATISFIES> ExprSingle()
}

void TypeswitchExpr() : {}
{
	<TYPESWITCH> <LPAR>Expr()<RPAR> (CaseClause())+ <DEFAULTTOKEN> (<DOLLAR>VarName())? <RETURN> ExprSingle()
}

void CaseClause() : {}
{
	<CASE> (<DOLLAR> VarName() <AS>)? SequenceType() <RETURN> Expr()
}

void IfExpr() : {}
{
	<IF> <LPAR>Expr()<RPAR> <THEN>Expr() <ELSE>ExprSingle()
}

String OrExpr() : 
{
	String expr="";
	String tempExpr="";
	Token orToken;
}
{
	expr= AndExpr() 
	( 	
		orToken = <OR> 
		tempExpr = AndExpr() 
		{	expr = expr + orToken.image + tempExpr;}
	)*
	
	{MatrixUtil.toLog("OR EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String AndExpr() : 
{
	String expr="";
	String tempExpr="";
	Token andToken;
}
{
	expr = InstanceofExpr() 
	(
		andToken = <AND> 
		tempExpr = InstanceofExpr() 
		{ expr = expr + andToken.image + tempExpr ; }
	)*
	{MatrixUtil.toLog("AND EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String InstanceofExpr() : 
{
	String expr="";
}
{
	expr = TreatExpr() 
	(<INSTANCE> <OF> SequenceType() )?
	{MatrixUtil.toLog("INSTANCE OF EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String TreatExpr() : 
{
	String expr="";
}
{
	expr = CastableExpr() 
	( <TREAT> <AS> SequenceType() )?
	{MatrixUtil.toLog("TREAT EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String CastableExpr() : 
{
	String expr="";
}
{
	expr = CastExpr() 
	( <CASTABLE> <AS> SingleType() )?
	{MatrixUtil.toLog("CASTABLE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String CastExpr() : 
{
	String expr="";
}
{
	expr = ComparisonExpr() 
	( <CAST> <AS> SingleType() )?
	{MatrixUtil.toLog("CAST EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{ return expr ;} 
}

String ComparisonExpr() : 
{
	String expr="";
	String tempExpr="";
	String wVar="";
	String wOpr="";
	String wVal="";
}
{
	expr = RangeExpr()
	{wVar = expr;} 
	( (ValueComp()
	  | tempExpr = GeneralComp()
	  	{wOpr = tempExpr;}
	  | NodeComp()
	  | OrderComp()) 
	  {expr = expr + tempExpr;}
	  tempExpr = RangeExpr() 
	  {expr = expr + tempExpr;}
	  {wVal = tempExpr;}
	  {
	  	MatrixQueryConditionClause condClause = new MatrixQueryConditionClause();
	  	condClause.setConditionClause(expr);
	  	condClause.setConditionVariable(wVar);
	  	condClause.setOperator(wOpr);
	  	condClause.setConditionValue(wVal);
	  	queryProcessor.getWhereClause().addCondition(condClause);
	  	//MatrixUtil.toLog("Comparison Expr : "+condClause.getConditionClause(),MatrixUtil.DEBUG_LOG);
	  }
	  )?
	  
	  {MatrixUtil.toLog("COMPARISON EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	  {return expr;}
}

String RangeExpr() : 
{
	String expr ="";
}
{
	expr = AdditiveExpr() 
	( <TO> AdditiveExpr() )?
	 {MatrixUtil.toLog("RANGE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String AdditiveExpr() : 
{
	String expr="";
}
{
	expr = MultiplicativeExpr() 
	( (<PLUS> | <MINUS>) MultiplicativeExpr() )*
	 {MatrixUtil.toLog("ADDITIVE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String MultiplicativeExpr() : 
{
	String expr="";
}
{
	expr = UnaryExpr() 
	( (<MULT> | <DIV> | <IDIV> | <MOD>) UnaryExpr() )*
	 {MatrixUtil.toLog("MULTIPLICATIVE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String UnaryExpr() : 
{
	String expr="";
}
{
	(<MINUS> | <PLUS>)* 
	expr = UnionExpr()
	 {MatrixUtil.toLog("UNARY EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String UnionExpr() : 
{
	String expr="";
}
{
	expr = IntersectExceptExpr() 
	( (<UNION> | <ORSYMBOL>) IntersectExceptExpr() )*
	 {MatrixUtil.toLog("UNION EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String IntersectExceptExpr() : 
{
	String expr="";
}
{
	expr = ValueExpr() 
	( (<INTERSECT> | <EXCEPT>) ValueExpr() )* 
	 {MatrixUtil.toLog("INTERSECT EXCEPT EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String ValueExpr() : 
{
	String expr="";
}
{
	ValidateExpr() 
	| expr  = PathExpr()
	 {MatrixUtil.toLog("VALUE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String PathExpr() : 
{
	String expr = "";
	Token fSlash;
	String tempExpr="";
}
{
	fSlash = <FSLASH>
	{expr = fSlash.image;}
	(
		tempExpr = RelativePathExpr()
		{expr = expr + tempExpr;}
	)?
	| 
	fSlash = <FSLASH>
	{ expr = expr + fSlash.image;}
	fSlash = <FSLASH> 
	{ expr = expr + fSlash.image;}
	tempExpr = RelativePathExpr()
	{expr = expr+tempExpr;}
	| 
	tempExpr = RelativePathExpr()
	{expr = expr + tempExpr;}
	 {MatrixUtil.toLog("PATH EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
	
 
}

String RelativePathExpr() : 
{
	String expr="";
	String tempExpr="";
	Token fSlash;
}
{
	expr = StepExpr() 
	(
		( 
			fSlash = <FSLASH> 
			{expr = expr + fSlash.image;}
			| fSlash = <FSLASH>
			  {expr = expr + fSlash.image;}
			  fSlash = <FSLASH>
			  {expr = expr + fSlash.image;}
		)
			 
		tempExpr = StepExpr()
		{expr = expr + tempExpr;}
	)*
	
	 {MatrixUtil.toLog("RELATIVE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return(expr);}
}

String StepExpr() : 
{
	String expr="";
}
{
	(expr = FilterStep() 
	|expr = AxisStep() ) // Avoid conflict for FunctionCall that starts with QName and AxisStep ..
	
	 {MatrixUtil.toLog("STEP EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String AxisStep() : 
{
	String expr="";
	String tempExpr="";
}
{
	(
		expr = ForwardStep() 
		| expr= ReverseStep()
	) 
	tempExpr = Predicates()
	{expr = expr + tempExpr;}
	 {MatrixUtil.toLog("AXIS STEP EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String FilterStep() : 
{
	String expr="";
	String tempExpr="";
}
{
	expr = PrimaryExpr() 
	tempExpr = Predicates()
	{expr += tempExpr;}
	
	 {MatrixUtil.toLog("FILTER EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String PrimaryExpr() : 
{
	String expr="";
	String tempExpr="";
	Token dollar;
}
{
	expr = Literal() 
	{return(expr);}
	| expr = FunctionCall() 
		{return(expr);}
	| (
		dollar = <DOLLAR>
		tempExpr = VarName()
		{expr = dollar.image+tempExpr;}
		{return(expr);}
	  ) 
	| expr = ParanthesizedExpr() 
		{return(expr);}
	| expr = Constructor()
		{return(expr);}
}

String Predicates() : 
{
	String expr="";
	String tempExpr="";
	Token lBracket;
	Token rBracket;
}
{
	(
		lBracket = <LBRACKET>
		{expr = lBracket.image;}
		tempExpr = Expr()
		{expr = expr + tempExpr;}
		rBracket = <RBRACKET>
		{expr = expr+rBracket.image;}
	)*
	{return(expr);}
}

void ValidateExpr() : {}
{
	((<VALIDATE> <LCURLYBRACE>) | (<VALIDATE> <GLOBAL> <LCURLYBRACE>) | (<VALIDATE> <CONTEXT> SchemaContextLocation() "{") | ("validate" SchemaMode() (SchemaContext())? <LCURLYBRACE>)) Expr() <RCURLYBRACE>
}

void SchemaContext() : {}
{
	(<CONTEXT> SchemaContextLocation()) | <GLOBAL>
}

String Constructor() : 
{
	String consExpr = null;
}
{
	(
	  (consExpr = ElementConstructor())
	| (XmlComment())
	| (XmlProcessingInstruction())
	| (CdataSection())
	| (ComputedDocumentConstructor())
	| (ComputedElementConstructor())
	| (ComputedAttributeConstructor())
	| (ComputedTextConstructor())
	)

	{return consExpr;}
}

String GeneralComp() : 
{
	Token operator;
}
{
	(
	operator = <EQUAL> 
	| operator = <NOTEQUAL> 
	| operator =<LESSTHAN> 
	| operator =<LESSTHANEQUAL> 
	| operator =<GREATERTHAN> 
	| operator =<GREATERTHANEQUAL>
	| operator = <LIKE_OPERATOR>
	| operator = <NOT_LIKE_OPERATOR>
	| operator = <SOUNDS_LIKE_OPERATOR>
	| operator = <SOUNDS_NOT_LIKE_OPERATOR>
	| operator = <IN_OPERATOR>
	| operator = <NOT_IN_OPERATOR>
	| operator = <BETWEEN_OPERATOR>
	| operator = <NOT_BETWEEN_OPERATOR>
	)
	{return operator.image;}
}

void ValueComp() : {}
{
	<EQ> | <NE> | <LT> | <LE> | <GT> | <GE>
}

void NodeComp() : {}
{
	<IS> | <ISNOT>
}

void OrderComp() : {}
{
	<LESSTHANLESSTHAN> | <GREATERTHANGREATERTHAN>
}

String ForwardStep() : 
{
	String expr="";
	String tempExpr="";
}
{
	(ForwardAxis() NodeTest()) 
	| expr = AbbreviatedForwardStep()
	{return(expr);}
}

String ReverseStep() : 
{
	String expr="";
	String tempExpr="";
}
{
	(ReverseAxis() NodeTest()) 
	| expr = AbbreviatedReverseStep()
	{return expr;}
}

String AbbreviatedForwardStep() : 
{
	String expr="";
	String tempExpr="";
	Token tok;
}
{
	tok = <DOT> 
	{expr = tok.image;}
	| (
		tok = <ATSYMBOL> 
		{expr = expr + tok.image;}
		tempExpr = NameTest()
		{expr = expr + tempExpr;}
	  ) 
	| tempExpr = NodeTest()
	  {expr = expr + tempExpr;}
	{return expr;}
}

String AbbreviatedReverseStep() : 
{
	Token tok;
}
{
	tok = <DOTDOT>
	{return tok.image;}
}

void ForwardAxis() : {}
{
	(<CHILD> <COLONCOLON>)
	| (<DESCENDANT> <COLONCOLON>)
	| (<ATTRIBUTE> <COLONCOLON>)
	| (<SELF> <COLONCOLON>)
	| (<DESCENDANT_OR_SELF> <COLONCOLON>)

}

void ReverseAxis() : {}
{
	<PARENT> <COLONCOLON>
}

String NodeTest() : 
{
	String expr="";
}
{
	(	
		KindTest() 
		| expr= NameTest ()
	)
	{return expr;}
}

String NameTest() : 
{
	String expr="";
}
{
	(
		expr = QName() 
		| expr= Wildcard()
	)
	{return expr;}
}

String Wildcard() : 
{
	Token t1,t2;
	String expr="";
	String tempExpr="";
}
{
	t1 = <MULT> 
	{expr = t1.image;}
	| (
		tempExpr = NCName() 
		t1= <COLON> 
		t2 = <MULT>
		{expr+=tempExpr+t1.image+t2.image;}
		)
	| (
		t1= <MULT>
		t2 = <COLON>
		tempExpr = NCName()
		{expr+=t1.image+t2.image+tempExpr;}
	  )	
		{return expr;}
}

String Literal() : 
{
	Token lit;
	String literal;
}
{
	//(<NumericLiteral> | <StringLiteral>)
	lit = <Literal>
	{	
		literal = lit.image;
		return literal;
	}
}

void NumericLiteral() : {}
{
	IntegerLiteral() | DecimalLiteral() | DoubleLiteral()
}

String ParanthesizedExpr() : 
{
	String expr="";
	String tempExpr="";
	Token lPar;
	Token rPar;
}
{
	lPar = <LPAR> 
	{expr = lPar.image;}
	(
	tempExpr = Expr()
	{expr = expr+tempExpr;}
	)? 
	rPar = <RPAR>
	{expr = expr + rPar.image;}
	{return expr;}
}

String FunctionCall() : 
{
	String functionName="";
	String functionExpression="";
	String tempFunctionExpression="";
	Token t1,t2;
}
{
	functionName = QName() 
	{functionExpression+=functionName;}
	t1= <LPAR> 
	{functionExpression+= t1.image;}
	(
		tempFunctionExpression = ExprSingle() 
		{functionExpression+= tempFunctionExpression;}
		(
			t2 = <COMMA> 
			{functionExpression+= t2.image;}
			tempFunctionExpression = ExprSingle()
			{	functionExpression +=tempFunctionExpression; }
		)*
	)? 
	t1 = <RPAR>
	{functionExpression+= t1.image;}
	{return functionExpression;}
}

String ElementConstructor() : 
{
	String elemConsExpr = null;
	String tempExpression = null;
	Token t1,t2,t3;
}
{
	//<LESSTHAN> QName() AttributeList() (<FSLASH><GREATERTHAN>|(<GREATERTHAN> (ElementContent())* <LESSTHAN><FSLASH> QName() (S())? <GREATERTHAN>) )
	t1= <LESSTHAN> 
	{ elemConsExpr =t1.image;}
	
	tempExpression = QName() 
	{elemConsExpr+=tempExpression;}
	
	AttributeList() // Not Supported
	
	t1= <GREATERTHAN> 
	{elemConsExpr+=t1.image;}
	
	(
		tempExpression = ElementContent()
		{elemConsExpr+=tempExpression;}
	)* 
	
	t1= <LESSTHAN>
	{elemConsExpr+=t1.image;}
	
	t1= <FSLASH> 
	{elemConsExpr+=t1.image;}
	
	tempExpression = QName() 
	{elemConsExpr+=tempExpression;}
	
	t1= <GREATERTHAN>
	{elemConsExpr+=t1.image;}
	
	{return elemConsExpr;}
}

void ComputedDocumentConstructor() : {}
{
	<DOCUMENT> <LCURLYBRACE>Expr()<RCURLYBRACE>
}

void ComputedElementConstructor() : {}
{
	(<ELEMENT> QName() <LCURLYBRACE> | (<ELEMENT> <LCURLYBRACE> Expr() <RCURLYBRACE> <LCURLYBRACE>)) (Expr())? <RCURLYBRACE>
}

void ComputedAttributeConstructor() : {}
{
	(<ATTRIBUTE> QName() <LCURLYBRACE> | (<ATTRIBUTE> <LCURLYBRACE> Expr() <RCURLYBRACE> <LCURLYBRACE>)) (Expr())? <RCURLYBRACE>
}

void ComputedTextConstructor() : {}
{
	<TEXT> <LCURLYBRACE> (Expr())? <RCURLYBRACE> 
}

void CdataSection() : {}
{
	<CDATASTART> (Char())* <CDATAEND>
}

void XmlProcessingInstruction() : {}
{
	<PROCESSINGINSTRSTART> PITarget() (Char())* <PROCESSINGINSTREND>
}

void XmlComment() : {}
{
	<COMMENTSTART> (Char())* <COMMENTEND>
}

String ElementContent() : 
{
	String elConExpr = null;
}
{
	(
	(ElementContentChar())
	| (<LCURLYBRACE><LCURLYBRACE>)
	|  (<RCURLYBRACE><RCURLYBRACE>)
	| (elConExpr = ElementConstructor())
	| (elConExpr = EnclosedExpr())
	| (CdataSection())
	| (CharRef())
	| (PredefinedEntityRef())
	| (XmlComment())
	| (XmlProcessingInstruction())
	)
	{return elConExpr;}
}

void AttributeList() : {}
{
	(S() (QName() (S())? <EQUAL> (S())? AttributeValue())?)*
}

void AttributeValue() : {}
{
	(<OPENQUOTE> (EscapeQuot() | AttributeValueContent())* <OPENQUOTE>)
	| (<OPENAPOS> (EscapeApos() | AttributeValueContent())* <OPENAPOS>)

}

void AttributeValueContent() : {}
{
	QuoteAttributeContentChar()
	| AposAttributeContentChar()
	| CharRef()
	| <LCURLYBRACE><LCURLYBRACE>
	| <RCURLYBRACE><RCURLYBRACE>
	| EnclosedExpr()
	| PredefinedEntityRef()
	

}

String EnclosedExpr() : 
{
	String enclExpr = null;
	String tempEnclExpr = null;
	Token t1;
}
{
	t1= <LCURLYBRACE>
	{enclExpr = t1.image;}
	
	tempEnclExpr = Expr()
	{enclExpr+=tempEnclExpr;}
	
	t1= <RCURLYBRACE>
	{enclExpr += t1.image;}
	
	{return (enclExpr); }
}

void XmlSpaceDecl() : {}
{
	<DECLARE> <XMLSPACE> <EQUAL> (<PRESERVE> | <STRIP>)
}

void DefaultCollationDecl() : {}
{
	<DEFAULTTOKEN> <COLLATION> <EQUAL> StringLiteral()
}

void NamespaceDecl() : {}
{
	<DECLARE> <NAMESPACE> NCName() <EQUAL> StringLiteral() 
}

void DefaultNamespaceDecl() : {}
{
	((<DEFAULTTOKEN> <ELEMENT>) | (<DEFAULTTOKEN> <FUNCTION>)) <NAMESPACE> <EQUAL> StringLiteral()
}

void FunctionDefn() : {}
{
	<DEFINE> <FUNCTION> QName() <LPAR> (ParamList())? (<RPAR> | (<RPAR> <AS> SequenceType())) (EnclosedExpr() | <EXTERNAL>)
}

void ParamList() : {}
{
	Param() (<COMMA> Param())*
}

void Param() : {}
{
	<DOLLAR>VarName() (TypeDeclaration())?
}

void TypeDeclaration() : {}
{
	<AS> SequenceType()
}

void SingleType() : {}
{
	AtomicType() (<QUESTION>)?
}

void SequenceType() : {}
{
	(ItemType() (OccurrenceIndicator())?)
	| (<EMPTY> <LPAR> <RPAR>)

}

void AtomicType() : {}
{
	QName()
}

void ItemType() : {}
{
	AtomicType() | KindTest() | (<ITEM> <LPAR> <RPAR>)
}

void KindTest() : {}
{
	DocumentTest()
| ElementTest()
| AttributeTest()
| ProcessingInstructionTest()
| CommentTest()
| TextTest()
| AnyKindTest()
 
}

void ElementTest() : {}
{
	<ELEMENT> <LPAR> ((SchemaContextPath() LocalName())
	| (NodeName() (<COMMA> TypeName() (<NILLABLE>)?)?))? <RPAR>

}

void AttributeTest() : {}
{
	<ATTRIBUTE> <LPAR> ((SchemaContextPath() <ATSYMBOL> LocalName())
	| (<ATSYMBOL> NodeName() (<COMMA> TypeName())?))? <RPAR>

}

void ProcessingInstructionTest() : {}
{
	<PROCESSINGINSTRUCTION> <LPAR> (StringLiteral())? <RPAR>
}

void DocumentTest() : {}
{
	<DOCUMENTNODE> <LPAR> (ElementTest())? <RPAR>
}

void CommentTest() : {}
{
	<COMMENT> <LPAR> <RPAR> 
}

void TextTest() : {}
{
	<TEXT> <LPAR> <RPAR> 
}

void AnyKindTest() : {}
{
	<NODE> <LPAR> <RPAR> 
}

void SchemaContextPath() : {}
{
	SchemaGlobalContext() <FSLASH> (SchemaContextStep() <FSLASH>)* 
}

void SchemaContextLocation() : {}
{
	(SchemaContextPath() QName()) | SchemaGlobalTypeName()
}

void LocalName() : {}
{
	QName()
}

void NodeName() : {}
{
	QName() | <MULT>
}

void TypeName() : {}
{
	QName() | <MULT>
}

void OccurrenceIndicator() : {}
{
	<QUESTION> | <MULT> | <PLUS>
}

void ValidationDecl() : {}
{
	(<VALIDATION> <LAX>) | (<VALIDATION> <STRICT>) | (<VALIDATION> <SKIPTOKEN>)
}

void SchemaImport() : {}
{
	(<IMPORT> <SCHEMA>) (SchemaPrefix())? StringLiteral() (<AT> StringLiteral())?
}

void SchemaPrefix() : {}
{
	(<NAMESPACE> NCName() <EQUAL>) | ((<DEFAULTTOKEN> <ELEMENT>) <NAMESPACE> <EQUAL>)
}




void Pragma() : {}
{
	<LPAR><COLONCOLON> <PRAGMA> QName() (PragmaContents())* <COLONCOLON><RPAR>
}

void MustUnderstandExtension() : {}
{
	<LPAR><COLONCOLON> <EXTENSION> QName() (ExtensionContents())* <COLONCOLON><RPAR>
}

void ExprComment() : {}
{
	<LPAR><COLON> (ExprCommentContent() | ExprComment())* <COLON><RPAR>
}

void ExprCommentContent() : {}
{
	Char()
}
void PragmaContents() : {}
{
	Char()
}

void ExtensionContents() : {}
{
	Char()
}

void IntegerLiteral() : {}
{
	Digits()
}

void DecimalLiteral() : {}
{
	(<DOT> Digits()) | (Digits() <DOT> (Digits())*)
}

void DoubleLiteral() : {}
{
	((<DOT> Digits()) | (Digits() (<DOT> (Digits())*)?)) (<e> | <E>) (<PLUS> | <MINUS>)? Digits()
}

void StringLiteral() : {}
{
	<Literal> // This should be StringLiteral. But there is some conflict with Literal Token and defining StringLiteral token
}

void S() : {}
{
	(<S>)+
}

void SchemaMode() : {}
{
	<LAX> | <STRICT> | <SKIPTOKEN>
}

void SchemaGlobalTypeName() : {}
{
	<TYPE> <LPAR> QName() <RPAR>
}

void SchemaGlobalContext() : {}
{
	QName() | SchemaGlobalTypeName()
}

void SchemaContextStep() : {}
{
	QName()
}

void Digits() : {}
{
	<DIGIT>
}

void EscapeQuot() : {}
{
	"\"" "\"" 
}

void PITarget() : {}
{
	NCName()
}

String NCName() : 
{	
	Token ncName;
}
{
	ncName = <NCNAME>
	{return ncName.image;}
}

String VarName() : 
{
	String varName;
}
{
	varName = QName()
	{return varName;}
}

String QName() : 
{
	String qName = "";
	String ncName="";
	Token colon;
}
{
	(
	ncName = NCName() 
	colon = <COLON>
	{qName = ncName + colon.image;}
	)? 
	ncName = NCName()
	{
		if(qName==null)
			qName = ncName;
		else	
			qName = qName+ncName;
	}
	{return qName;}
}

void PredefinedEntityRef() : {}
{
	<ANDSYMBOL> (<LT> | <GT> | <AMP> | <QUOT> | <APOS>) <SEMICOLON> 
}

void HexDigits() : {}
{
	<HEXDIGIT>
}

void CharRef() : {}
{
	<ANDHASH> (Digits() | (<x> HexDigits())) <SEMICOLON>
}

void EscapeApos() : {}
{
	"''"
}


void Char() : {}
{
	<CHAR>
}

void ElementContentChar() : {}
{
	Char() 
}

void QuoteAttributeContentChar() : {}
{
	Char()  
}

void AposAttributeContentChar() : {}
{
	Char() 
}

