/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. C:\CodeRepository\matrix\src\edu\sdsc\matrix\srb\query\MatrixQueryParser.jj */
/*@egen*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

PARSER_BEGIN(MatrixQueryParser)
package edu.sdsc.matrix.srb.query;

import java.io.StringReader;
import edu.sdsc.matrix.srb.util.MatrixUtil;

public class MatrixQueryParser/*@bgen(jjtree)*/implements MatrixQueryParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTMatrixQueryParserState jjtree = new JJTMatrixQueryParserState();

/*@egen*/

	// Initialize MatrixQuery
       public static MatrixQueryProcessor queryProcessor =  new MatrixQueryProcessor();			
	   public static boolean isReturnClauseInProcess = false; 	
  public static void main(String args[]) {
  
    System.out.println("Reading from standard input...");
   // MatrixQueryParser t = new MatrixQueryParser(System.in);
    String queryString = "for $coll in collection(\"testCollection\") where $coll/MT/SIZE>1000 return $coll/MT/OFFSET";
    MatrixQueryParser t = new MatrixQueryParser(new StringReader(queryString));
    try {
     
      
    
      ASTStart n = t.Start();
      MatrixQueryParserVisitor v = new MatrixQueryParserDumpVisitor();
      n.jjtAccept(v, null);
      System.out.println("Thank you.");
      queryProcessor.process();
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
    
  }
}

PARSER_END(MatrixQueryParser)


SKIP :{ " " | "	" | "\n" | "\r" }

TOKEN : {  <ANDHASH: "&#"> }
TOKEN : {  <x: "x"> }
TOKEN : {  <e: "e"> }
TOKEN : {  <E: "E"> }
TOKEN : {  <LPAR: "("> }
TOKEN : {  <RPAR: ")"> }
TOKEN : {  <SEMICOLON: ";"> }
TOKEN : {  <COLON: ":"> }
TOKEN : {  <COLONCOLON: "::"> }
TOKEN : {  <PRAGMA: "pragma"> }
TOKEN : {  <EXTENSION: "extension"> }
TOKEN : {  <DOT: "."> }
TOKEN : {  <LAX: "lax"> }
TOKEN : {  <STRICT: "strict"> }
TOKEN : {  <SKIPTOKEN:"skip"> }
TOKEN : {  <TYPE: "type"> }
TOKEN : {  <ANDSYMBOL: "&"> }
TOKEN : {  <AMP: "amp"> }
TOKEN : {  <QUOT: "quot"> }
TOKEN : {  <APOS: "apos"> }
TOKEN : {  <HASH: "#"> }
TOKEN : { <XQUERY: "xquery">}
TOKEN : { <VERSION: "version">}
TOKEN : { <IMPORT: "import">}
TOKEN : {  <MODULE: "module"> }
TOKEN : { <NAMESPACE: "namespace">}
TOKEN : { <EQUAL: "=">}
TOKEN : { <AT: "at">}
TOKEN : { <DEFINE: "define">}
TOKEN : { <VARIABLE: "variable">}
TOKEN : {  <DOLLAR: "$"> }
TOKEN : {  <LCURLYBRACE: "{"> }
TOKEN : {  <RCURLYBRACE: "}"> }
TOKEN : {  <EXTERNAL: "external"> }
TOKEN : {  <COMMA: ","> }
TOKEN : {  <RETURN: "return"> }
TOKEN : {  <FOR: "for"> }
TOKEN : {  <IN: "in"> }
TOKEN : {  <LET: "let"> }
TOKEN : {  <WHERE: "where"> }
TOKEN : {  <ORDER: "order"> }
TOKEN : {  <BY: "by"> }
TOKEN : {  <STABLE: "stable"> }
TOKEN : {  <ASCENDING: "ascending"> }
TOKEN : {  <DESCENDING: "descending"> }
TOKEN : {  <EMPTY: "empty"> }
TOKEN : {  <GREATEST: "greatest"> }
TOKEN : {  <LEAST: "least"> }
TOKEN : {  <COLLATION: "collation"> }
TOKEN : {  <SOME: "some"> }
TOKEN : {  <EVERY: "every"> }
TOKEN : {  <SATISFIES: "satisfies"> }
TOKEN : {  <TYPESWITCH: "typeswitich"> }
TOKEN : {  <DEFAULTTOKEN: "default"> }
TOKEN : {  <CASE: "case"> }
TOKEN : {  <AS: "as"> }
TOKEN : {  <IF: "if"> }
TOKEN : {  <THEN: "then"> }
TOKEN : {  <ELSE: "else"> }
TOKEN : {  <OR: "or"> }
TOKEN : {  <AND: "and"> }
TOKEN : {  <INSTANCE: "instance"> }
TOKEN : {  <OF: "of"> }
TOKEN : {  <TREAT: "treat"> }
TOKEN : {  <CASTABLE: "castable"> }
TOKEN : {  <CAST: "cast"> }
TOKEN : {  <TO: "to"> }
TOKEN : {  <PLUS: "+"> }
TOKEN : {  <MINUS: "-"> }
TOKEN : {  <MULT: "*"> }
TOKEN : {  <DIV: "div"> }
TOKEN : {  <IDIV: "idiv"> }
TOKEN : {  <MOD: "mod"> }
TOKEN : {  <UNION: "union"> }
TOKEN : {  <ORSYMBOL: "|"> }
TOKEN : {  <INTERSECT: "intersect"> }
TOKEN : {  <EXCEPT: "except"> }
TOKEN : {  <FSLASH: "/"> }
TOKEN : {  <BSLASH: "\\"> }
TOKEN : {  <LBRACKET: "["> }
TOKEN : {  <RBRACKET: "]"> }
TOKEN : {  <VALIDATE: "validate"> }
TOKEN : {  <GLOBAL: "global"> }
TOKEN : {  <CONTEXT: "context"> }
TOKEN : {  <NOTEQUAL: "!="> }
TOKEN : {  <LESSTHAN: "<"> }
TOKEN : {  <LESSTHANEQUAL: "<="> }
TOKEN : {  <GREATERTHAN: ">"> }
TOKEN : {  <GREATERTHANEQUAL: ">="> }
TOKEN : {  <EQ: "eq"> }
TOKEN : {  <NE: "ne"> }
TOKEN : {  <LT: "lt"> }
TOKEN : {  <LE: "le"> }
TOKEN : {  <GT: "gt"> }
TOKEN : {  <GE: "ge"> }
TOKEN : {  <IS: "is"> }
TOKEN : {  <ISNOT: "isnot"> }
TOKEN : {  <LESSTHANLESSTHAN: "<<"> }
TOKEN : {  <GREATERTHANGREATERTHAN: ">>"> }
TOKEN : {  <ATSYMBOL: "@"> }
TOKEN : {  <DOTDOT: ".."> }
TOKEN : {  <CHILD: "child"> }
TOKEN : {  <DESCENDANT: "descendant"> }
TOKEN : {  <ATTRIBUTE: "attribute"> }
TOKEN : {  <SELF: "self"> }
TOKEN : {  <DESCENDANT_OR_SELF: "descendant-or-self"> }
TOKEN : {  <PARENT: "parent"> }
TOKEN : {  <DOCUMENT: "document"> }
TOKEN : {  <ELEMENT: "element"> }
TOKEN : {  <TEXT: "text"> }
TOKEN : {  <CDATASTART: "<![CDATA["> }
TOKEN : {  <CDATAEND: "]]>"> }
TOKEN : {  <PROCESSINGINSTRSTART: "<?"> }
TOKEN : {  <PROCESSINGINSTREND: "?>"> }
TOKEN : {  <COMMENTSTART: "<!--"> }
TOKEN : {  <COMMENTEND: "-->"> }
TOKEN : {  <OPENQUOTE: "\""> }
TOKEN : {  <OPENAPOS: "'"> }
TOKEN : {  <DECLARE: "declare"> }
TOKEN : {  <XMLSPACE: "xmlspace"> }
TOKEN : {  <PRESERVE: "preserve"> }
TOKEN : {  <STRIP: "strip"> }
TOKEN : {  <FUNCTION: "function"> }
TOKEN : {  <ITEM: "item"> }
TOKEN : {  <NILLABLE: "nillable"> }
TOKEN : {  <PROCESSINGINSTRUCTION: "processing-instruction"> }
TOKEN : {  <DOCUMENTNODE: "document-node"> }
TOKEN : {  <COMMENT: "comment"> }
TOKEN : {  <NODE: "node"> }
TOKEN : {  <QUESTION: "?"> }
TOKEN : {  <SCHEMA: "schema"> }
TOKEN : {  <VALIDATION: "validation"> }

// Tokens for JARGON Query Operators
TOKEN : {  <LIKE_OPERATOR: "LIKE"> }
TOKEN : {  <NOT_LIKE_OPERATOR: "NOT LIKE"> }
TOKEN : {  <SOUNDS_LIKE_OPERATOR: "SOUNDS LIKE"> }
TOKEN : {  <SOUNDS_NOT_LIKE_OPERATOR: "SOUNDS NOT LIKE"> }
TOKEN : {  <IN_OPERATOR: "IN"> }
TOKEN : {  <NOT_IN_OPERATOR: "NOT IN"> }
TOKEN : {  <BETWEEN_OPERATOR: "BETWEEN"> }
TOKEN : {  <NOT_BETWEEN_OPERATOR: "NOT BETWEEN"> }

// NC NAME DEFINITION

/* definesc NCName */
TOKEN:
{
	<NCNAME: (<Letter> | "_") (<NCNameChar>)* >
|	<#NCNameChar: <Letter> | <Digit> | "." | "-" | "_" | <CombiningChar> | <Extender> >
|	<#Letter: <BaseChar> | <Ideographic> >
	
|	<#BaseChar:
		  ["A"-"Z"] | ["a"-"z"] | ["\u00c0"-"\u00d6"] | ["\u00d8"-"\u00f6"]
		| ["\u00f8"-"\u00ff"] | ["\u0100"-"\u0131"] | ["\u0134"-"\u013e"] | ["\u0141"-"\u0148"]
		| ["\u014a"-"\u017e"] | ["\u0180"-"\u01c3"] | ["\u01cd"-"\u01f0"] | ["\u01f4"-"\u01f5"]
		| ["\u01fa"-"\u0217"] | ["\u0250"-"\u02a8"] | ["\u02bb"-"\u02c1"] | "\u0386" | ["\u0388"-"\u038a"]
		| "\u038c" | ["\u038e"-"\u03a1"] | ["\u03a3"-"\u03ce"] | ["\u03d0"-"\u03d6"] | "\u03da"
		| "\u03dc" | "\u03de" | "\u03e0" | ["\u03e2"-"\u03f3"] | ["\u0401"-"\u040c"] | ["\u040e"-"\u044f"]
		| ["\u0451"-"\u045c"] | ["\u045e"-"\u0481"] | ["\u0490"-"\u04c4"] | ["\u04c7"-"\u04c8"]
		| ["\u04cb"-"\u04cc"] | ["\u04d0"-"\u04eb"] | ["\u04ee"-"\u04f5"] | ["\u04f8"-"\u04f9"]
		| ["\u0531"-"\u0556"] | "\u0559" | ["\u0561"-"\u0586"] | ["\u05d0"-"\u05ea"] | ["\u05f0"-"\u05f2"]
		| ["\u0621"-"\u063a"] | ["\u0641"-"\u064a"] | ["\u0671"-"\u06b7"] | ["\u06ba"-"\u06be"]
		| ["\u06c0"-"\u06ce"] | ["\u06d0"-"\u06d3"] | "\u06d5" | ["\u06e5"-"\u06e6"] | ["\u0905"-"\u0939"]
		| "\u093d" | ["\u0958"-"\u0961"] | ["\u0985"-"\u098c"] | ["\u098f"-"\u0990"] | ["\u0993"-"\u09a8"]
		| ["\u09aa"-"\u09b0"] | "\u09b2" | ["\u09b6"-"\u09b9"] | ["\u09dc"-"\u09dd"] | ["\u09df"-"\u09e1"]
		| ["\u09f0"-"\u09f1"] | ["\u0a05"-"\u0a0a"] | ["\u0a0f"-"\u0a10"] | ["\u0a13"-"\u0a28"]
		| ["\u0a2a"-"\u0a30"] | ["\u0a32"-"\u0a33"] | ["\u0a35"-"\u0a36"] | ["\u0a38"-"\u0a39"]
		| ["\u0a59"-"\u0a5c"] | "\u0a5e" | ["\u0a72"-"\u0a74"] | ["\u0a85"-"\u0a8b"] | "\u0a8d"
		| ["\u0a8f"-"\u0a91"] | ["\u0a93"-"\u0aa8"] | ["\u0aaa"-"\u0ab0"] | ["\u0ab2"-"\u0ab3"]
		| ["\u0ab5"-"\u0ab9"] | "\u0abd" | "\u0ae0" | ["\u0b05"-"\u0b0c"] | ["\u0b0f"-"\u0b10"]
		| ["\u0b13"-"\u0b28"] | ["\u0b2a"-"\u0b30"] | ["\u0b32"-"\u0b33"] | ["\u0b36"-"\u0b39"]
		| "\u0b3d" | ["\u0b5c"-"\u0b5d"] | ["\u0b5f"-"\u0b61"] | ["\u0b85"-"\u0b8a"]
		| ["\u0b8e"-"\u0b90"] | ["\u0b92"-"\u0b95"] | ["\u0b99"-"\u0b9a"] | "\u0b9c" | ["\u0b9e"-"\u0b9f"]
		| ["\u0ba3"-"\u0ba4"] | ["\u0ba8"-"\u0baa"] | ["\u0bae"-"\u0bb5"] | ["\u0bb7"-"\u0bb9"]
		| ["\u0c05"-"\u0c0c"] | ["\u0c0e"-"\u0c10"] | ["\u0c12"-"\u0c28"] | ["\u0c2a"-"\u0c33"]
		| ["\u0c35"-"\u0c39"] | ["\u0c60"-"\u0c61"] | ["\u0c85"-"\u0c8c"] | ["\u0c8e"-"\u0c90"]
		| ["\u0c92"-"\u0ca8"] | ["\u0caa"-"\u0cb3"] | ["\u0cb5"-"\u0cb9"] | "\u0cde" | ["\u0ce0"-"\u0ce1"]
		| ["\u0d05"-"\u0d0c"] | ["\u0d0e"-"\u0d10"] | ["\u0d12"-"\u0d28"] | ["\u0d2a"-"\u0d39"]
		| ["\u0d60"-"\u0d61"] | ["\u0e01"-"\u0e2e"] | "\u0e30" | ["\u0e32"-"\u0e33"] | ["\u0e40"-"\u0e45"]
		| ["\u0e81"-"\u0e82"] | "\u0e84" | ["\u0e87"-"\u0e88"] | "\u0e8a" | "\u0e8d" | ["\u0e94"-"\u0e97"]
		| ["\u0e99"-"\u0e9f"] | ["\u0ea1"-"\u0ea3"] | "\u0ea5" | "\u0ea7" | ["\u0eaa"-"\u0eab"]
		| ["\u0ead"-"\u0eae"] | "\u0eb0" | ["\u0eb2"-"\u0eb3"] | "\u0ebd" | ["\u0ec0"-"\u0ec4"]
		| ["\u0f40"-"\u0f47"] | ["\u0f49"-"\u0f69"] | ["\u10a0"-"\u10c5"] | ["\u10d0"-"\u10f6"] | "\u1100"
		| ["\u1102"-"\u1103"] | ["\u1105"-"\u1107"] | "\u1109" | ["\u110b"-"\u110c"] | ["\u110e"-"\u1112"]
		| "\u113c" | "\u113e" | "\u1140" | "\u114c" | "\u114e" | "\u1150" | ["\u1154"-"\u1155"] | "\u1159"
		| ["\u115f"-"\u1161"] | "\u1163" | "\u1165" | "\u1167" | "\u1169" | ["\u116d"-"\u116e"]
		| ["\u1172"-"\u1173"] | "\u1175" | "\u119e" | "\u11a8" | "\u11ab" | ["\u11ae"-"\u11af"]
		| ["\u11b7"-"\u11b8"] | "\u11ba" | ["\u11bc"-"\u11c2"] | "\u11eb" | "\u11f0" | "\u11f9"
		| ["\u1e00"-"\u1e9b"] | ["\u1ea0"-"\u1ef9"] | ["\u1f00"-"\u1f15"] | ["\u1f18"-"\u1f1d"]
		| ["\u1f20"-"\u1f45"] | ["\u1f48"-"\u1f4d"] | ["\u1f50"-"\u1f57"] | "\u1f59" | "\u1f5b" | "\u1f5d"
		| ["\u1f5f"-"\u1f7d"] | ["\u1f80"-"\u1fb4"] | ["\u1fb6"-"\u1fbc"] | "\u1fbe" | ["\u1fc2"-"\u1fc4"]
		| ["\u1fc6"-"\u1fcc"] | ["\u1fd0"-"\u1fd3"] | ["\u1fd6"-"\u1fdb"] | ["\u1fe0"-"\u1fec"]
		| ["\u1ff2"-"\u1ff4"] | ["\u1ff6"-"\u1ffc"] | "\u2126" | ["\u212a"-"\u212b"] | "\u212e"
		| ["\u2180"-"\u2182"] | ["\u3041"-"\u3094"] | ["\u30a1"-"\u30fa"] | ["\u3105"-"\u312c"]
		| ["\uac00"-"\ud7a3"] >
|	<#Ideographic :    ["\u4e00"-"\u9fa5"] | "\u3007" | ["\u3021"-"\u3029"] > 
|	<#CombiningChar :
		  ["\u0300"-"\u0345"] | ["\u0360"-"\u0361"] | ["\u0483"-"\u0486"] | ["\u0591"-"\u05a1"]
		| ["\u05a3"-"\u05b9"] | ["\u05bb"-"\u05bd"] | "\u05bf" | ["\u05c1"-"\u05c2"] | "\u05c4"
		| ["\u064b"-"\u0652"] | "\u0670" | ["\u06d6"-"\u06dc"] | ["\u06dd"-"\u06df"]
		| ["\u06e0"-"\u06e4"] | ["\u06e7"-"\u06e8"] | ["\u06ea"-"\u06ed"] | ["\u0901"-"\u0903"]
		| "\u093c" | ["\u093e"-"\u094c"] | "\u094d" | ["\u0951"-"\u0954"] | ["\u0962"-"\u0963"]
		| ["\u0981"-"\u0983"] | "\u09bc" | "\u09be" | "\u09bf" | ["\u09c0"-"\u09c4"] | ["\u09c7"-"\u09c8"]
		| ["\u09cb"-"\u09cd"] | "\u09d7" | ["\u09e2"-"\u09e3"] | "\u0a02" | "\u0a3c" | "\u0a3e"
		| "\u0a3f" | ["\u0a40"-"\u0a42"] | ["\u0a47"-"\u0a48"] | ["\u0a4b"-"\u0a4d"] | ["\u0a70"-"\u0a71"]
		| ["\u0a81"-"\u0a83"] | "\u0abc" | ["\u0abe"-"\u0ac5"] | ["\u0ac7"-"\u0ac9"] | ["\u0acb"-"\u0acd"]
		| ["\u0b01"-"\u0b03"] | "\u0b3c" | ["\u0b3e"-"\u0b43"] | ["\u0b47"-"\u0b48"] | ["\u0b4b"-"\u0b4d"]
		| ["\u0b56"-"\u0b57"] | ["\u0b82"-"\u0b83"] | ["\u0bbe"-"\u0bc2"] | ["\u0bc6"-"\u0bc8"]
		| ["\u0bca"-"\u0bcd"] | "\u0bd7" | ["\u0c01"-"\u0c03"] | ["\u0c3e"-"\u0c44"] | ["\u0c46"-"\u0c48"]
		| ["\u0c4a"-"\u0c4d"] | ["\u0c55"-"\u0c56"] | ["\u0c82"-"\u0c83"] | ["\u0cbe"-"\u0cc4"]
		| ["\u0cc6"-"\u0cc8"] | ["\u0cca"-"\u0ccd"] | ["\u0cd5"-"\u0cd6"] | ["\u0d02"-"\u0d03"]
		| ["\u0d3e"-"\u0d43"] | ["\u0d46"-"\u0d48"] | ["\u0d4a"-"\u0d4d"] | "\u0d57" | "\u0e31"
		| ["\u0e34"-"\u0e3a"] | ["\u0e47"-"\u0e4e"] | "\u0eb1" | ["\u0eb4"-"\u0eb9"]
		| ["\u0ebb"-"\u0ebc"] | ["\u0ec8"-"\u0ecd"] | ["\u0f18"-"\u0f19"] | "\u0f35" | "\u0f37" | "\u0f39"
		| "\u0f3e" | "\u0f3f" | ["\u0f71"-"\u0f84"] | ["\u0f86"-"\u0f8b"] | ["\u0f90"-"\u0f95"] | "\u0f97"
		| ["\u0f99"-"\u0fad"] | ["\u0fb1"-"\u0fb7"] | "\u0fb9" | ["\u20d0"-"\u20dc"] | "\u20e1"
		| ["\u302a"-"\u302f"] | "\u3099" | "\u309a" >
|	<#Digit:
		  ["0"-"9"] | ["\u0660"-"\u0669"] | ["\u06f0"-"\u06f9"] | ["\u0966"-"\u096f"]
		| ["\u09e6"-"\u09ef"] | ["\u0a66"-"\u0a6f"] | ["\u0ae6"-"\u0aef"] | ["\u0b66"-"\u0b6f"]
		| ["\u0be7"-"\u0bef"] | ["\u0c66"-"\u0c6f"] | ["\u0ce6"-"\u0cef"] | ["\u0d66"-"\u0d6f"]
		| ["\u0e50"-"\u0e59"] | ["\u0ed0"-"\u0ed9"] | ["\u0f20"-"\u0f29"] >
|	<#Extender :
		  "\u00b7" | "\u02d0" | "\u02d1" | "\u0387" | "\u0640" | "\u0e46" | "\u0ec6" | "\u3005"
		| ["\u3031"-"\u3035"] | ["\u309d"-"\u309e"] | ["\u30fc"-"\u30fe"] >

}


TOKEN : /* S */
{
  < S: " " | "	" | "\n" | "\r" >
}


TOKEN :{
	<Literal : <StringLiteral> | <NumericLiteral> >
|   <#StringLiteral :   (("\"" (~["\""])* "\"") | ("'" (~["'"])* "'")) >
|   <#NumericLiteral : <IntegerLiteral> | <DecimalLiteral> |<DoubleLiteral> >
|   <#IntegerLiteral :   <Digits> >
|   <#DecimalLiteral :   ("." <Digits>) | ( <Digits> "." (["0" - "9"])* ) >
|   <#DoubleLiteral :    ( ("." <Digits>) | ( <Digits> ("." ( ["0" - "9"])*)? )) ( ["e","E"] ) ([ "+","-" ])? <Digits> >
|   <#Digits : (["0" - "9"])+  >
}

TOKEN : /* Char - 10000-10FFFF*/
{
  < CHAR: "	" | "\n" | "\r" |[" "-"\ud7ff"]|["\ue000"-"\ufffd"]  >
}


TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}

TOKEN : /* DIGIT */
{
  < DIGIT: (["0"-"9"])+>  
}

TOKEN : /* IDENTIFIER_LETTER */
{
  < IDENTIFIER_LETTER: ["_","a"-"z","A"-"Z"]>
}


TOKEN : /* IDENTIFIER */
{
  < IDENTIFIER: <IDENTIFIER_LETTER> (<IDENTIFIER_LETTER>|<DIGIT>)* >
}

TOKEN : /* HEXDIGIT */
{
  < HEXDIGIT: (["0"-"9","a"-"f","A"-"F"])+>
}



TOKEN : /* STRING_LITERAL */
{
< STRING_LITERAL1:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

TOKEN : /* STRING_LITERAL */
{
< STRING_LITERAL:(("\"" (~["\""])* "\"") | ("'" (~["'"])* "'")) >
}


ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  MatrixQueryExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ /*";"*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void MatrixQueryExpression() : {}
{
  Module()
}

void Module() : {}
{
  (MainModule() | LibraryModule())
}

void MainModule() : {}
{
	Prolog() QueryBody()
}

void LibraryModule(): {}
{
	(ModuleDecl() Prolog())
}


void ModuleDecl()             :
{/*@bgen(jjtree) NotSupported */
        ASTNotSupported jjtn000 = new ASTNotSupported(JJTNOTSUPPORTED);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t1;
}
{/*@bgen(jjtree) NotSupported */
        try {
/*@egen*/
	t1= <MODULE> StringLiteral()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		throw new ParseException("ModuleDecl - Feature Not Supported in Matrix: "+t1);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Prolog() : {}
{
	(Version())? (NamespaceDecl()| XmlSpaceDecl() | DefaultNamespaceDecl() | DefaultCollationDecl() | SchemaImport() | ModuleImport() | VarDefn() | ValidationDecl() )* (FunctionDefn())*
}

void Version()              :
{/*@bgen(jjtree) NotSupported */
        ASTNotSupported jjtn000 = new ASTNotSupported(JJTNOTSUPPORTED);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t1;
}
{/*@bgen(jjtree) NotSupported */
        try {
/*@egen*/
	t1 = <XQUERY> <VERSION> StringLiteral()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 	
	{
		throw new ParseException("Version - Feature Not Supported in Matrix:"+t1);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ModuleImport()              : 
{/*@bgen(jjtree) NotSupported */
        ASTNotSupported jjtn000 = new ASTNotSupported(JJTNOTSUPPORTED);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t1;
}
{/*@bgen(jjtree) NotSupported */
        try {
/*@egen*/
	t1 = <IMPORT> <MODULE> (<NAMESPACE> NCName() <EQUAL>)?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 	
	{
		throw new ParseException("ModuleImport - Feature Not Supported in Matrix:"+t1);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VarDefn(): {}
{
	//("VarDefn ")
	<DEFINE> S() <VARIABLE> <DOLLAR> VarName() (TypeDeclaration())? ((<LCURLYBRACE> Expr() <RCURLYBRACE>) | <EXTERNAL>)
}

void QueryBody() : {}
{
	Expr()
}

String Expr() : 
{
	String expr="";
	String tempExpr="";
	Token tok;
}
{
	expr = ExprSingle() 
	(
		tok = <COMMA> 
		{expr += tok.image;}
		tempExpr = ExprSingle()
		{expr+=tempExpr;}
	)*
	{return expr;}
}

String ExprSingle() : 
{
	String expression = null; 
}
{
	(
	FLWORExpr() 
	| QuantifiedExpr() 
	| TypeswitchExpr() 
	| IfExpr() 
	| expression =OrExpr()
	)
	{MatrixUtil.toLog("MatrixQueryParser-ExprSingle()- isReturnClauseInProcess:"+isReturnClauseInProcess,MatrixUtil.DEBUG_LOG);}
	{MatrixUtil.toLog("EXPR SINGLE expression:"+expression,MatrixUtil.DEBUG_LOG);}
	{
		// Processing Selection Fields For Return Clause
		if(isReturnClauseInProcess)
		{
			if(expression!=null)
			{
				if(expression.trim().length()>0)
					queryProcessor.getReturnClause().addSelectionFieldName(expression);
			}	
		}	
	}
	{MatrixUtil.toLog("EXPR SINGLE expression:"+expression,MatrixUtil.DEBUG_LOG);}
	{ return expression; }
}

void FLWORExpr() : 
{
	String returnExpression;
}
{
	( ForClause() | LetClause())+  (WhereClause())? (OrderByClause())? <RETURN>
	{isReturnClauseInProcess = true;}  
	returnExpression = ExprSingle()
	{MatrixUtil.toLog("RETURN EXPRESSION :"+returnExpression,MatrixUtil.DEBUG_LOG);}
	{isReturnClauseInProcess = false;}  
	{queryProcessor.getReturnClause().setReturnExpression(returnExpression);}
	{queryProcessor.getReturnClause().fixToRemoveReturnExpresionFromSelectionFieldNames();}
}

void ForClause() : 
{ 
	String varName;
	String forExpression ="";
}
{
	<FOR><DOLLAR> 
	varName = VarName() 
	(TypeDeclaration())? (PositionalVar())? <IN>  
	forExpression = ExprSingle() 
	(<COMMA> <DOLLAR> VarName() (TypeDeclaration())? (PositionalVar())? <IN> ExprSingle())*
	{ 
		
		queryProcessor.getForClause().setVariableName(varName);
		queryProcessor.getForClause().setFunctionName(forExpression.substring(0,forExpression.indexOf('(')));
		queryProcessor.getForClause().setFunctionParameter(forExpression.substring(forExpression.indexOf('"')+1,forExpression.lastIndexOf('"')));
		
		
	}
}

void PositionalVar() : {}
{
	(<AT> <DOLLAR>VarName())
}

void LetClause() : {}
{
	<LET> <DOLLAR>VarName() (TypeDeclaration())? <COLON><EQUAL> ExprSingle() (<COMMA> <DOLLAR>VarName() (TypeDeclaration())? <COLON><EQUAL> ExprSingle())*
}

void WhereClause() : 
{
	String whereExpression;
}
{
	( 
		<WHERE> 
		whereExpression = Expr() 
		
		{queryProcessor.getWhereClause().setWhereExpression(whereExpression);}
	)
}

void OrderByClause() : {}
{
	((<ORDER> <BY>)|(<STABLE> <ORDER> <BY>)) OrderSpecList()
}

void OrderSpecList() : {}
{
	OrderSpec() (<COMMA> OrderSpec())*
}

void OrderSpec() : {}
{
	ExprSingle() OrderModifier() 
}

void OrderModifier() : {}
{
	(<ASCENDING>|<DESCENDING>)? ((<EMPTY> <GREATEST>) |( <EMPTY> <LEAST>))? (<COLLATION> StringLiteral())?
}

void QuantifiedExpr() : {}
{
	((<SOME> <DOLLAR>) | (<EVERY> <DOLLAR>)) VarName() (TypeDeclaration())? <IN> ExprSingle() (<COMMA> <DOLLAR>VarName() (TypeDeclaration())? <IN> ExprSingle())* <SATISFIES> ExprSingle()
}

void TypeswitchExpr() : {}
{
	<TYPESWITCH> <LPAR>Expr()<RPAR> (CaseClause())+ <DEFAULTTOKEN> (<DOLLAR>VarName())? <RETURN> ExprSingle()
}

void CaseClause() : {}
{
	<CASE> (<DOLLAR> VarName() <AS>)? SequenceType() <RETURN> Expr()
}

void IfExpr() : {}
{
	<IF> <LPAR>Expr()<RPAR> <THEN>Expr() <ELSE>ExprSingle()
}

String OrExpr() : 
{
	String expr="";
	String tempExpr="";
	Token orToken;
}
{
	expr= AndExpr() 
	( 	
		orToken = <OR> 
		tempExpr = AndExpr() 
		{	expr = expr + orToken.image + tempExpr;}
	)*
	
	{MatrixUtil.toLog("OR EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String AndExpr() : 
{
	String expr="";
	String tempExpr="";
	Token andToken;
}
{
	expr = InstanceofExpr() 
	(
		andToken = <AND> 
		tempExpr = InstanceofExpr() 
		{ expr = expr + andToken.image + tempExpr ; }
	)*
	{MatrixUtil.toLog("AND EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String InstanceofExpr() : 
{
	String expr="";
}
{
	expr = TreatExpr() 
	(<INSTANCE> <OF> SequenceType() )?
	{MatrixUtil.toLog("INSTANCE OF EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String TreatExpr() : 
{
	String expr="";
}
{
	expr = CastableExpr() 
	( <TREAT> <AS> SequenceType() )?
	{MatrixUtil.toLog("TREAT EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String CastableExpr() : 
{
	String expr="";
}
{
	expr = CastExpr() 
	( <CASTABLE> <AS> SingleType() )?
	{MatrixUtil.toLog("CASTABLE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String CastExpr() : 
{
	String expr="";
}
{
	expr = ComparisonExpr() 
	( <CAST> <AS> SingleType() )?
	{MatrixUtil.toLog("CAST EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{ return expr ;} 
}

String ComparisonExpr() : 
{
	String expr="";
	String tempExpr="";
	String wVar="";
	String wOpr="";
	String wVal="";
}
{
	expr = RangeExpr()
	{wVar = expr;} 
	( (ValueComp()
	  | tempExpr = GeneralComp()
	  	{wOpr = tempExpr;}
	  | NodeComp()
	  | OrderComp()) 
	  {expr = expr + tempExpr;}
	  tempExpr = RangeExpr() 
	  {expr = expr + tempExpr;}
	  {wVal = tempExpr;}
	  {
	  	MatrixQueryConditionClause condClause = new MatrixQueryConditionClause();
	  	condClause.setConditionClause(expr);
	  	condClause.setConditionVariable(wVar);
	  	condClause.setOperator(wOpr);
	  	condClause.setConditionValue(wVal);
	  	queryProcessor.getWhereClause().addCondition(condClause);
	  	//MatrixUtil.toLog("Comparison Expr : "+condClause.getConditionClause(),MatrixUtil.DEBUG_LOG);
	  }
	  )?
	  
	  {MatrixUtil.toLog("COMPARISON EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	  {return expr;}
}

String RangeExpr() : 
{
	String expr ="";
}
{
	expr = AdditiveExpr() 
	( <TO> AdditiveExpr() )?
	 {MatrixUtil.toLog("RANGE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String AdditiveExpr() : 
{
	String expr="";
}
{
	expr = MultiplicativeExpr() 
	( (<PLUS> | <MINUS>) MultiplicativeExpr() )*
	 {MatrixUtil.toLog("ADDITIVE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String MultiplicativeExpr() : 
{
	String expr="";
}
{
	expr = UnaryExpr() 
	( (<MULT> | <DIV> | <IDIV> | <MOD>) UnaryExpr() )*
	 {MatrixUtil.toLog("MULTIPLICATIVE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String UnaryExpr() : 
{
	String expr="";
}
{
	(<MINUS> | <PLUS>)* 
	expr = UnionExpr()
	 {MatrixUtil.toLog("UNARY EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String UnionExpr() : 
{
	String expr="";
}
{
	expr = IntersectExceptExpr() 
	( (<UNION> | <ORSYMBOL>) IntersectExceptExpr() )*
	 {MatrixUtil.toLog("UNION EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String IntersectExceptExpr() : 
{
	String expr="";
}
{
	expr = ValueExpr() 
	( (<INTERSECT> | <EXCEPT>) ValueExpr() )* 
	 {MatrixUtil.toLog("INTERSECT EXCEPT EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String ValueExpr() : 
{
	String expr="";
}
{
	ValidateExpr() 
	| expr  = PathExpr()
	 {MatrixUtil.toLog("VALUE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String PathExpr() : 
{
	String expr = "";
	Token fSlash;
	String tempExpr="";
}
{
	fSlash = <FSLASH>
	{expr = fSlash.image;}
	(
		tempExpr = RelativePathExpr()
		{expr = expr + tempExpr;}
	)?
	| 
	fSlash = <FSLASH>
	{ expr = expr + fSlash.image;}
	fSlash = <FSLASH> 
	{ expr = expr + fSlash.image;}
	tempExpr = RelativePathExpr()
	{expr = expr+tempExpr;}
	| 
	tempExpr = RelativePathExpr()
	{expr = expr + tempExpr;}
	 {MatrixUtil.toLog("PATH EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
	
 
}

String RelativePathExpr() : 
{
	String expr="";
	String tempExpr="";
	Token fSlash;
}
{
	expr = StepExpr() 
	(
		( 
			fSlash = <FSLASH> 
			{expr = expr + fSlash.image;}
			| fSlash = <FSLASH>
			  {expr = expr + fSlash.image;}
			  fSlash = <FSLASH>
			  {expr = expr + fSlash.image;}
		)
			 
		tempExpr = StepExpr()
		{expr = expr + tempExpr;}
	)*
	
	 {MatrixUtil.toLog("RELATIVE EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return(expr);}
}

String StepExpr() : 
{
	String expr="";
}
{
	(expr = FilterStep() 
	|expr = AxisStep() ) // Avoid conflict for FunctionCall that starts with QName and AxisStep ..
	
	 {MatrixUtil.toLog("STEP EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String AxisStep() : 
{
	String expr="";
	String tempExpr="";
}
{
	(
		expr = ForwardStep() 
		| expr= ReverseStep()
	) 
	tempExpr = Predicates()
	{expr = expr + tempExpr;}
	 {MatrixUtil.toLog("AXIS STEP EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String FilterStep() : 
{
	String expr="";
	String tempExpr="";
}
{
	expr = PrimaryExpr() 
	tempExpr = Predicates()
	{expr += tempExpr;}
	
	 {MatrixUtil.toLog("FILTER EXPR : "+expr,MatrixUtil.DEBUG_LOG);}
	{return expr;}
}

String PrimaryExpr() : 
{
	String expr="";
	String tempExpr="";
	Token dollar;
}
{
	expr = Literal() 
	{return(expr);}
	| expr = FunctionCall() 
		{return(expr);}
	| (
		dollar = <DOLLAR>
		tempExpr = VarName()
		{expr = dollar.image+tempExpr;}
		{return(expr);}
	  ) 
	| expr = ParanthesizedExpr() 
		{return(expr);}
	| expr = Constructor()
		{return(expr);}
}

String Predicates() : 
{
	String expr="";
	String tempExpr="";
	Token lBracket;
	Token rBracket;
}
{
	(
		lBracket = <LBRACKET>
		{expr = lBracket.image;}
		tempExpr = Expr()
		{expr = expr + tempExpr;}
		rBracket = <RBRACKET>
		{expr = expr+rBracket.image;}
	)*
	{return(expr);}
}

void ValidateExpr() : {}
{
	((<VALIDATE> <LCURLYBRACE>) | (<VALIDATE> <GLOBAL> <LCURLYBRACE>) | (<VALIDATE> <CONTEXT> SchemaContextLocation() "{") | ("validate" SchemaMode() (SchemaContext())? <LCURLYBRACE>)) Expr() <RCURLYBRACE>
}

void SchemaContext() : {}
{
	(<CONTEXT> SchemaContextLocation()) | <GLOBAL>
}

String Constructor() : 
{
	String consExpr = null;
}
{
	(
	  (consExpr = ElementConstructor())
	| (XmlComment())
	| (XmlProcessingInstruction())
	| (CdataSection())
	| (ComputedDocumentConstructor())
	| (ComputedElementConstructor())
	| (ComputedAttributeConstructor())
	| (ComputedTextConstructor())
	)

	{return consExpr;}
}

String GeneralComp() : 
{
	Token operator;
}
{
	(
	operator = <EQUAL> 
	| operator = <NOTEQUAL> 
	| operator =<LESSTHAN> 
	| operator =<LESSTHANEQUAL> 
	| operator =<GREATERTHAN> 
	| operator =<GREATERTHANEQUAL>
	| operator = <LIKE_OPERATOR>
	| operator = <NOT_LIKE_OPERATOR>
	| operator = <SOUNDS_LIKE_OPERATOR>
	| operator = <SOUNDS_NOT_LIKE_OPERATOR>
	| operator = <IN_OPERATOR>
	| operator = <NOT_IN_OPERATOR>
	| operator = <BETWEEN_OPERATOR>
	| operator = <NOT_BETWEEN_OPERATOR>
	)
	{return operator.image;}
}

void ValueComp() : {}
{
	<EQ> | <NE> | <LT> | <LE> | <GT> | <GE>
}

void NodeComp() : {}
{
	<IS> | <ISNOT>
}

void OrderComp() : {}
{
	<LESSTHANLESSTHAN> | <GREATERTHANGREATERTHAN>
}

String ForwardStep() : 
{
	String expr="";
	String tempExpr="";
}
{
	(ForwardAxis() NodeTest()) 
	| expr = AbbreviatedForwardStep()
	{return(expr);}
}

String ReverseStep() : 
{
	String expr="";
	String tempExpr="";
}
{
	(ReverseAxis() NodeTest()) 
	| expr = AbbreviatedReverseStep()
	{return expr;}
}

String AbbreviatedForwardStep() : 
{
	String expr="";
	String tempExpr="";
	Token tok;
}
{
	tok = <DOT> 
	{expr = tok.image;}
	| (
		tok = <ATSYMBOL> 
		{expr = expr + tok.image;}
		tempExpr = NameTest()
		{expr = expr + tempExpr;}
	  ) 
	| tempExpr = NodeTest()
	  {expr = expr + tempExpr;}
	{return expr;}
}

String AbbreviatedReverseStep() : 
{
	Token tok;
}
{
	tok = <DOTDOT>
	{return tok.image;}
}

void ForwardAxis() : {}
{
	(<CHILD> <COLONCOLON>)
	| (<DESCENDANT> <COLONCOLON>)
	| (<ATTRIBUTE> <COLONCOLON>)
	| (<SELF> <COLONCOLON>)
	| (<DESCENDANT_OR_SELF> <COLONCOLON>)

}

void ReverseAxis() : {}
{
	<PARENT> <COLONCOLON>
}

String NodeTest() : 
{
	String expr="";
}
{
	(	
		KindTest() 
		| expr= NameTest ()
	)
	{return expr;}
}

String NameTest() : 
{
	String expr="";
}
{
	(
		expr = QName() 
		| expr= Wildcard()
	)
	{return expr;}
}

String Wildcard() : 
{
	Token t1,t2;
	String expr="";
	String tempExpr="";
}
{
	t1 = <MULT> 
	{expr = t1.image;}
	| (
		tempExpr = NCName() 
		t1= <COLON> 
		t2 = <MULT>
		{expr+=tempExpr+t1.image+t2.image;}
		)
	| (
		t1= <MULT>
		t2 = <COLON>
		tempExpr = NCName()
		{expr+=t1.image+t2.image+tempExpr;}
	  )	
		{return expr;}
}

String Literal() : 
{
	Token lit;
	String literal;
}
{
	//(<NumericLiteral> | <StringLiteral>)
	lit = <Literal>
	{	
		literal = lit.image;
		return literal;
	}
}

void NumericLiteral() : {}
{
	IntegerLiteral() | DecimalLiteral() | DoubleLiteral()
}

String ParanthesizedExpr() : 
{
	String expr="";
	String tempExpr="";
	Token lPar;
	Token rPar;
}
{
	lPar = <LPAR> 
	{expr = lPar.image;}
	(
	tempExpr = Expr()
	{expr = expr+tempExpr;}
	)? 
	rPar = <RPAR>
	{expr = expr + rPar.image;}
	{return expr;}
}

String FunctionCall() : 
{
	String functionName="";
	String functionExpression="";
	String tempFunctionExpression="";
	Token t1,t2;
}
{
	functionName = QName() 
	{functionExpression+=functionName;}
	t1= <LPAR> 
	{functionExpression+= t1.image;}
	(
		tempFunctionExpression = ExprSingle() 
		{functionExpression+= tempFunctionExpression;}
		(
			t2 = <COMMA> 
			{functionExpression+= t2.image;}
			tempFunctionExpression = ExprSingle()
			{	functionExpression +=tempFunctionExpression; }
		)*
	)? 
	t1 = <RPAR>
	{functionExpression+= t1.image;}
	{return functionExpression;}
}

String ElementConstructor() : 
{
	String elemConsExpr = null;
	String tempExpression = null;
	Token t1,t2,t3;
}
{
	//<LESSTHAN> QName() AttributeList() (<FSLASH><GREATERTHAN>|(<GREATERTHAN> (ElementContent())* <LESSTHAN><FSLASH> QName() (S())? <GREATERTHAN>) )
	t1= <LESSTHAN> 
	{ elemConsExpr =t1.image;}
	
	tempExpression = QName() 
	{elemConsExpr+=tempExpression;}
	
	AttributeList() // Not Supported
	
	t1= <GREATERTHAN> 
	{elemConsExpr+=t1.image;}
	
	(
		tempExpression = ElementContent()
		{elemConsExpr+=tempExpression;}
	)* 
	
	t1= <LESSTHAN>
	{elemConsExpr+=t1.image;}
	
	t1= <FSLASH> 
	{elemConsExpr+=t1.image;}
	
	tempExpression = QName() 
	{elemConsExpr+=tempExpression;}
	
	t1= <GREATERTHAN>
	{elemConsExpr+=t1.image;}
	
	{return elemConsExpr;}
}

void ComputedDocumentConstructor() : {}
{
	<DOCUMENT> <LCURLYBRACE>Expr()<RCURLYBRACE>
}

void ComputedElementConstructor() : {}
{
	(<ELEMENT> QName() <LCURLYBRACE> | (<ELEMENT> <LCURLYBRACE> Expr() <RCURLYBRACE> <LCURLYBRACE>)) (Expr())? <RCURLYBRACE>
}

void ComputedAttributeConstructor() : {}
{
	(<ATTRIBUTE> QName() <LCURLYBRACE> | (<ATTRIBUTE> <LCURLYBRACE> Expr() <RCURLYBRACE> <LCURLYBRACE>)) (Expr())? <RCURLYBRACE>
}

void ComputedTextConstructor() : {}
{
	<TEXT> <LCURLYBRACE> (Expr())? <RCURLYBRACE> 
}

void CdataSection() : {}
{
	<CDATASTART> (Char())* <CDATAEND>
}

void XmlProcessingInstruction() : {}
{
	<PROCESSINGINSTRSTART> PITarget() (Char())* <PROCESSINGINSTREND>
}

void XmlComment() : {}
{
	<COMMENTSTART> (Char())* <COMMENTEND>
}

String ElementContent() : 
{
	String elConExpr = null;
}
{
	(
	(ElementContentChar())
	| (<LCURLYBRACE><LCURLYBRACE>)
	|  (<RCURLYBRACE><RCURLYBRACE>)
	| (elConExpr = ElementConstructor())
	| (elConExpr = EnclosedExpr())
	| (CdataSection())
	| (CharRef())
	| (PredefinedEntityRef())
	| (XmlComment())
	| (XmlProcessingInstruction())
	)
	{return elConExpr;}
}

void AttributeList() : {}
{
	(S() (QName() (S())? <EQUAL> (S())? AttributeValue())?)*
}

void AttributeValue() : {}
{
	(<OPENQUOTE> (EscapeQuot() | AttributeValueContent())* <OPENQUOTE>)
	| (<OPENAPOS> (EscapeApos() | AttributeValueContent())* <OPENAPOS>)

}

void AttributeValueContent() : {}
{
	QuoteAttributeContentChar()
	| AposAttributeContentChar()
	| CharRef()
	| <LCURLYBRACE><LCURLYBRACE>
	| <RCURLYBRACE><RCURLYBRACE>
	| EnclosedExpr()
	| PredefinedEntityRef()
	

}

String EnclosedExpr() : 
{
	String enclExpr = null;
	String tempEnclExpr = null;
	Token t1;
}
{
	t1= <LCURLYBRACE>
	{enclExpr = t1.image;}
	
	tempEnclExpr = Expr()
	{enclExpr+=tempEnclExpr;}
	
	t1= <RCURLYBRACE>
	{enclExpr += t1.image;}
	
	{return (enclExpr); }
}

void XmlSpaceDecl() : {}
{
	<DECLARE> <XMLSPACE> <EQUAL> (<PRESERVE> | <STRIP>)
}

void DefaultCollationDecl() : {}
{
	<DEFAULTTOKEN> <COLLATION> <EQUAL> StringLiteral()
}

void NamespaceDecl() : {}
{
	<DECLARE> <NAMESPACE> NCName() <EQUAL> StringLiteral() 
}

void DefaultNamespaceDecl() : {}
{
	((<DEFAULTTOKEN> <ELEMENT>) | (<DEFAULTTOKEN> <FUNCTION>)) <NAMESPACE> <EQUAL> StringLiteral()
}

void FunctionDefn() : {}
{
	<DEFINE> <FUNCTION> QName() <LPAR> (ParamList())? (<RPAR> | (<RPAR> <AS> SequenceType())) (EnclosedExpr() | <EXTERNAL>)
}

void ParamList() : {}
{
	Param() (<COMMA> Param())*
}

void Param() : {}
{
	<DOLLAR>VarName() (TypeDeclaration())?
}

void TypeDeclaration() : {}
{
	<AS> SequenceType()
}

void SingleType() : {}
{
	AtomicType() (<QUESTION>)?
}

void SequenceType() : {}
{
	(ItemType() (OccurrenceIndicator())?)
	| (<EMPTY> <LPAR> <RPAR>)

}

void AtomicType() : {}
{
	QName()
}

void ItemType() : {}
{
	AtomicType() | KindTest() | (<ITEM> <LPAR> <RPAR>)
}

void KindTest() : {}
{
	DocumentTest()
| ElementTest()
| AttributeTest()
| ProcessingInstructionTest()
| CommentTest()
| TextTest()
| AnyKindTest()
 
}

void ElementTest() : {}
{
	<ELEMENT> <LPAR> ((SchemaContextPath() LocalName())
	| (NodeName() (<COMMA> TypeName() (<NILLABLE>)?)?))? <RPAR>

}

void AttributeTest() : {}
{
	<ATTRIBUTE> <LPAR> ((SchemaContextPath() <ATSYMBOL> LocalName())
	| (<ATSYMBOL> NodeName() (<COMMA> TypeName())?))? <RPAR>

}

void ProcessingInstructionTest() : {}
{
	<PROCESSINGINSTRUCTION> <LPAR> (StringLiteral())? <RPAR>
}

void DocumentTest() : {}
{
	<DOCUMENTNODE> <LPAR> (ElementTest())? <RPAR>
}

void CommentTest() : {}
{
	<COMMENT> <LPAR> <RPAR> 
}

void TextTest() : {}
{
	<TEXT> <LPAR> <RPAR> 
}

void AnyKindTest() : {}
{
	<NODE> <LPAR> <RPAR> 
}

void SchemaContextPath() : {}
{
	SchemaGlobalContext() <FSLASH> (SchemaContextStep() <FSLASH>)* 
}

void SchemaContextLocation() : {}
{
	(SchemaContextPath() QName()) | SchemaGlobalTypeName()
}

void LocalName() : {}
{
	QName()
}

void NodeName() : {}
{
	QName() | <MULT>
}

void TypeName() : {}
{
	QName() | <MULT>
}

void OccurrenceIndicator() : {}
{
	<QUESTION> | <MULT> | <PLUS>
}

void ValidationDecl() : {}
{
	(<VALIDATION> <LAX>) | (<VALIDATION> <STRICT>) | (<VALIDATION> <SKIPTOKEN>)
}

void SchemaImport() : {}
{
	(<IMPORT> <SCHEMA>) (SchemaPrefix())? StringLiteral() (<AT> StringLiteral())?
}

void SchemaPrefix() : {}
{
	(<NAMESPACE> NCName() <EQUAL>) | ((<DEFAULTTOKEN> <ELEMENT>) <NAMESPACE> <EQUAL>)
}




void Pragma() : {}
{
	<LPAR><COLONCOLON> <PRAGMA> QName() (PragmaContents())* <COLONCOLON><RPAR>
}

void MustUnderstandExtension() : {}
{
	<LPAR><COLONCOLON> <EXTENSION> QName() (ExtensionContents())* <COLONCOLON><RPAR>
}

void ExprComment() : {}
{
	<LPAR><COLON> (ExprCommentContent() | ExprComment())* <COLON><RPAR>
}

void ExprCommentContent() : {}
{
	Char()
}
void PragmaContents() : {}
{
	Char()
}

void ExtensionContents() : {}
{
	Char()
}

void IntegerLiteral() : {}
{
	Digits()
}

void DecimalLiteral() : {}
{
	(<DOT> Digits()) | (Digits() <DOT> (Digits())*)
}

void DoubleLiteral() : {}
{
	((<DOT> Digits()) | (Digits() (<DOT> (Digits())*)?)) (<e> | <E>) (<PLUS> | <MINUS>)? Digits()
}

void StringLiteral() : {}
{
	<Literal> // This should be StringLiteral. But there is some conflict with Literal Token and defining StringLiteral token
}

void S() : {}
{
	(<S>)+
}

void SchemaMode() : {}
{
	<LAX> | <STRICT> | <SKIPTOKEN>
}

void SchemaGlobalTypeName() : {}
{
	<TYPE> <LPAR> QName() <RPAR>
}

void SchemaGlobalContext() : {}
{
	QName() | SchemaGlobalTypeName()
}

void SchemaContextStep() : {}
{
	QName()
}

void Digits() : {}
{
	<DIGIT>
}

void EscapeQuot() : {}
{
	"\"" "\"" 
}

void PITarget() : {}
{
	NCName()
}

String NCName() : 
{	
	Token ncName;
}
{
	ncName = <NCNAME>
	{return ncName.image;}
}

String VarName() : 
{
	String varName;
}
{
	varName = QName()
	{return varName;}
}

String QName() : 
{
	String qName = "";
	String ncName="";
	Token colon;
}
{
	(
	ncName = NCName() 
	colon = <COLON>
	{qName = ncName + colon.image;}
	)? 
	ncName = NCName()
	{
		if(qName==null)
			qName = ncName;
		else	
			qName = qName+ncName;
	}
	{return qName;}
}

void PredefinedEntityRef() : {}
{
	<ANDSYMBOL> (<LT> | <GT> | <AMP> | <QUOT> | <APOS>) <SEMICOLON> 
}

void HexDigits() : {}
{
	<HEXDIGIT>
}

void CharRef() : {}
{
	<ANDHASH> (Digits() | (<x> HexDigits())) <SEMICOLON>
}

void EscapeApos() : {}
{
	"''"
}


void Char() : {}
{
	<CHAR>
}

void ElementContentChar() : {}
{
	Char() 
}

void QuoteAttributeContentChar() : {}
{
	Char()  
}

void AposAttributeContentChar() : {}
{
	Char() 
}

