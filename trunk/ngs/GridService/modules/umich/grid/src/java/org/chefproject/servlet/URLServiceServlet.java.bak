/**********************************************************************************
*
* $Header$
*
***********************************************************************************
*
* COPYRIGHT © 2002
* THE REGENTS OF THE UNIVERSITY OF MICHIGAN
* ALL RIGHTS RESERVED
* 
* PERMISSION IS GRANTED TO USE, COPY AND REDISTRIBUTE THIS SOFTWARE FOR
* NONCOMMERCIAL EDUCATION AND RESEARCH PURPOSES, SO LONG AS NO FEE IS
* CHARGED, AND SO LONG AS THE COPYRIGHT NOTICE ABOVE, THIS GRANT OF PERMISSION,
* AND THE DISCLAIMER BELOW APPEAR IN ALL COPIES MADE; AND SO LONG AS THE NAME
* OF THE UNIVERSITY OF MICHIGAN IS NOT USED IN ANY ADVERTISING OR PUBLICITY
* PERTAINING TO THE USE OR DISTRIBUTION OF THIS SOFTWARE WITHOUT SPECIFIC,
* WRITTEN PRIOR AUTHORIZATION. PERMISSION TO MODIFY OR OTHERWISE CREATE
* DERIVATIVE WORKS OF THIS SOFTWARE IS NOT GRANTED.
* 
* THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION AS TO ITS FITNESS FOR
* ANY PURPOSE, AND WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE. THE REGENTS OF THE UNIVERSITY OF MICHIGAN
* SHALL NOT BE LIABLE FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL,
* OR CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING OUT OF OR IN
* CONNECTION WITH THE USE OF THE SOFTWARE, EVEN IF IT HAS BEEN OR IS HEREAFTER
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
*
***********************************************************************************
*
*  For information concerning commercial application of this software, contact the
*  CHEF software group, School of Information + Media Union, University of Michigan
*					 mailto:chef-software@umich.edu
*
**********************************************************************************/

// package
package org.chefproject.servlet;

// imports
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import java.net.*;

import org.apache.turbine.util.Log;
import org.apache.turbine.util.RunData;
import org.apache.turbine.util.RunDataFactory;

import org.chefproject.core.User;
import org.chefproject.service.UsageSessionService;
import org.chefproject.service.UserDirectoryService;
import org.chefproject.service.SecurityService;

// For retrieve-cert

import org.chefproject.service.GridService;
import org.chefproject.exception.*;
import org.globus.security.*;
import org.globus.myproxy.*;

// For create-channel

import org.nees.nsds.nsdsServer.service.NsdsServerServiceLocator;
import org.nees.nsds.nsdsServer.NsdsPortType;
import java.net.URL;

/* The purpose of this servlet is to provide "back-door" access to CHEF
   services via a servlet without gfoing through the portal.  This servlet
   demands that the context (i.e. session cookie) be properly set in the 
   browser.  The URLs are of the form:

	http://localhost:8080/chef/urlsrv/request-cert?debug=on


   Much of the applet is a framework which sets up and checks the user
   identity so that CHEF services operate properly. For each specific
   request, you must define a path and call your specific method for
   the request.  You must also define the method which will respond to 
   the request. 

*/

public class URLServiceServlet
	extends HttpServlet
{
	/** delimiter for form multiple values */
	static final String FORM_VALUE_DELIMETER = "^";

	/** used to id a log message */
	public static String ME = "Access:";

	/** set to true when init'ed. */
	private boolean m_ready = false;

	/** init thread - so we don't wait in the actual init() call */
	public class URLServiceServletInit
		extends Thread
	{
		/**
		* construct and start the init activity
		*/
		public URLServiceServletInit()
		{
			m_ready = false;
			start();

		}   // URLServiceServletInit

		/**
		* run the init
		*/
		public void run()
		{
			m_ready = true;

		}   // run

	}   // class URLServiceServletInit

	/**
	* initialize the URLServiceServlet servlet
	*
	* @param config the servlet config parameter
	* @exception ServletException in case of difficulties
	*/
	public void init(ServletConfig config)
		throws ServletException
	{
		super.init(config);
		startInit();

	}   // init

	/**
	* Start the initialization process
	*/
	public void startInit()
	{
		new URLServiceServletInit();

	}   // startInit

	/**
	* respond to an HTTP GET request
	*
	* @param req HttpServletRequest object with the client request
	* @param res HttpServletResponse object back to the client
	* @exception ServletException in case of difficulties
	* @exception IOException in case of difficulties
	*/
	public void doGet(  HttpServletRequest req,
						HttpServletResponse res)
		throws ServletException, IOException
	{
		dispatch(req, res);

	}   // doGet


	/**
	* respond to an HTTP POST request
	*
	* @param req HttpServletRequest object with the client request
	* @param res HttpServletResponse object back to the client
	* @exception ServletException in case of difficulties
	* @exception IOException in case of difficulties
	*/
	public void doPost(HttpServletRequest req, HttpServletResponse res)
		throws ServletException, IOException
	{
		dispatch(req, res);

	}   // doPost


	/**
	* handle get and post communication from the user
	*
	* @param req HttpServletRequest object with the client request
	* @param res HttpServletResponse object back to the client
	*/
	public synchronized void dispatch(HttpServletRequest req, HttpServletResponse res)
	{
		if (!m_ready)
		{
			// send the response type
			res.setContentType("text/html");

			// output here
			try
			{
				PrintWriter out = res.getWriter();

				out.write("<html><head><title>" + ME + "</title></head><body><h1>"
						+ ME + " is not ready"
						+ "</h1></body></html>");

				out.flush();

				Log.info("chef", ME + "ip=" + req.getRemoteAddr() + "&"
										+ "READY=FALSE&");
			}
			catch (IOException ignore) {}

			return;
		}

		// get the incoming information
		URLServiceServletInfo info = newInfo(req);

		RunData data = null;
		try
		{
			// setup for the request
			setup(req);

			// setup the rundata / state manager (etc.) setup for this thread
			data = RunDataFactory.getRunData(req, res, getServletConfig());

			// do it
			doDispatch(info, req, res);
		}
		catch (Exception e)
		{
			Log.warn("chef", this + ".dispatch(): exception: ", e);
		}
		finally
		{
			// log
			log(req, info);
	
			// cleanup from the request
			cleanup();

			// cleanup the rundata / state manager (etc.) setup for this thread
			RunDataFactory.putRunData(data);
		}

	}   // dispatch

	/** log a request processed */
	public void log(HttpServletRequest req, URLServiceServletInfo info)
	{
		Log.info("chef", ME
						+ " from:" + req.getRemoteAddr()
						+ " path:" + req.getPathInfo()
						+ " options: " +  info.optionsString()
						+ " time: " + info.getElapsedTime()
						);

	}   // log

	/**
	* Setup by connecting the request user to the security service.
	* @param req The servlet request.
	*/
	private void setup(HttpServletRequest req)
	{
	}   // setup

	/**
	* Cleanup by removing the security setup for this request thread.
	*/
	private void cleanup()
	{
	}   // cleanup

	/**
	 * Show HTTP header information.
	 */
	protected String getRequestInfo(HttpServletRequest req) {

		StringBuffer sb = new StringBuffer("");

		sb.append("\n");
		sb.append("DefaultServlet Request Info" + "\n");
		sb.append("\n");

		// Show generic info
		sb.append("Encoding : " + req.getCharacterEncoding() + "\n");
		sb.append("Length : " + req.getContentLength() + "\n");
		sb.append("Type : " + req.getContentType() + "\n");

		sb.append("\n");
		sb.append("Parameters" + "\n");

		Enumeration parameters = req.getParameterNames();

		while (parameters.hasMoreElements()) {
			String paramName = (String) parameters.nextElement();
			String[] values = req.getParameterValues(paramName);
			sb.append(paramName + " : ");
			for (int i = 0; i < values.length; i++) {
			        sb.append(values[i] + ", ");
			}
			sb.append("\n");
		}

		sb.append("\n");

		sb.append("Protocol : " + req.getProtocol() + "\n");
		sb.append("Address : " + req.getRemoteAddr() + "\n");
		sb.append("Host : " + req.getRemoteHost() + "\n");
		sb.append("Scheme : " + req.getScheme() + "\n");
		sb.append("Server Name : " + req.getServerName() + "\n");
		sb.append("Server Port : " + req.getServerPort() + "\n");

		sb.append("\n");
		sb.append("Attributes" + "\n");

		Enumeration attributes = req.getAttributeNames();

		while (attributes.hasMoreElements()) {
		    String attributeName = (String) attributes.nextElement();
		    sb.append(attributeName + " : ");
		    sb.append(req.getAttribute(attributeName).toString() + "\n");
		}

		sb.append("\n");

		// Show HTTP info
		sb.append("HTTP Header Info" + "\n");
		sb.append("\n");

		sb.append("Authentication Type : " + req.getAuthType() + "\n");
		sb.append("HTTP Method : " + req.getMethod() + "\n");
		sb.append("Path Info : " + req.getPathInfo() + "\n");
		sb.append("Path translated : " + req.getPathTranslated() + "\n");
		sb.append("Query string : " + req.getQueryString() + "\n");
		sb.append("Remote user : " + req.getRemoteUser() + "\n");
		sb.append("Requested session id : "
		               + req.getRequestedSessionId() + "\n");
		sb.append("Request URI : " + req.getRequestURI() + "\n");
		sb.append("Context path : " + req.getContextPath() + "\n");
		sb.append("Servlet path : " + req.getServletPath() + "\n");
		sb.append("User principal : " + req.getUserPrincipal() + "\n");
		sb.append("\n");
		sb.append("Headers : " + "\n");
		
		Enumeration headers = req.getHeaderNames();

		while (headers.hasMoreElements()) {
		    String headerName = (String) headers.nextElement();
		    sb.append(headerName + " : ");
		    sb.append(req.getHeader(headerName) + "\n");
		}
		
		sb.append("\n");

		return sb.toString();
	}

	// Begining of the request-specific extension methods ******************

	/** Dump information from the request **/
	public void doDumpInfo(URLServiceServletInfo info, HttpServletRequest req, HttpServletResponse res,
			User curUser)
	{
		try
		{
			PrintWriter out = res.getWriter();
			res.setContentType("text/plain");
			
			out.println("Current User " + curUser.getId());
			out.println(getRequestInfo(req));		
		} catch (Exception e) {}
	}


	/** Retrieve the user's certificate **/
	public void doRetrieveCert(URLServiceServletInfo info, HttpServletRequest req, HttpServletResponse res,
			User curUser)
	{
		GlobusProxy proxy = null;
		boolean debug = false;

		if ( req.getParameter("debug") != null ) {
			System.out.println("Debug turned on "+req.getParameter("debug"));
			debug = true;
		}

		proxy = GridService.getCurrentUserGlobusProxy();

		try
		{

			ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
			proxy.save(byteOut);

			PrintWriter respOut = res.getWriter();
			res.setContentType("text/plain");

			respOut.println(byteOut.toString());
			if ( debug ) respOut.println(proxy.toString());

		} catch (Exception e) {}

	} // doRetrieveCert

  	/**
   	* creates a new channel name for a client applet
	* returns a code and value
	*
	* Success:
	* 100 nsds-channel-1035298590005
	*
	* Failure: (anything else other than a 100)
	* 401 Thrown: ClassMissingException org/apache/missing/class
   	*
   	*/
	/** Create an NSDS channel **/
	public void doCreateChannel(URLServiceServletInfo info, HttpServletRequest req, HttpServletResponse res,
			User curUser)
	{
    		String uri = "http://core.isi.edu:8080/ogsa/services/samples/nsds/server/NsdsFactoryService/test";
		String output;
		
		System.out.println("Creating channel:\n" + uri);
    		try
    		{
			System.out.println("Creating channel " + uri);
			NsdsServerServiceLocator locator = new NsdsServerServiceLocator();
			System.out.println("ServiceLocator Created");
			NsdsPortType nsds = locator.getnsdsServerPort(new URL(uri));
			System.out.println("NSDS Port Created");
      			String channel = nsds.createChannel();
			System.out.println("Channel created:" + channel);

			output = "100 " + channel;
    		}
    		catch (Exception e)
    		{
			System.out.println("Exception thrown:" + e.getMessage());
			output = "400 Exception: " + e.getMessage();
      			// e.printStackTrace(System.out);
    		}
    		catch( Throwable t ) {
			System.out.println("Threw "+t.getMessage());
			System.out.println("Throwable error:" + t.getMessage());
			output = "401 Thrown: " + t.getMessage();
    		}

		try {
			PrintWriter out = res.getWriter();
			res.setContentType("text/plain");
			out.println(output);
			System.out.println("Returning: " + output);
		} catch (Exception e) {}

  	}

	// End of the request-specific extension methods ******************

	/** dispatch a request */
	public void doDispatch(URLServiceServletInfo info, HttpServletRequest req, HttpServletResponse res)
	{

		// error message string - set on error
		String errMsg = null;

		String path = req.getPathInfo();
		if (path == null) path = "";

		// check for no logged in user

		User curUser = UsageSessionService.getSessionUser();

		// Debug - heavy - comment out near production
		System.out.println(getRequestInfo(req));

		if ((curUser == null) || 
                    (curUser == UserDirectoryService.getAnonymousUser()))
		{
			System.out.println("Unauthorized");
			try
			{
				res.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			} catch  (Exception e) {}
			return;
		}

		System.out.println("URLServicesServlet path="+path+" user = " + curUser.getId());

		// Add request-specific paths here ******************

		if (path.equals("/dump-info")) {
			doDumpInfo(info,req,res,curUser);
		} else if ( path.equals("/retrieve-cert")) {
			doRetrieveCert(info,req,res,curUser);
		} else if ( path.equals("/create-channel")) {
			doCreateChannel(info,req,res,curUser);
		} else  {
			System.out.println("URLServicesServlet - Unsupported request:"+path);
			try
			{
				res.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			} catch  (Exception e) {}
			return;
		}

	}   // doDispatch

	/** create the info */
	public URLServiceServletInfo newInfo(HttpServletRequest req)
	{
		return new URLServiceServletInfo(req);

	}   // newInfo

	public class URLServiceServletInfo
	{
		// elapsed time start
		protected long m_startTime = System.currentTimeMillis();
		public long getStartTime() { return m_startTime; }
		public long getElapsedTime()
		{
			return System.currentTimeMillis() - m_startTime;
		}

		// all properties from the request
		protected Properties m_options = null;
		public Properties getOptions() { return m_options; }

		/** construct from the req */
		public URLServiceServletInfo(HttpServletRequest req)
		{
			m_options = new Properties();
			String type = req.getContentType();

			Enumeration e = req.getParameterNames();
			while (e.hasMoreElements())
			{
				String key = (String) e.nextElement();
				String [] values = req.getParameterValues(key);
				if (values.length == 1) 
				{
					m_options.put(key, values[0]);
				}
				else 
				{
					StringBuffer buf = new StringBuffer();
					for (int i = 0; i < values.length; i++)
					{
						buf.append(values[i] + FORM_VALUE_DELIMETER);
					}
					m_options.put(key, buf.toString());
				}
			}

		}   // URLServiceServletInfo

		/** return the m_options as a string */
		public String optionsString()
		{
			StringBuffer buf = new StringBuffer(1024);
			Enumeration e = m_options.keys();
			while (e.hasMoreElements())
			{
				String key = (String)e.nextElement();
				Object o = m_options.getProperty(key);
				if (o instanceof String)
				{
					buf.append(key);
					buf.append("=");
					buf.append(o.toString());
					buf.append("&");
				}
			}

			return buf.toString();

		}   // optionsString
		
	}   // URLServiceServletInfo

}   // URLServiceServlet

/**********************************************************************************
*
* $Header$
*
**********************************************************************************/

