<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSPY v2004 rel. 3 U (http://www.xmlspy.com) by Arun swaran (University of Florida) -->
<!--We hope to have this as a standard in the Global Grid Forum for data management in data grids. Contact SDSC Matrix Team (arun@sdsc.edu) for any suggestions or comments -->
<xs:schema targetNamespace="http://www.teragrid.org/schemas/datagrid" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tg="http://www.teragrid.org/schemas/datagrid" elementFormDefault="qualified" attributeFormDefault="unqualified">
	<?version 1.0.0?>
	<!-- ROOT ELEMENTS  (The DataGrid Language consists of DataGridRequest and DataGridResponse)-->
	<xs:element name="DataGridRequest">
		<xs:annotation>
			<xs:documentation>DGReq for short</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="DocMeta" type="tg:DocMeta" minOccurs="0"/>
				<xs:element name="GridUser" type="tg:UserInfo"/>
				<xs:element name="VOInfo" type="tg:VirtualOrganizationInfo"/>
				<xs:choice>
					<xs:element name="Flow" type="tg:Flow"/>
					<xs:element name="FlowStatusQuery" type="tg:FlowStatusQuery"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="requestType" type="xs:string" use="optional" default="asynchronous"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="DataGridResponse">
		<xs:annotation>
			<xs:documentation>DGRes for short</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="docMeta" type="tg:DocMeta" minOccurs="0">
					<xs:annotation>
						<xs:documentation>information about the document and the DataGrid Server and Matrix Handlers that were used to process the request</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:choice>
					<xs:element name="RequestAcknowledgement" type="tg:RequestAcknowledgment">
						<xs:annotation>
							<xs:documentation>Sent as a response imdtly after a job or request is submited. This provides a psudo-asynchrony. In future, there could be pure asynchrony and this might not be used</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="FlowStatusResponse" type="tg:FlowStatusResponse"/>
				</xs:choice>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!--ABSTRACT TYPES (not really abstract for now)-->
	<xs:complexType name="tDocumentation" mixed="true">
		<xs:sequence>
			<xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="tDocumented" abstract="true">
		<xs:annotation>
			<xs:documentation>This type is extended by  component types to allow them to be documented
      </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="documentation" type="tg:tDocumentation" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="tExtensibleDocumented">
		<xs:annotation>
			<xs:documentation>This type is extended by component types to allow elements from other namespaces to be added.
          </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="tg:tDocumented">
				<xs:sequence>
					<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- REQUEST ELEMENTS (The data types used in DataGridRequest)-->
	<xs:complexType name="DocMeta">
		<xs:annotation>
			<xs:documentation>Information about the DataGridRequest or a DataGridResponse about the saga</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="docAuthor" type="xs:string"/>
			<xs:element name="docOwner" type="tg:UserInfo" minOccurs="0"/>
			<xs:element name="documentation" type="tg:tExtensibleDocumented" minOccurs="0"/>
			<xs:element name="docVersion" type="xs:string" minOccurs="0"/>
			<xs:element name="sagaID" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Default Transaction ID</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="optInvocationID" type="xs:string" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="UserInfo">
		<xs:annotation>
			<xs:documentation>Information about a grid User</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:annotation>
					<xs:documentation>Can be either a user-id or grid-certificate key or a ticket-id to logon to the datagrid</xs:documentation>
				</xs:annotation>
				<xs:element name="gridTicket" type="tg:GridTicketInfo"/>
				<xs:sequence>
					<xs:element name="userID" type="xs:string"/>
					<xs:element name="organization" type="tg:OrganizationInfo">
						<xs:annotation>
							<xs:documentation>The organization of user. In SRB it is the domain name</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="challenge-Response" type="xs:string" minOccurs="0">
						<xs:annotation>
							<xs:documentation>password in most cases - must be transmitted secure (e.g) HTTPS</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="homeDirectory" type="xs:string" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The default home collection the user wants to use for the session</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="defaultStorageResource" type="xs:string" minOccurs="0">
						<xs:annotation>
							<xs:documentation>default logical storage resource the users wants to use for this session</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:choice>
			<xs:element name="phoneNumber" type="xs:int" minOccurs="0"/>
			<xs:element name="e-mail" type="xs:anyURI" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="VirtualOrganizationInfo">
		<xs:annotation>
			<xs:documentation>Virtual Organization or a member in the grid</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:element name="voID" type="xs:string">
					<xs:annotation>
						<xs:documentation>Virtual Organization ID (e.g) SCEC, TeraGrid, BIRN</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:sequence>
					<xs:element name="server" type="xs:anyURI"/>
					<xs:element name="port" type="xs:int"/>
				</xs:sequence>
			</xs:choice>
			<xs:element name="description" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Description about the Virtual Organization</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Flow">
		<xs:annotation>
			<xs:documentation>Flow is an unit of a transaction consisting of a set of steps that can be either executed sequentially or parallely</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="variables" type="tg:tVariables" minOccurs="0"/>
			<xs:element name="flowLogic" type="tg:AnyControlStructure"/>
			<xs:choice>
				<xs:element name="Step" type="tg:Step" maxOccurs="unbounded"/>
				<xs:element name="Flow" type="tg:Flow" maxOccurs="unbounded"/>
			</xs:choice>
		</xs:sequence>
		<xs:attribute name="flowID" type="xs:ID" use="required"/>
	</xs:complexType>
	<xs:complexType name="Step">
		<xs:annotation>
			<xs:documentation>Step represents an atomic operation that can be executed on the data grid</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Variables" type="tg:tVariables" minOccurs="0"/>
			<xs:element name="UserDefinedRules" type="tg:tRule" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Operation" type="tg:Operation"/>
		</xs:sequence>
		<xs:attribute name="stepID" type="xs:ID" use="required"/>
	</xs:complexType>
	<xs:complexType name="Operation">
		<xs:annotation>
			<xs:documentation>any standard data grid operation </xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="CopyOp" type="tg:CopyOp"/>
			<xs:element name="ChangePermissionOp" type="tg:ChangePermissionOp"/>
			<xs:element name="CreateOp" type="tg:CreateOp"/>
			<xs:element name="DeleteOp" type="tg:DeleteOp"/>
			<xs:element name="RenameOp" type="tg:RenameOp"/>
			<xs:element name="IngestOp" type="tg:IngestDataSetOp"/>
			<xs:element name="PrepareTicketOp" type="tg:PrepareTicketOp"/>
			<xs:element name="DownloadDataSetOp" type="tg:DownloadDataSetOp"/>
			<xs:element name="ReplicateOp" type="tg:ReplicateOp"/>
			<xs:element name="ListOp" type="tg:ListOp"/>
			<xs:element name="SeekNReadOp" type="tg:SeekNReadOp"/>
			<xs:element name="SeekNWriteOp" type="tg:SeekNWriteOp"/>
			<xs:element name="MetadataQueryOp" type="tg:MetadataQueryOp"/>
			<xs:element name="IngestMetadataOp" type="tg:IngestMetadataOp"/>
			<xs:element name="ExecuteProcessOp" type="tg:ExecuteProcessOp"/>
			<xs:element name="ReDirectStatusOp" type="tg:RedirectStatusOp"/>
			<xs:element name="GetPhysicalLocationOp" type="tg:GetPhysicalLocationOp"/>
		</xs:choice>
	</xs:complexType>
	<!-- STATUS ELEMENTS  (For querying on the status of a DataGridRequest)-->
	<xs:complexType name="FlowStatusQuery">
		<xs:annotation>
			<xs:documentation>Query the state of a particular flow</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:element name="StatusOperation" type="tg:StatusOperation">
				<xs:annotation>
					<xs:documentation>will operate on the largest (recent) iteration of the flow</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ItrQueries" type="tg:FlowItrStatusQuery" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Operate on a set of iterations on the same flow</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attribute name="flowID" type="xs:string" use="required"/>
	</xs:complexType>
	<xs:complexType name="FlowItrStatusQuery">
		<xs:choice minOccurs="0">
			<xs:element name="StatusOperaton" type="tg:StatusOperation">
				<xs:annotation>
					<xs:documentation>Will operate on all steps of the whole flow iteration</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StepStatusQueries" type="tg:StepStatusQuery" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Operate on a set of steps mentioned using their ids </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FlowStatusQuery" type="tg:FlowStatusQuery" maxOccurs="unbounded"/>
		</xs:choice>
		<xs:attribute name="flowItrID" type="xs:integer" use="required"/>
	</xs:complexType>
	<xs:complexType name="StepStatusQuery">
		<xs:annotation>
			<xs:documentation>Query a step  in a data grid request made earlier.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StatusOperation" type="tg:StatusOperation">
				<xs:annotation>
					<xs:documentation>the largest (recent) step iteration is the default</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ItrQueries" type="tg:StepItrStatusQuery" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Operate on a set of iterations of the same step (iteration number must be known)</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attribute name="stepID" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The name of the step that has to be queried</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="StepItrStatusQuery">
		<xs:sequence>
			<xs:element name="StatusOperation" type="tg:StatusOperation"/>
		</xs:sequence>
		<xs:attribute name="stepItrID" type="xs:integer" use="required"/>
	</xs:complexType>
	<xs:complexType name="StatusOperation">
		<xs:choice>
			<xs:element name="queryType" type="xs:string" default="simpleQuery">
				<xs:annotation>
					<xs:documentation>can be used to indicate the type of the query. Currenly just has the value 'simple query'. In future might have mroe value including ways to subscribe to know the status</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="stop" type="xs:string" default="tryStop">
				<xs:annotation>
					<xs:documentation>can be used to stop a transaction/flow/step (if  it has not been started ) - not used now</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<!-- CONTEXT/CONTROL FLOW LOGIC ELEMENTS-->
	<xs:complexType name="tCondition">
		<xs:annotation>
			<xs:documentation>An XQuery that will return any of the action items as a result</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="tg:tExtensibleDocumented">
				<xs:choice>
					<xs:element name="xQuery" type="xs:string">
						<xs:annotation>
							<xs:documentation>later this has to be from some w3c schema for XQuery</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="simpleQuery" type="xs:string"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="tAction">
		<xs:complexContent>
			<xs:extension base="tg:tExtensibleDocumented">
				<xs:sequence>
					<xs:element name="actionString">
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:whiteSpace value="preserve"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="name" type="xs:NCName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="tPart">
		<xs:annotation>
			<xs:documentation>currently these are the only meta-data stuff that are supported. Theoretically we must be able to support xml-any type.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="number" type="xs:decimal"/>
			<xs:element name="CollectionList" type="tg:CollectionList"/>
			<xs:element name="DataSet" type="tg:DataSet"/>
			<xs:element name="StringSet" type="tg:StringSet"/>
			<xs:element name="StreamData" type="tg:StreamData"/>
			<xs:element name="Collection" type="tg:Collection"/>
		</xs:choice>
		<xs:attribute name="name" type="xs:string" use="required"/>
	</xs:complexType>
	<xs:complexType name="tIterator">
		<xs:annotation>
			<xs:documentation>possible iterators</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="collection" type="tg:Collection"/>
			<xs:element name="collectionListing" type="tg:CollectionList"/>
			<xs:element name="dataSet" type="tg:DataSet">
				<xs:annotation>
					<xs:documentation>assumes csv or lsv</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="stringSet" type="tg:StringSet"/>
			<xs:sequence>
				<xs:annotation>
					<xs:documentation>For external contents like objects from a URL or FTPresource along with the userInfo required to grab the content</xs:documentation>
				</xs:annotation>
				<xs:element name="externalURL" type="xs:string"/>
				<xs:element name="externalUser" type="tg:UserInfo" minOccurs="0"/>
			</xs:sequence>
		</xs:choice>
		<xs:attribute name="iterationVariableName" type="xs:string" use="required"/>
	</xs:complexType>
	<xs:complexType name="tVariables">
		<xs:sequence>
			<xs:element name="part" type="tg:tPart" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="tRule">
		<xs:annotation>
			<xs:documentation>The basis of ECAA rules in matrix. An event  (e.g) start or stop of a flow or its sub-member  triggers the rule to be processed. The condition evalutes to any of the action names. The corresponding action is executed. If no action names match to result of the condition, nothing is executed.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="condition" type="tg:tCondition"/>
			<xs:element name="action" type="tg:tAction" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="name" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="beforeEntry"/>
					<xs:enumeration value="afterExit"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="tForLoop">
		<xs:annotation>
			<xs:documentation>similar to typical "flor" loop in programming languages. For loop is repeated as long as the condition returns "true"</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="init" type="tg:tAction" minOccurs="0"/>
			<xs:element name="forCondition" type="tg:tCondition"/>
			<xs:element name="iterator" type="tg:tAction" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:QName" use="optional"/>
	</xs:complexType>
	<xs:complexType name="tWhileLoop">
		<xs:annotation>
			<xs:documentation>if the condition retunred "true", invokes the sub-members (sequentially). The condition is evaluated and again  and the "while" loop is repeated</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="condition" type="tg:tCondition"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="tSequential">
		<xs:annotation>
			<xs:documentation>invokes all the sub-members once one after the other, sequentially</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="SeqRule" type="tg:tRule" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="tParallel">
		<xs:annotation>
			<xs:documentation>The sub-members of this flow are all "invoked" simultaenously as threads. </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ParaRule" type="tg:tRule" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="AnyControlStructure">
		<xs:sequence>
			<xs:choice>
				<xs:element name="sequential" type="tg:tSequential"/>
				<xs:element name="parallel" type="tg:tParallel"/>
				<xs:element name="forLoop" type="tg:tForLoop"/>
				<xs:element name="whileLoop" type="tg:tWhileLoop"/>
				<xs:element name="switch-block" type="tg:tSwitch"/>
				<xs:element name="forEachLoop" type="tg:tForEachLoop"/>
			</xs:choice>
			<xs:element name="userDefinedRules" type="tg:tRule" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="tForEachLoop">
		<xs:annotation>
			<xs:documentation>iterates over a set of strings  CollectionListings</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="iterationSet" type="tg:tIterator" maxOccurs="unbounded"/>
			<xs:element name="parallel-init" type="xs:integer" minOccurs="0"/>
			<xs:element name="parallel-increment" type="xs:integer" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="tIf">
		<xs:annotation>
			<xs:documentation>The submembers of this flow are executed if the condition returns "true"</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="condition" type="tg:tCondition"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="tSwitch">
		<xs:annotation>
			<xs:documentation>Switch is similar to switch-case construct in programming. The return value of the switch condition matched with the flow-id or step-id of the sub-members  and is executed</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="switch" type="tg:tCondition"/>
		</xs:sequence>
	</xs:complexType>
	<!-- PARAMETER ELEMENTS (Data types in a datagrid)-->
	<xs:complexType name="GridTicketInfo">
		<xs:annotation>
			<xs:documentation>Grid Ticket that can be used to use the grid without having a valid user-id</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ticketID" type="tg:TicketID"/>
			<xs:element name="startTime" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="endTime" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="ticketParent" type="tg:UserInfo" minOccurs="0"/>
			<xs:element name="usageCount" type="xs:int" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="OrganizationInfo">
		<xs:annotation>
			<xs:documentation>Organization or a Group in the Grid</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="organizationName" type="xs:string">
				<xs:annotation>
					<xs:documentation>Could be an organization or a group in the datagrid. In SRB, this is called as domain or UserGroup</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="groupUserId" minOccurs="0">
				<xs:annotation>
					<xs:documentation>This is a special user-id in the VO. The members of the Organization inherit the rights enjoyed by this groupUserId. Similar to Unix-FileSystem groups</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="description" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Descrtiption about the organization or the group in the VO</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ActiveDatagridCollection">
		<xs:annotation>
			<xs:documentation>Active Data Grid Collection to be used by Data Grid Management Systems in future</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="collection" type="tg:Collection"/>
			<xs:element name="collectionBehavior" type="xs:anyURI"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Collection">
		<xs:annotation>
			<xs:documentation>A collection is a logical organization of digital entities in a data that might be physically distributed in the data grid</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdCollection" type="tg:StdCollection"/>
			<xs:element name="CollectionReference" type="tg:VariableReference"/>
			<xs:element name="AnyDirectory" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="StdCollection">
		<xs:sequence>
			<xs:element name="collectionName" type="xs:string" nillable="false"/>
			<xs:element name="collectionOwner" type="tg:UserInfo" minOccurs="0"/>
			<xs:element name="MetaData" type="tg:MetaData" minOccurs="0"/>
			<xs:element name="annotation" type="tg:Annotation" minOccurs="0"/>
			<xs:element name="comments" type="xs:string" minOccurs="0"/>
			<xs:element name="defContainer" type="tg:Container" minOccurs="0"/>
			<xs:element name="createTimeStamp" type="xs:dateTime" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ParamList">
		<xs:annotation>
			<xs:documentation>A list of generic parameters as strings (not xs:anyType). This is provided for flexibility to use differnt set of parameters other the standard ones (if requiered)</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="param" type="xs:string" nillable="true" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="StringSet">
		<xs:choice>
			<xs:element name="StdStringSet" type="tg:StdStringSet"/>
			<xs:element name="StringSetReference" type="tg:VariableReference"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="StdStringSet">
		<xs:sequence>
			<xs:element name="stringElement" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="MetaData">
		<xs:annotation>
			<xs:documentation>A general Description of MetaData</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="AVU-pairs" type="tg:AVUpair" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="UserDefined" type="tg:UserDefinedSchema" minOccurs="0"/>
			<xs:element name="SystemMeta" type="tg:SystemMetaData" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="AVUpair">
		<xs:annotation>
			<xs:documentation>Attribute-value-unit pair for meta data (one of the simplest ways used for meta-data) (e.g) color-blue-100</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="attribute" type="xs:string"/>
			<xs:element name="value" type="xs:string"/>
			<xs:element name="unit" type="xs:string" minOccurs="0"/>
			<xs:element name="addlValues" type="xs:anySimpleType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>the current matrix implementation can support only upto 6 addlValues</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Container">
		<xs:annotation>
			<xs:documentation>Container is used to store a set of releated dataSets  together for convenience at a single site in the datagrid.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="containerName" type="xs:string"/>
			<xs:element name="currentSize" type="xs:unsignedLong" nillable="false" minOccurs="0"/>
			<xs:element name="maxSize" type="xs:unsignedLong" minOccurs="0"/>
			<xs:element name="replicaNum" type="xs:int" minOccurs="0"/>
			<xs:element name="resourceUsed" type="tg:Resource" minOccurs="0"/>
			<xs:element name="dataType" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>datatype stored in this container</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DataSet">
		<xs:annotation>
			<xs:documentation>Any data in the grid</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdDataSet" type="tg:StdDataSet"/>
			<xs:element name="DataSetReference" type="tg:VariableReference"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="StdDataSet">
		<xs:sequence>
			<xs:element name="dataIdentifier" type="xs:string">
				<xs:annotation>
					<xs:documentation>Just the name, like a file name</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="logicalLocation" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>logical home or location. In SRB the collection is the logical location (made optional for interoperability)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="physicalLocation" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>This is the physical location or URL of the data set. could be gridftp url</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="logicalResourceName" type="tg:Resource" minOccurs="0"/>
			<xs:element name="InContainer" type="tg:Container" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Is this data set in a container</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MetaInfo" type="tg:MetaData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Meta data about this particular data set</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="replicaNum" minOccurs="0">
				<xs:annotation>
					<xs:documentation>replica number of the data set</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="size" minOccurs="0">
				<xs:annotation>
					<xs:documentation>size of the data set</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="contentType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type of the data set. (e.g) jpeg, mov, xml, fits etc</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="createTimeStamp" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="lastModificationTimeStamp" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="lastAccessTimeStamp" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="Owner" type="tg:UserInfo" minOccurs="0"/>
			<xs:element name="dataDirty" type="xs:boolean" minOccurs="0"/>
			<xs:element name="dataCompressed" type="xs:boolean" minOccurs="0"/>
			<xs:element name="Lock" type="tg:DataLock" minOccurs="0"/>
			<xs:element name="hideLevel" type="xs:int" default="0" minOccurs="0">
				<xs:annotation>
					<xs:documentation>if > 0 hide even the existence of this data to other users</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dataDeleted" type="xs:boolean" minOccurs="0"/>
			<xs:element name="checkSum" type="xs:unsignedLong" minOccurs="0"/>
			<xs:element name="expiryDate1" type="xs:date" minOccurs="0"/>
			<xs:element name="expiryDate2" type="xs:date" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ActiveDatagridDataSet">
		<xs:annotation>
			<xs:documentation>Active Data Grid dataset to be used by Data Grid Management System</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="dataSet" type="tg:DataSet"/>
			<xs:element name="VO" type="tg:VirtualOrganizationInfo"/>
			<xs:element name="provider" type="tg:UserInfo"/>
			<xs:element name="static" type="xs:boolean" default="false"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Resource">
		<xs:annotation>
			<xs:documentation>logical or physical name of the resource in the data grid</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="logicalName" type="xs:string">
				<xs:annotation>
					<xs:documentation>Logical name used to identify a resource in the data grid. (e.g) SDSC-HPSS</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="resourceType" nillable="true" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Type of the resource. (e.g) archive, database, unix, NFS etc. This has to be converted into a enumeration</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="physicalLocation" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>physical location of the resource. (e.g) /projects/birn/srbVault</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="netURI" type="xs:anyURI" minOccurs="0"/>
			<xs:element name="maxObjSize" type="xs:unsignedLong" minOccurs="0"/>
			<xs:element name="Latency" minOccurs="0">
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:int">
							<xs:attribute name="minLatency" type="xs:int" use="optional"/>
							<xs:attribute name="maxLatency" type="xs:int" use="optional"/>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="approxBandwidth" minOccurs="0">
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:unsignedLong">
							<xs:attribute name="worstCaseBW" type="xs:unsignedLong" use="optional"/>
							<xs:attribute name="bestCaseBW" type="xs:unsignedLong" use="optional"/>
							<xs:attribute name="varianceFromApprox" type="xs:int" use="optional"/>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="resoureHierarchy" type="xs:int" minOccurs="0"/>
			<xs:element name="capacity" minOccurs="0">
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:unsignedLong">
							<xs:attribute name="measurementUnit" type="xs:string" use="required"/>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="StdDatagridObject">
		<xs:annotation>
			<xs:documentation>Choice of the datagrid object descriptions like Collection, Container, Data Set</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="CollectionNow" type="tg:Collection"/>
			<xs:element name="DataSetNow" type="tg:DataSet"/>
			<xs:element name="ContainerNow" type="tg:Container"/>
			<xs:element name="ADCnow" type="tg:ActiveDatagridCollection"/>
			<xs:element name="ActiveDataSetNow" type="tg:ActiveDatagridDataSet"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="Annotation">
		<xs:sequence>
			<xs:element name="annotator" type="tg:UserInfo"/>
			<xs:element name="text" type="xs:string"/>
			<xs:element name="timeStamp" type="xs:dateTime" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DataLock">
		<xs:sequence>
			<xs:element name="lockNum" type="xs:int">
				<xs:annotation>
					<xs:documentation>lock type</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="lockOwner" type="tg:UserInfo"/>
			<xs:element name="lockDescription" type="xs:string" minOccurs="0"/>
			<xs:element name="lockStartTimeStamp" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="lockEndTimeStamp" type="xs:dateTime" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="TicketID">
		<xs:sequence>
			<xs:element name="ticketString" type="xs:string"/>
			<xs:element name="ticketType" type="xs:string" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Key">
		<xs:annotation>
			<xs:documentation>To represent a key like public key or GSI</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="keyValue" type="xs:string"/>
			<xs:element name="validFrom" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="validTo" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="issuedBy" type="xs:string" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="keyType" type="xs:string" use="optional" default="GSI"/>
		<xs:attribute name="keyVersion" type="xs:string" use="optional"/>
	</xs:complexType>
	<xs:complexType name="MetadataQueryInfo">
		<xs:annotation>
			<xs:documentation>Results for a query for metadata</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="queryRequestString" type="xs:string"/>
			<xs:element name="queryResultString" type="xs:anyType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CollectionList">
		<xs:choice>
			<xs:element name="StdCollectionList" type="tg:StdCollectionList"/>
			<xs:element name="CollectionListReference" type="tg:VariableReference"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="StdCollectionList">
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:element name="CollectionsExtendedInfo" type="tg:CollectionList" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element name="Collections" type="tg:Collection" minOccurs="0" maxOccurs="unbounded"/>
			</xs:choice>
			<xs:element name="dataSets" type="tg:DataSetExtendedList" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DataSetExtendedList">
		<xs:sequence>
			<xs:element name="DataSet" type="tg:DataSet"/>
			<xs:element name="canRead" type="xs:boolean" minOccurs="0"/>
			<xs:element name="canWrite" type="xs:boolean" minOccurs="0"/>
			<xs:element name="allAccess" type="xs:boolean" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CollectionSystemMetaData">
		<xs:annotation>
			<xs:documentation>System defined meta data for collection</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:any maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="UserSystemMetaData">
		<xs:sequence>
			<xs:element name="TBA"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DatasetSystemMetaData">
		<xs:sequence>
			<xs:element name="is_dirty" type="xs:string" minOccurs="0"/>
			<xs:element name="file_is_compressed" type="xs:string" minOccurs="0"/>
			<xs:element name="file_hide" type="xs:int" minOccurs="0"/>
			<xs:element name="file_ver_num" type="xs:string" minOccurs="0"/>
			<xs:element name="file_class_type" type="xs:string" minOccurs="0"/>
			<xs:element name="file_expiry_date" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="file_expire_date_2" type="xs:string" minOccurs="0"/>
			<xs:element name="modification_date" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="file_pin_expiry" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="file_auditFlag" type="xs:string" minOccurs="0"/>
			<xs:element name="file_pin_owner_domain" type="tg:OrganizationInfo" minOccurs="0"/>
			<xs:element name="file_replication_enum" type="xs:int" minOccurs="0"/>
			<xs:element name="size" type="xs:long" minOccurs="0"/>
			<xs:element name="file_lock" type="tg:DataLock" minOccurs="0"/>
			<xs:element name="creation_date" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="physical_resouce" type="tg:Resource" minOccurs="0"/>
			<xs:element name="containerInfo" type="tg:Container" minOccurs="0"/>
			<xs:element name="offset" type="xs:long" minOccurs="0">
				<xs:annotation>
					<xs:documentation>position of data in container</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="file_access_id" type="xs:string" minOccurs="0"/>
			<xs:element name="owner" type="tg:UserInfo" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ResourceSystemMetaData">
		<xs:sequence>
			<xs:element name="TBA"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SystemMetaData">
		<xs:choice>
			<xs:element name="collectionSysMeta" type="tg:CollectionSystemMetaData"/>
			<xs:element name="userSysMeta" type="tg:UserSystemMetaData"/>
			<xs:element name="resourceSysMeta" type="tg:ResourceSystemMetaData"/>
			<xs:element name="dataSetSysMeta" type="tg:DatasetSystemMetaData"/>
			<xs:element name="anySysMeta" type="tg:UserDefinedSchema"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="UserDefinedSchema">
		<xs:annotation>
			<xs:documentation>Any structure based on user defined schema</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="anyUserDefined" type="xs:anyType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="StreamData">
		<xs:annotation>
			<xs:documentation>Currently defined for I/O streams</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdStreamData" type="tg:StdStreamData"/>
			<xs:element name="StreamDataReference" type="tg:VariableReference"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="StdStreamData">
		<xs:choice>
			<xs:element name="dataSet" type="tg:DataSet"/>
			<xs:element name="scratchLocalWorkSpace" type="xs:string"/>
			<xs:sequence>
				<xs:annotation>
					<xs:documentation>data from external reources like FTPresource along with the userInfo required to write the content</xs:documentation>
				</xs:annotation>
				<xs:element name="externalURL" type="xs:string"/>
				<xs:element name="externalUser" type="tg:UserInfo" minOccurs="0"/>
			</xs:sequence>
			<xs:element name="inMemory" type="xs:boolean"/>
			<xs:element name="variable" type="xs:string">
				<xs:annotation>
					<xs:documentation>This ia an expression that will get resolved to a variable.  The stream will stream in and out of that variable. (seems this is no longer needed as reference is already present now)</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="VariableReference">
		<xs:sequence>
			<xs:element name="variableName" type="xs:string"/>
		</xs:sequence>
	</xs:complexType>
	<!-- OPERATIONS  (Data Grid Operations)-->
	<xs:complexType name="CopyOp">
		<xs:annotation>
			<xs:documentation>copy data from a dataSource to dataDestination</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdParams" type="tg:CopyParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="CopyParams">
		<xs:annotation>
			<xs:documentation>Standard definition to copy data from a dataSource to dataDestination in grid. The logical name of the data object in the source and target must be the same  ARUN COMMENT: The Conatinainer name can not be target in this operation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>This structure has to confirmed</xs:documentation>
			</xs:annotation>
			<xs:element name="DataSource" type="tg:StdDatagridObject"/>
			<xs:element name="DataTarget" type="tg:StdDatagridObject">
				<xs:annotation>
					<xs:documentation>If container name specified in the Collection or DataSet they are used in this operation</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ChangePermissionOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:ChangePermissionParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ChangePermissionParams">
		<xs:sequence>
			<xs:element name="gridData" type="tg:StdDatagridObject"/>
			<xs:element name="targetUser" type="tg:UserInfo"/>
			<xs:element name="newPermission">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="read"/>
						<xs:enumeration value="write"/>
						<xs:enumeration value="all"/>
						<xs:enumeration value="annotate"/>
						<xs:enumeration value="none"/>
						<xs:enumeration value="other"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			<xs:element name="recursive" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>grants/changes access permissions recursively for collection and sub-collections under it. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="auditNewAccess" minOccurs="0">
				<xs:annotation>
					<xs:documentation>adds auditing feature for the access permission granted for datasets. Auditing works only if the audit_flag is turned on by the Datagrid Provider. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="collectionOnly" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>grants/changes access permissions for collections only. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dataSetOnly" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>grants/changes access permissions for datasets only. </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CreateOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:CreateParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="CreateParams">
		<xs:sequence>
			<xs:element name="DatagridObject" type="tg:StdDatagridObject"/>
			<xs:element name="defaultContainerForCollection" type="tg:Container" minOccurs="0">
				<xs:annotation>
					<xs:documentation>When creating the collection, the call also associates the new collection with a parent collection's container (if one exists). Using this option overrides this default.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DeleteOp">
		<xs:annotation>
			<xs:documentation>Delete datagrid object</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdParams" type="tg:DeleteParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="DeleteParams">
		<xs:annotation>
			<xs:documentation>Parameters for deleting a datagrid Object</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="gridObject" type="tg:StdDatagridObject"/>
			<xs:element name="recursive" type="xs:boolean" minOccurs="0"/>
			<xs:element name="force" type="xs:boolean" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="RenameOp">
		<xs:annotation>
			<xs:documentation>Rename Operation (Smv in SRB)</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdParams" type="tg:RenameParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="RenameParams">
		<xs:annotation>
			<xs:documentation>Renames the logical names used to identify a datagrid object</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="OldName" type="tg:StdDatagridObject"/>
			<xs:element name="NewName" type="xs:string"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="IngestDataSetOp">
		<xs:annotation>
			<xs:documentation>Full Ingestion of a data Set into the datagrid including logical entries and phyical conetent movement</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdParams" type="tg:IngestDataSetParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="IngestDataSetParams">
		<xs:annotation>
			<xs:documentation>Full Ingestion of a data Set into the datagrid including logical entries and phyical conetent movement</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:element name="content-MIME-ID" type="xs:string">
					<xs:annotation>
						<xs:documentation>This must be either a xs:Qname or URI  or somthing pointing to the attachment content id of the MIME or DIME present along with the DataGridRequest</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:sequence>
					<xs:annotation>
						<xs:documentation>For external contents like objects from a URL or FTPresource along with the userInfo required to grab the content</xs:documentation>
					</xs:annotation>
					<xs:element name="externalURL" type="xs:string"/>
					<xs:element name="externalUser" type="tg:UserInfo" minOccurs="0"/>
				</xs:sequence>
			</xs:choice>
			<xs:element name="DataDestination" type="tg:DataSet">
				<xs:annotation>
					<xs:documentation>The incoming conent will be  inserted into a existing collection with this description. An existing  container or resoruce can also be specified.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="overWrite" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>force copying even if object exists</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="updateAllReplicas" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>force copying all replica of the target object. </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DownloadDataSetOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:DownloadDataSetParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="DownloadDataSetParams">
		<xs:annotation>
			<xs:documentation>A dataset or a any content could be downloaded from data grid to a any other source or url (third party) or downloaded as a attachment or be sent as a e-mail</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DataSource" type="tg:DataSet">
				<xs:annotation>
					<xs:documentation>data set that has to be downloaded </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice minOccurs="0">
				<xs:annotation>
					<xs:documentation>Data Download Destination: If no destination is provided, the data is sent as a MIME or DIME along with the response with the full logical name of the dataSet as the content it in downloadDataSetResult. The stepName may be concatenated to get unique identifier along iwth the full logical name</xs:documentation>
				</xs:annotation>
				<xs:element name="content-MIME-ID" type="xs:string">
					<xs:annotation>
						<xs:documentation>This must be either a xs:Qname or URI  or somthing pointing to the attachment content id of the MIME or DIME that can be present along with the DataGridResponse</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:sequence>
					<xs:annotation>
						<xs:documentation>For downloading data to external reources like FTPresource along with the userInfo required to write the content</xs:documentation>
					</xs:annotation>
					<xs:element name="externalURL" type="xs:string"/>
					<xs:element name="externalUser" type="tg:UserInfo" minOccurs="0"/>
				</xs:sequence>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PrepareTicketOp">
		<xs:annotation>
			<xs:documentation>Prepare Ticket Operation</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdParams" type="tg:PrepareTicketParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="PrepareTicketParams">
		<xs:sequence>
			<xs:element name="parentUser" type="tg:UserInfo"/>
			<xs:element name="gridInfo" type="tg:VirtualOrganizationInfo" minOccurs="0"/>
			<xs:element name="startTime" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="endTime" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="usageCount" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Determines how many times this ticket can be used. Default is infinite. If usageCount == 0 (infinite access, the default). If usageCount less than  0, then removes or deactivates this ticket.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReplicateOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:ReplicateParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ExecuteProcessOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:ExecuteProcessParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ExecuteProcessParams">
		<xs:sequence>
			<xs:element name="exeURI" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation> URI of the executable or package.  If no protocol is specified (e.g. http, ftp) then it is assumed the URI refers to a proxy command on the SRB</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="exeName" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the exeURI designates a package, then this field indicates which executable (packagename.className) to call</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="exeMethod" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>if java, method name</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="input" type="tg:tPart" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="std_in" type="tg:StreamData" minOccurs="0"/>
			<xs:element name="std_out" type="tg:StreamData" minOccurs="0"/>
			<xs:element name="std_err" type="tg:StreamData" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="waitAfterStart" type="xs:boolean" use="optional" default="true"/>
	</xs:complexType>
	<xs:complexType name="ReplicateParams">
		<xs:annotation>
			<xs:documentation>Replicates by making one more copy of the datagrid object </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DataSource" type="tg:StdDatagridObject"/>
			<xs:element name="DataTarget" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="TargetCollection" type="tg:Collection" minOccurs="0">
							<xs:annotation>
								<xs:documentation>If given, the object is stored in this collection</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="TargetResource" type="tg:Resource" minOccurs="0">
							<xs:annotation>
								<xs:documentation>If given, the object is stored in resourceName. Otherwise the object is stored in the default resource userInfo</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ListOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:ListParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ListParams">
		<xs:sequence>
			<xs:element name="recursive" type="xs:int" default="0" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If lising a collection, apply recursively to the sub collections till the specified level internally. If value = -1 means entire sub-levels were recursively listed</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="extendedInfoLevel" type="xs:int" default="0" minOccurs="0">
				<xs:annotation>
					<xs:documentation>level of additional information about the listing. Used in matrix only if recursive is set to some value. Key: -1 = list only data sets  inside</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice>
				<xs:element name="collection" type="tg:Collection"/>
				<xs:element name="container" type="tg:Container"/>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SeekNReadOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:SeekNReadParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="SeekNReadParams">
		<xs:annotation>
			<xs:documentation>Used to read raw bytes from a data set (more like a file thingie)</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DataSet" type="tg:DataSet"/>
			<xs:element name="offset" type="xs:string">
				<xs:annotation>
					<xs:documentation>the start offset in the data - xs: unsignedLong</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="length" type="xs:string">
				<xs:annotation>
					<xs:documentation>the maximum number of bytes read.  xs:unsignedLong</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice minOccurs="0">
				<xs:annotation>
					<xs:documentation>Data Read/Download Destination: If no destination is provided, the data is sent as a MIME or DIME along with the response with the full logical name of the dataSet as the content it in downloadDataSetResult. The stepName may be concatenated to get unique identifier along iwth the full logical name</xs:documentation>
				</xs:annotation>
				<xs:element name="content-MIME-ID" type="xs:string">
					<xs:annotation>
						<xs:documentation>This must be either a xs:Qname or URI  or somthing pointing to the attachment content id of the MIME or DIME that can be present along with the DataGridResponse</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:sequence>
					<xs:annotation>
						<xs:documentation>For downloading data to external reources like FTPresource along with the userInfo required to write the content</xs:documentation>
					</xs:annotation>
					<xs:element name="externalURL" type="xs:string"/>
					<xs:element name="externalUser" type="tg:UserInfo" minOccurs="0"/>
				</xs:sequence>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SeekNWriteOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:SeekNWriteParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="SeekNWriteParams">
		<xs:annotation>
			<xs:documentation>Used to write raw bytes into a data set (more like seek in, write)</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DataSet" type="tg:DataSet"/>
			<xs:element name="offset" type="xs:string">
				<xs:annotation>
					<xs:documentation>the start offset in the data xs:unsignedLong</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="length" type="xs:string">
				<xs:annotation>
					<xs:documentation>the number of bytes that are written xs:unsignedLong</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice minOccurs="0">
				<xs:annotation>
					<xs:documentation>Data Source</xs:documentation>
				</xs:annotation>
				<xs:element name="content-MIME-ID" type="xs:string">
					<xs:annotation>
						<xs:documentation>This must be either a xs:Qname or URI  or somthing pointing to the attachment content id of the MIME or DIME that can be present along with the DataGridRequest</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:sequence>
					<xs:annotation>
						<xs:documentation>For writing data from external reources like FTPresource along with the userInfo required to write the content</xs:documentation>
					</xs:annotation>
					<xs:element name="externalURL" type="xs:string"/>
					<xs:element name="externalUser" type="tg:UserInfo" minOccurs="0"/>
				</xs:sequence>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="MetadataQueryOp">
		<xs:annotation>
			<xs:documentation>Metadata Query Operation</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdParams" type="tg:MetadataQueryParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="MetadataQueryParams">
		<xs:annotation>
			<xs:documentation>Params for metadata query</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="queryRequestString" type="xs:string"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="IngestMetadataOp">
		<xs:annotation>
			<xs:documentation>Ingest Metadata Operation</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="StdParams" type="tg:IngestMetadataParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="IngestMetadataParams">
		<xs:annotation>
			<xs:documentation>Params for ingest metadata</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DataGridObject" type="tg:StdDatagridObject"/>
			<xs:element name="Metadata" type="tg:MetaData"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="RedirectStatusOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:DownloadDataSetParams">
				<xs:annotation>
					<xs:documentation>Current Status could be either redirected to a data set a url or e-mail id (url)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="GetPhysicalLocationOp">
		<xs:choice>
			<xs:element name="StdParams" type="tg:GetPhysicalLocationParams"/>
			<xs:element name="FlexParams" type="tg:ParamList"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="GetPhysicalLocationParams">
		<xs:sequence>
			<xs:element name="logicalResource" type="tg:DataSet"/>
		</xs:sequence>
	</xs:complexType>
	<!-- RESPONSE ELEMENTS -->
	<xs:complexType name="RequestAcknowledgment">
		<xs:annotation>
			<xs:documentation>Acnowledgement sent on reciept of a Datagrid request  - immedietly. This is to faciliate psueo-asynchrony. In futre this acknowledgement might be avoided to proivde pure asynchrony.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="requestID" type="xs:string"/>
			<xs:element name="requestState" type="xs:int">
				<xs:annotation>
					<xs:documentation>specifies if the request was submited to the DataGrid Request Queue. </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Status">
		<xs:sequence>
			<xs:element name="statusCode" type="xs:int">
				<xs:annotation>
					<xs:documentation>would indicate if the status of the step (started, completed, not in queue, unknown step etc) based on the status query</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="statusDescription" type="xs:string" minOccurs="0"/>
			<xs:element name="Result" type="tg:OpResult" minOccurs="0"/>
			<xs:element name="Variables" type="tg:tVariables" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="ID" type="xs:string" use="required"/>
		<xs:attribute name="ItrID" type="xs:integer" use="optional" default="1"/>
		<xs:attribute name="startTime" type="xs:dateTime" use="optional"/>
		<xs:attribute name="endTime" type="xs:dateTime" use="optional"/>
		<xs:attribute name="abortRequested" type="xs:boolean" use="optional"/>
	</xs:complexType>
	<xs:complexType name="StepStatusResponse">
		<xs:complexContent>
			<xs:extension base="tg:Status"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FlowStatusResponse">
		<xs:complexContent>
			<xs:extension base="tg:Status">
				<xs:choice minOccurs="0">
					<xs:element name="FlowStatusResponse" type="tg:FlowStatusResponse" maxOccurs="unbounded"/>
					<xs:element name="StepStatusResponse" type="tg:StepStatusResponse" maxOccurs="unbounded"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OpResult">
		<xs:annotation>
			<xs:documentation>Resultant Information for specific Operations added to the Response</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="returnValue" type="xs:int"/>
			<xs:element name="description" type="xs:string" minOccurs="0"/>
			<xs:element name="addlComments" type="xs:string" minOccurs="0"/>
			<xs:choice minOccurs="0">
				<xs:element name="prepareTicketResult" type="tg:PrepareTicketResult"/>
				<xs:element name="downloadDataSetResult" type="tg:DownloadDataSetResult"/>
				<xs:element name="listResult" type="tg:ListResult"/>
				<xs:element name="seekNReadResult" type="tg:SeekNReadResult"/>
				<xs:element name="metadataQueryResult" type="tg:MetadataQueryResult"/>
				<xs:element name="executeProcessResult" type="tg:ExecuteProcessResult"/>
				<xs:element name="redirectStatusResult" type="tg:DownloadDataSetResult"/>
				<xs:element name="getPhysicalLocationResult" type="tg:GetPhysicalLocationResult"/>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PrepareTicketResult">
		<xs:sequence>
			<xs:element name="gridTicket" type="tg:GridTicketInfo"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DownloadDataSetResult">
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:element name="contentId">
					<xs:annotation>
						<xs:documentation>This is either a xs:Qname or URI  or somthing pointing to the attachment content id of the MIME or DIME that is be present along with the DataGridResponse</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="externalURl">
					<xs:annotation>
						<xs:documentation>URL of the external reource like FTPresource where the conetent was dowloaded from the datagrid</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="urlUpdated" type="xs:anyURI"/>
			</xs:choice>
			<xs:element name="comments">
				<xs:annotation>
					<xs:documentation>Any addl comments (esp) comments from the external resource that might have been used.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ListResult">
		<xs:sequence>
			<xs:element name="Listing" type="tg:CollectionList"/>
			<xs:element name="depthLevel" type="xs:int" default="-1" minOccurs="0">
				<xs:annotation>
					<xs:documentation>-1 indicates complete depth was searched</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SeekNReadResult">
		<xs:sequence>
			<xs:choice>
				<xs:element name="contentId">
					<xs:annotation>
						<xs:documentation>This is either a xs:Qname or URI  or somthing pointing to the attachment content id of the MIME or DIME that is be present along with the DataGridResponse</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="externalURl">
					<xs:annotation>
						<xs:documentation>URL of the external reource like FTPresource where the conetent was dowloaded from the datagrid</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="comments">
				<xs:annotation>
					<xs:documentation>Any addl comments (esp) comments from the external resource that might have been used.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ExecuteProcessResult">
		<xs:sequence>
			<xs:element name="Output" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Yes, this can be complicatied  stuff later. but, this is some thing to start with</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="std_out" type="tg:StreamData" minOccurs="0"/>
			<xs:element name="std_err" type="tg:StreamData" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="MetadataQueryResult">
		<xs:sequence>
			<xs:element name="queryResults" type="tg:MetadataQueryInfo"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="GetPhysicalLocationResult">
		<xs:sequence>
			<xs:element name="physicalLocation" type="xs:string"/>
		</xs:sequence>
	</xs:complexType>
</xs:schema>
