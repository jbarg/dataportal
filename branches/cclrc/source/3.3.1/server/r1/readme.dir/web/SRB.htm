<HTML>
<HEAD>
<TITLE>SRB</TITLE>
<BODY bgcolor=#BBFF00FA>
<IMG SRC="http://www.npaci.edu/images/DI.gif" WIDTH="555" HEIGHT="90"></P>
<FONT FACE="Courier New" SIZE=4>
<A NAME="Beginning"></A>
<P>&nbsp;</P>
<H1>SRB - The Storage Resource Broker (Version 2.0.0) </H1>
<BR><A HREF="README.first.htm">Release Notes for Version 2.0.0</A>
<P>&nbsp;</P>
<BR><A HREF="#Major features of the SRB">1.0 The SRB Architecture</A>
<DIR>
<A HREF="#Major features of the SRB">1.1 Major features of the SRB </A>
<BR><A HREF="#An Overview of the SRB architecture">  1.2 An Overview of the SRB architecture</A>
<BR><A HREF="#Implementation details">1.3 Implementation details</A>
<DIR>
<A HREF="#The SRB process model">1.3.1 The SRB process model</A>
<BR><A HREF="#Federated SRB servers">1.3.2 Federated SRB servers</A>
<BR><A HREF="#The SRB agent design details">1.3.3 The SRB agent design details</A>
<BR><A HREF="#The SRB container design">1.3.4 The SRB container design</A>
</DIR>
</DIR>
<A HREF="#The SRB client API">2.0 The SRB client API</A>
<DIR>
<A HREF="#Overview">2.1 Overview</A>
<BR><A HREF="#Description of API">2.2 Description of API</A>
</DIR>
<A HREF="#Setting up Client Environment">3.0 Setting up Client Environment</A>
<DIR>
<A HREF="#Building and installing the SRB client library">3.1 Building and installing the SRB client library</A>
<BR><A HREF="#Setting up the client user environment">3.2 Setting up the client user environment</A>
<BR><A HREF="#Locations of the SRB client library and header files">3.3 Locations of the SRB client library and header files</A>
</DIR>
<A HREF="#Client Programming">4.0 Client Programming</A>
<DIR>
<A HREF="#Connecting and disconnecting to the SRB Server">4.1 Connecting and disconnecting to the SRB Server</A>
<BR><A HREF="#Error handling">4.2 Error handling</A>
<BR><A HREF="#Client programming examples">4.3 Client programming examples</A>
</DIR>
<A HREF="#Installing and configuring the SRB servers">5.0 Installing and configuring the SRB servers</A>
<DIR>
<A HREF="#Building and installing the SRB server">5.1 Building and installing the SRB server</A>
<BR><A HREF="#Configuring the SRB servers">5.2 Configuring the SRB servers</A>
<DIR>
<BR><A HREF="#Quick server setup">5.2.1 Quick server setup</A>
<BR><A HREF="#Detailed server setup">5.2.2 Detailed server setup</A>
</DIR>
<BR><A HREF="#Starting the SRB server">5.3 Starting the SRB server</A>
<BR><A HREF="#Running the test suite">5.4 Running the test suite</A>
</DIR>
<BR><A HREF="#Building and Running the srbBrowser">6.0 Building and Running the JAVA based srbBrowser </A>
<DIR>
<BR><A HREF="#Building the srbBrowser">6.1 Building the JAVA based srbBrowser </A>
<BR><A HREF="#Running the srbBrowser">6.2 Running the JAVA based srbBrowser </A>
</DIR>
<BR><A HREF="#Building and Running the srbMon">7.0 Building and Running srbMon - a SRB server monitoring program</A>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Appendix A - Descriptions of the SRB Client API</A>
<P><A HREF="#Appendix B">Appendix B - Descriptions of the DataCutter Client API</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>

<H2>1.0 The SRB Architecture</H2>
<A NAME="Major features of the SRB"></A>
<H3>1.1 Major features of the SRB </H3>
<P>1) SRB server - The Storage Resource Broker (SRB) is a middleware that provides distributed clients with uniform access to diverse storage resources in a heterogeneous computing Environment. Storage systems handled by the current release of the SRB include the UNIX file system, archival storage systems such as UNITREE and HPSS, and database Large Objects managed by various DBMS including DB2, Oracle and Illustra.</P>
<P>2) Client library - Client applications are provided with a set of API for sending requests and receiving response to/from the SRB servers.</P>
<P>3) MCAT server - The meta data of the SRB system is managed by the MCAT server which is based on relational database technology. The MCAT server stores meta data associated with data sets, users and resources managed by the SRB. Detailed descriptions on the design of MCAT are given in <B><A HREF="http://www.npaci.edu/DICE/Software/SRB/mcat.html">http://www.npaci.edu/DICE/Software/SRB/mcat.html</A></B>. Meta data includes information for access control, and data structures required for implementing "collection" (directory) abstraction. Since the MCAT is implemented with relational database technology, it can be extended beyond the capability of traditional file system, such as implementing a more complex access control system, proxy operations, and information discovery based on system level and application level meta data. </P>
<P>4) A set of UNIX like utilities (e.g., ls, cp, chmod, etc) for manipulating and querying collections and datasets in the SRB space. </P>
<P>5) A JAVA based SRB client GUI - The srbBrowser is a JAVA based SRB client GUI which can be used to perform a variety of client level operations including replication, copy and paste, registration of datasets and metadata manipulation and query, etc. </P>
<P>6) A logical view of data - The MCAT presents clients with a logical view of data sets stored in the SRB. Similar to the file name in the file system paradigm, each data set stored in SRB has a logical name, which may be used as a handle for data operation. Unlike the file system where the physical location of a file is implicitly implied in its path name through its mount point, the physical location of a data set in the SRB environment is logically mapped to the data sets. Therefore, the actual data of data sets belonging to the same collection may physically reside in different storage systems. A client does not need to remember the physical mapping of a data set. It is stored as the meta data associated with the data set.</P>
<P>7) The global logical name space – Similar to file system paradigm, data sets can be arranged in a directory-like structure, which we call <B>collection</B>. Collections provide a logical grouping mechanism where each collection may contain a group of physically distributed data sets and/or sub-collections.</P>
<P>8) The container abstraction – Due to the relative high overhead of creating/opening files in archival storage systems such as HPSS, they are not suitable for storing large amount of small files typically found in digital library systems. The container concept was specifically created to handle this type limitation. Through the use of containers, many small files can be aggregated in the cache system before storage in the archival storage system. A caching system has been designed to handle container I/O. The current version of the SRB server has been designed to handle multiple archival and cache storage resources.</P>
<P>9) "Server driven" parallel I/O - The "Server driven" parallel I/O scheme has been implemented throughout the SRB infrastructure. It is the preferred data transfer mechanism for data import, export, copy and replication. The parallel I/O uses the more efficient "mover" APIs and protocol to access HPSS resources.</P>
<P>10) A Mass Storage System (MSS) implementation within SRB - The system can be configured to have a pool of disk cache resources in the frontend and a STK tape silo library in the backend. Data files stored in this system are automatically staged to the disk cache whenever accessed and migrate to the tape library when more free cache space is needed.</P>
<P>11) Support four authentication schemes - The SRB can now support four authentication schemes - GSI, SEA (developed at SDSC), plain text password and encrypted password. GSI (Grid Security Infrastructure) is a security infrastructure based on X.509 certificates developed by the Globus group <A HREF="http://www.npaci.edu/DICE/security/index.html">(http://www.npaci.edu/DICE/security/index.html)</A>. SEA is a authentication and encryption scheme developed at SDSC based on RSA key encryption scheme. <A HREF="http://www.npaci.edu/DICE/Software/SEA/index.html">(http://www.npaci.edu/DICE/Software/SEA/index.html)</A></P>
<P>12) Ticket - The Ticket abstraction has been implemented to facilitate the sharing of data among users. The Ticket implementation works as follows:</P><DIR>
<DIR>

<P>i) The owner of a data object or collection may grant read only access to a user or a group of users through issuance of tickets on the data object or collection. </P>
<P>ii) A ticket is a 10 character alphanumeric string and can be passed from the ticket issuer to the ticket users. A ticket user can then use this ticket to open and read data objects.</P>
<P>&#9; </P>
<P>&#9;iii) A ticket can be issued to either MCAT registered or unregistered users. Unregistered users who wish to use a ticket to access a data object must use a special call to connect to the SRB sever. The normal user authentication will then be bypassed but the resulting connection has only limited privileges. </P>
<P>&nbsp;</P></DIR>
</DIR>

<P>13) Logical resource implementation - the RESOURCE meta data has been modified to allow grouping of two or more physical resources into a resource group or logical resource. Logical resources can be used in more than one way. A logical resource can be used to group together a pool of disk cache and appears as one large disk cache, or it can be used to automatically replicate data in each of the physical resource belonging to the logical resource. <P>
<P>13) Data replication – The SRB supports data replication. The following gives some details of the implementation:</P>
<P>&#9;</P><DIR>
<DIR>

<P>i) Automatic replication of new data - When creating a data set, a client can specify a logical resource rather than a physical resource as the resource input. With the COPIES=ALL flag set, a copy of the data will be created in each of the physical resource belonging to the logical resource. </P>
<P>ii) Replication of existing data - A user can use the Sreplicate command or the srbObjReplicate() API to replicate existing data to the specified resource. </P></DIR>
</DIR>

<P>14) Replica synchronization - Copies of replica can modified individually and replica of an object can be out of sync. Now, the most recently modified copy will be marked as "dirty".  A new command - "Ssyncd" and API - srbSyncData() has been created to synchronize all copies (replica) of an SRB object with the dirty copy.  A "%" character to the left of the file name of a "Sls -l" output indicates the given copy is "dirty".<P>

<P>15) Proxy operation - Some operations can be more efficiently done by the server without much involvement by the client. An example is the copy operation where it is more efficient for the server to do all the read and write operations on behalf of the client than passing the data read to the client and then for the client passing it back to the server for the write operation. A framework for handling proxy operations has been set up to facilitate the building of new proxy functions. These proxy functions can be in the form of either direct codes in the SRB server or individual executables which are accessible by users the the Spcommand utility or the srbExecCommand() API </P>
<P>16) Bulk Ingestion - A bulk ingestion mode has been implemented. This feature enables, a user to create a container  and register the requisite metadata in parallel and in bulk. The system has been tested at SDSC to ingest into SRB medium-sized data files in large directory structures at more than 400 files per second. The feature is available through the command called Sbload. <P>
<P>17) Auditing - Auditing provides a facility to audit the usage of data sets. </P>
<P>18) srbMon - a SRB server monitoring daemon. The srbMon is a SRB monitoring daemon which remotely monitors and logs all SRB servers belonging to a federation, and attempts to restart any servers that were found to be down. </P>
<P>19) UNIX Transparency - This involves using the PRELOAD feature of the Solaris and Linux platform to trap UNIX I/O system calls and replaced them with SRB I/O calls so that regular UNIX commands and applications can be used to access and manipulate data stored in SRB without recompiling. Please read README.transparency for more info on this subject. </P>

<P>20) Support file size larger than 2GB - The SRB software will now support file size larger than 2 GB for the Solaris, Linix, Aix and C90 platforms.</P>

<P>21) Prespawning server processes - To improve interactivity, the SRB servers can now be configured to prespawn a specific number of server processes. <P>

<P>22) Platforms supported – The SRB has been implemented on AIX, Sun Solaris(32 and 64 bits address), Linux 32 and 64 bits address), SunOs, DEC OSF, SGI, MacOS X and the Cray C90. The MCAT catalog now runs on both the Oracle and DB2 DBMS.</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="An Overview of the SRB architecture"></A>
<B><P>1.2 An Overview of the SRB architecture</P>
</B><P>The Storage Resource Broker (SRB) is a middleware that provides distributed clients with uniform access to diverse storage resources in a heterogeneous computing Environment. </P>

<P><IMG SRC="http:img001.GIF"><P>

Figure 1
gives a simplified view of the SRB architecture. The model consists of three components: the meta data catalog (MCAT) service, SRB servers and SRB clients, connected to each other via network. </P>
<P>The MCAT stores meta data associated with data sets, users and resources managed by the SRB. The MCAT server handles requests from the SRB servers. These requests include information queries as well as instructions for meta data creation and update. </P>
<P>Client applications are provided with a set of API for sending requests and receiving response to/from the SRB servers. The SRB server is responsible for carrying out tasks to satisfy the client requests. These tasks include interacting with the MCAT service, and performing I/O on behalf of the clients. A client uses the same common API to access every storage systems managed by the SRB. The complex tasks of interacting with various types of storage system and OS/hardware architecture, are handled by the SRB server. </P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Implementation details"></A>
<B><P>1.3 Implementation details</P>
</B><P>&nbsp;</P>
<A NAME="The SRB process model"></A>
<B><P>1.3.1 The SRB process model</P>
</B>
<P><IMG SRC="http:img002.GIF"><P>

Figure 2 depicts the SRB process model. The design of the SRB server is based on the traditional network connected client/server model. It is composed of two separate servers, SRB Master and SRB Server. The SRB Master is the main daemon listening continuously on a well-known port for connection requests from clients. Once a connection from a client is established and authenticated, it forks and execs a copy of the SRB Server, which we call SRB agent, to service the connection. From that point onward, the client and the SRB agent communicate using a different port and the SRB Master goes back to listening for more connections. A client can use the same SRB agent to service multiple requests. </P>
<P>Client applications communicate with the SRB agent using a set of API via TCP/IP sockets. The client library sends requests using pre-defined request stubs to the SRB agent, and receives and parses replies from the SRB agent. The model is distributed in the sense that clients and servers may be running on different hosts.</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Federated SRB servers"></A>
<B><P>1.3.2 Federated SRB servers</P>
</B><P>&nbsp;</P>
<P>A group of distributed SRB servers coordinating with each other to service client requests, can be configured to form a federation. The advantages of a federated SRB are as follows:</P><DIR>
<DIR>

<P>o For technical and policy reasons, various storage systems must run on different hosts.</P></DIR>
</DIR>

<P>o Improved performance.</P><DIR>
<DIR>

<P>o Improved data reliability and availability – Replica of data may be stored in different storage systems and on different hosts.</P></DIR>
</DIR>

<P><IMG SRC="http:img003.GIF"><P>

Figure 3 depicts the working of a federated SRB, which consists of two SRB masters, running on hosts A and B. The SRB server on A is MCAT enabled meaning that it can talk to the MCAT server. In this example, a client "open data set" request may result in the following steps: </P><DIR>
<DIR>

<P>1) After completing the connection sequence with the SRB master on host A, the client sends a request to the SRB agent on host A to open a data set for reading.</P>
<P>2) The SRB agent makes a MCAT call passing the client’s user ID and the data set name to the MCAT server to check if the client has the proper access permission to the data set. If it checks out, the MCAT call returns a data structure that contains the physical location where the data set is stored. The physical location data structure includes the host name, the storage system type (e.g., UNIX, HPSS, DB2 Large Object, etc) and the path name (e.g. a unix file path).</P>
<P>3) The SRB agent on host A realizes the requested data set is on host B and carries a remote open on behalf on the client passing along the storage system type and the path name to the SRB agent on host B.</P>
<P>4) The SRB agent on host B uses the storage system type to invoke the appropriate low level storage driver to invoke to handle the open call, passing along the path name to be opened. Upon completion of the open call, the SRB agent on host B returns the opened file descriptor or error code to the SRB agent on host A.</P>
<P>5) If the open call is successful, the SRB agent on host A stores the returned file descriptor and other information such as host name, etc in a internal data structure and pass back the pointer to this data structure to the client. The client can then use this pointer in subsequent read calls; if the open call is not successful, an error code is returned instead.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></DIR>
</DIR>

<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="The SRB agent design details"></A>
<B><P>1.3.3 - The SRB agent design details</P>
</B><P>As described above, the SRB is designed based on the traditional client/server model. Client applications are provided with a set of simple API to communicate with the SRB servers. The main daemon, the SRB master, is responsible for the simple tasks of listening for incoming connections, and spawning a SRB agent to handle each connection once the client is authenticated. The SRB agents are responsible for receiving and servicing all subsequent client requests.</P>

<P><IMG SRC="http:img004.GIF"><P>

Figure 4
 gives a simplified view of the SRB agent design. </P>
<P>At the top is the "dispatcher" module, which listens for incoming client requests and dispatches the requests to the proper request handlers. The "dispatcher" is also responsible for returning the results to clients.</P>
<P>Clients are provided with two sets of API, the high-level and low-level API. The high-level API handles data sets that use the MCAT server for meta data management, while the low-level API handles data sets that do not use the MCAT. When using the high-level API to create a data set, the data set is automatically registered in MCAT and the MCAT keeps all relevant information associated with the data set until the data set is deleted. On the other hand, data sets created using the low-level API are not registered in MCAT. When accessing a data set using the low-level API, a client needs to provide all required information such as the physical location (host address and full path name) and the storage system type of the data set. Detailed descriptions of the client API are given in <A HREF="#Appendix A">Appendix A</A>.
<P>The high-level request handler of the SRB agent handles all high-level client requests, and the low-level request handler handles low-level client requests.</P>
<P>Through the high-level API, a client can access the following type of services provided by the SRB agents:</P>
<P>&#9;1) Create and remove data sets. </P>
<P>&#9;2) Perform I/O operations on data sets.</P><DIR>
<DIR>

<P>3) Manipulate and query meta data associated with the data sets and collections.</P></DIR>
</DIR>

<P>&#9;4) Manipulate and query meta data associated with other objects such as &#9;users, user-groups and resources managed by the SRB.</P>
<P>&nbsp;</P>
<P>All these operations require the high-level request handler to interact with the MCAT service to manipulate and query the meta data stored in MCAT. In addition, for requests that perform operations on data set (1) and 2)), low-level requests will be generated and dispatched to the low-level request handler for further processing.</P>
<P>A set of library calls is used by the high-level request handler to interact with the MCAT service. These calls allows the SRB agent to register, unregister and modify meta data associated with data sets, users and storage resources, and to query the meta data. Basically, these routines translate easy-to-understood input parameters into complex SQL queries and send them to the MCAT server. Upon receiving the query results from the MCAT server, these routines parse the query results into simple forms before returning them to the caller. </P>
<P>The type of MCAT call made by the SRB agent depends on the type of client call the SRB agent is trying to handle. For example, to handle a "create data set" call, a query is sent to the MCAT server on the requested storage resource. If the client is allowed to create data set in this storage resource, it returns the physical location (host name, directory path) and storage system type of the requested storage system to the caller. Using the returned directory path, a unique physical path name (e.g., UNIX or HPSS path name) is generated. A low-level "create" call is generated and dispatched, passing on the host name, path name and storage system type parameters to the low-level request handler. If the low-level create call is successful, a "register data set" call is made to the MCAT server, passing on the data set name, the collection in which to put the data set, the storage resource, the physical path name and the user name. The MCAT registration routine does a few sanity checks (such as the permission to create data sets in the specified collection, duplicate data set name, etc). If the registration is successful, a set of meta data associated with the newly created data set is added to the MCAT catalog. Finally, the SRB agent returns a handle to the client. The client can then use this handle for subsequent read/write calls. If the data set register call is unsuccessful, a low-level unlink call is dispatched and an error is returned to the client.</P>
<P>The low-level request handler handles low-level client requests dispatched directly from the request dispatch, or high-level client requests passed indirectly through the high-level request handler module. This module performs the basic I/O operations on behalf of the client on the various storage systems managed by the SRB agent. The common parameters passed to this module are the resource location (host name), the storage system type (UNIX, HPSS, DB2, etc) and the physical path name (UNIX path name). If the requested storage system is not local, it dispatches a remote call to the appropriate SRB agent. Otherwise, it calls its low-level drivers to carry out the I/O operation. </P>
<P>Two types of drivers, the file-type and the DB-type, are supported. The file-type drivers provide UNIX-like file I/O interfaces to the file system of the storage systems, i.e., UNIX, UniTree and HPSS. Other non-file system type drivers, such as FTP and HTTP, are also grouped under this category because the similarities in the I/O interface. I/O operations supported by the file-type drivers are create, open, close, unlink, read, write, sync, seek, stat, chmod, mkdir, opendir, closedir and readdir.</P>
<P>The DB-type drivers provide I/O interface to DB large objects stored in DBMS, i.e., DB2, Oracle and Illustra. . I/O operations supported by the DB-type drivers are create, open, close, unlink, read, write and seek.</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<P>&nbsp;</P>
<A NAME="The SRB container design"></A>
<B><P>1.3.4 - The SRB container design</P>
</B><P>Due to the relative high overhead of creating/opening files in archival storage systems such as HPSS, they are not suitable for storing large number of small files typically found in digital library systems. The container concept was specifically designed  to circumvent  this type of limitation. The idea is through the use of containers, many small files can be aggregated in the cache system before storage in the archival storage system. The metadata for translating an inContainer object to file path, offset and size are kept in the MCAT and the SRB I/O drivers have been adapted to handle inContainer objects.</P>
<P>A caching system has been designed to handle container I/O. All container writes are done to the cache copy first. When a client is done filling up the container, a syncContainer call can be made to write the entire container copy to the archival storage system. For reading an object that has been stored in a container (inContainer object), if the container is not already on cache, the SRB server will stage the entire container to the cache first. Reading is done only on the cache copy. The metadata for translating an inContainer object to file path, offset and size are kept in the MCAT and the SRB I/O drivers have been adapted to handle inContainer objects.</P>
<P>The current version of the SRB server has been designed to handle multiple archival and cache storage resources. Multiple storage resources for containers was implemented through the use of logical resource. At the time of container creation, a logical resource is associated with the container being created through the srbContainerCreate() API.</P>
<P>Logical resource is an abstraction that contains one or more physical resources. Physical resource is a SRB abstraction that describe the underlying storage resources that can be accessed by the current SRB server configuration. In MCAT, a set of attributes is associated with a physical resource. Among other things, these attributes identify the location of the resource (host address and the path of the SRB vault), the type of resource (UNIX file system, HPSS file system and DB large objects), and the resource class (cache or permanent, primary or normal), etc.</P>
<P>The logical resource used to create a container should contain both classes of physical resources: "permanent/archival" (e.g., HPSS) and "cache" (e.g., UNIX disk file system) resources. A "cache" copy can be purged while a "permanent" copy is not purgable. Multiple resources for each resource class are allowed in which case, one and only one must be designated as "primary" for each resource class.</P>
<P>All container I/Os are done only to the copy on the "cache" type resource. If a "cache" copy does not exist (purged), the SRB server will attempt to stage a copy from the primary permanent resource to the primary cache resource first. If the primary permanent copy is not available (system or device down), other permanent copies will be used. Similarly, if the primary cache is not available, other cache resources belonging to the same logical resource will be used. It should be noted that the staging is done for the whole container rather than individual container segments. Once a "cache" copy is found or staged, read/write I/O can be carried out on objects contained in the container. If the cache copy has been modified, the srbSyncContainer() call or the Ssyncont command can be used to synchronize the cache copy to the archival resource.</P>
<P>The following software has been developed to support containers:</P>
<P>API - Five new  APIs, srbContainerCreate(), srbRmContainer(), srbGetContainerInfo(), srbSyncContainer() and srbReplContainer() have been created to create, remove, query container info, synchronize and replicate(or stage) copies of a container.</P>
<P>Command line utilities - Five command line utilities: Smkcont, Srmcont, Ssyncont, Slscont and Sreplcont to create, remove, sync, list meta-data  and replicate (stage) copies of a container.  The Slscont command allows the listing of all containers owned or accessible by a user as well as listing all inContainer objects stored in a given container.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="The SRB client API"></A>
<B><P>2.0 The SRB client API</P>
</B><P>&nbsp;</P>
<A NAME="Overview"></A>
<B><P>2.1 Overview</P>
</B><P>Clients are provided with a set of API for sending requests and receiving response to/from the SRB servers. </P>
<P>A majority of the API performs some kind of operations on data sets. Based on the type of data sets they operate on, these API may be classified into two groups, the high-level and low-level API. The high-level API handles data sets that use the MCAT server for meta data management, while the low-level API handles data sets that do not use the MCAT. When using the high-level API to create a data set, the data set is automatically registered in MCAT and the MCAT keeps all relevant information associated with the data set until the data set is deleted. On the other hand, data sets created using the low-level API are not registered in MCAT. </P>
<P>The low-level API can be subdivided further into file-type and DB-type API because of the different types of operation they support. </P>
<P>The rest of the API handles client/server connections, interacts with MCAT for information query and meta data creation and update.</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Description of API"></A>
<B><P>2.2 Description of API</P>
</B><P ALIGN="JUSTIFY">A brief description of the SRB client API is given below. The API are grouped into six categories according to functionality and the type of data set they operate on. A more detailed description of the API can be found in <A HREF="#Appendix A">Appendix A</A>.</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><P>1) Client/server connection API</B> – This set of API handles opening and closing connection to a SRB server.</P>
<P><A HREF="#clConnect">clConnect</A> - Initiate a connection to a SRB server.</P>
<P><A HREF="#tiUserConnect">tiUserConnect</A> – Initiate a connection to a SRB server by a TICKET USER. Normal authentication will be bypassed for a TICKET USER.</P>
<P><A HREF="#clFinish">clFinish</A> - Close the current connection and free the srbConn data structure.</P>
<P><A HREF="#clErrorMessage">clErrorMessage</A> - Return the ErrorMessage of a connection. This is the error message returned by the SRB server from the current client call.</P>
<B><P>2) High-Level API:</P>
</B><P><A HREF="#srbObjOpen">srbObjOpen</A> - Open a SRB data set.</P>
<P><A HREF="#srbObjOpenWithTicket">srbObjOpenWithTicket</A> - Open a SRB data set using a ticket.</P>
<P><A HREF="#srbObjCreate">srbObjCreate</A> - Create a SRB data set.</P>
<P><A HREF="#srbObjClose">srbObjClose</A> - Close an opened data set.</P>
<P><A HREF="#srbObjUnlink">srbObjUnlink</A> - Unlink a data set.</P>
<P><A HREF="#srbObjRead">srbObjRead</A> - Read a block of data from a data set into buffer.</P>
<P><A HREF="#srbObjWrite">srbObjWrite</A> - Write content of buffer to a data set.</P>
<P><A HREF="#srbObjSeek">srbObjSeek</A> - Change the current read or write location on an data set.</P>
<P><A HREF="#srbObjSync">srbObjSync</A> - Sync an opened SRB object.</P>
<P><A HREF="#srbObjStat">srbObjStat</A> - Stat an SRB object.</P>
<P><A HREF="#srbObjStat64">srbObjStat64</A> - Stat an SRB object and put results in a stat64 struct.</P>
<P><A HREF="#srbObjGetdents">srbObjGetdents</A> -  The SRB equivalent of the UNIX getdents call.</P>
<P><A HREF="#srbObjGetdents64">srbObjGetdents64</A> - The SRB equivalent of the UNIX getdents64 call.</P>
<P><A HREF="#srbObjProxyOpr">srbObjProxyOpr</A> - Proxy Operation request.</P>
<P><A HREF="#srbExecCommand">srbExecCommand</A> - Remote execution of command.</P>
<P><A HREF="#srbObjReplicate">srbObjReplicate</A> - Make a copy of a data set.</P>
<P><A HREF="#srbObjMove">srbObjMove</A> - Move a copy of a data set to a new location.</P>
<P><A HREF="#srbCreateCollect">srbCreateCollect</A> - Create a SRB collection.</P>
<P><A HREF="#srbListCollect">srbListCollect</A> - List a SRB collection.</P>
<P><A HREF="#srbModifyCollect">srbModifyCollect</A> - Modify a SRB collection.</P>
<P><A HREF="#srbIssueTicket">srbIssueTicket</A> - Issue a ticket.</P>
<P><A HREF="#srbRemoveTicket">srbRemoveTicket</A> - Cancel a ticket.</P>
<P><A HREF="#srbContainerCreate">srbContainerCreate</A> - Create a container.</P>
<P><A HREF="#srbRmContainer">srbRmContainer</A> - Remove a container.</P>
<P><A HREF="#srbSyncContainer">srbSyncContainer</A> - Synchronize copies of a container.</P>
<P><A HREF="#srbReplContainer">srbReplContainer</A> - Replicate/stage a container.</P>
<P><A HREF="#srbObjGet">srbObjGet</A> - Export a file from SRB to local file system  using parallel I/O.</P>
<P><A HREF="#srbObjPut">srbObjPut</A> - Import a file from local file system to SRB using parallel I/O.</P>
<P><A HREF="#srbSyncData">srbSyncData</A> - Synchronize all copies (replica) of an SRB object with the most recently modified version</P>
<P>&nbsp;</P>
<B><P>3) Low-Level File-type API: </P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A> - Opens a file.</P>
<P><A HREF="#srbFileCreate">srbFileCreate</A> - Create a file.</P>
<P><A HREF="#srbFileUnlink">srbFileUnlink</A> - Unlink a file.</P>
<P><A HREF="#srbFileClose">srbFileClose</A> - Close a file.</P>
<P><A HREF="#srbFileRead">srbFileRead</A> - Read a block of data from a file into buffer.</P>
<P><A HREF="#srbFileWrite">srbFileWrite</A> - Write content of a buffer to a file. </P>
<P><A HREF="#srbFileSeek">srbFileSeek</A> - Change the current read or write location on a file.</P>
<P><A HREF="#srbFileSync">srbFileSync</A> - Sync a file.</P>
<P><A HREF="#srbFileStat">srbFileStat</A> – Get the status of a file.</P>
<P><A HREF="#srbFileFstat">srbFileFstat</A> – Get the status of a file descriptor.</P>
<P><A HREF="#srbFileMkdir">srbFileMkdir</A> - Create a new directory.</P>
<P><A HREF="#srbFileChmod">srbFileChmod</A> - Change the mode of a file or directory.</P>
<P><A HREF="#srbFileRmdir">srbFileRmdir</A> - Remove a directory.</P>
<P><A HREF="#srbOpendir">srbOpendir</A> - Opens a directory</P>
<P><A HREF="#srbClosedir">srbClosedir</A> - Close an opened directory</P>
<P><A HREF="#srbReaddir">srbReaddir</A> - Read a directory entry</P>
<P><A HREF="#srbSetStorAttri">srbSetStorAttri</A> - Set Attributes for a Storage System; establish connection.</P>
<P>Only used by FTP file type,</P>
<P>&nbsp;</P>
<B><P>4) Lower-level DB-type API:</P>
</B><P><A HREF="#srbDbLobjOpen">srbDbLobjOpen</A> - Open a DB Large Object.</P>
<P><A HREF="#srbDbLobjCreate">srbDbLobjCreate</A> Create a DB Large Object.</P>
<P><A HREF="#srbDbLobjClose">srbDbLobjClose</A> - Close a DB Large Object.</P>
<P><A HREF="#srbDbLobjRead">srbDbLobjRead</A> - Read a block of data from a DB large object into buffer.</P>
<P><A HREF="#srbDbLobjWrite">srbDbLobjWrite</A> - Write content of a buffer to a DB large object.</P>
<P><A HREF="#srbDbLobjSeek">srbDbLobjSeek</A> - Change the current read or write location of a DB large object.</P>
<P><A HREF="#srbDbLobjUnlink">srbDbLobjUnlink</A> - Unlink a DB large object.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><P>5) Lower-level DB table object API:</P>
</B><P><A HREF="#srbDbTableOpen">srbDbTableOpen</A> - Open a DB Table Object.</P>
<P><A HREF="#srbDbTableCreate">srbDbTableCreate</A> Create a DB Table Object.</P>
<P><A HREF="#srbDbTableClose">srbDbTableClose</A> - Close a DB Table Object.</P>
<P><A HREF="#srbDbTableRead">srbDbTableRead</A> - Read a block of data from a DB Table object into buffer.</P>
<P><A HREF="#srbDbTableWrite">srbDbTableWrite</A> - Write content of a buffer to a DB Table object.</P>
<P><A HREF="#srbDbTableSeek">srbDbTableSeek</A> - Change the current read or write location of a DB Table object.</P>
<P><A HREF="#srbDbTableUnlink">srbDbTableUnlink</A> - Unlink a DB Table object.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><P>6) API that interact with MCAT</B> – This set of API interacts with MCAT for information query and meta data creation and update<B>.</P>
</B><P><A HREF="#srbGetDatasetInfo">srbGetDatasetInfo</A> - Get some default Info on a SRB data set.</P>
<P><A HREF="#srbGetDataDirInfo">srbGetDataDirInfo</A> - Get arbitrary meta data info on users, data sets or resources by querying the MCAT catalog.</P>
<P><A HREF="#srbRegisterDataset">srbRegisterDataset</A> - Register a SRB data object.</P>
<P><A HREF="#srbUnregisterDataset">srbUnregisterDataset</A> - Unregister a SRB data object.</P>
<P><A HREF="#srbSetAuditTrail">srbSetAuditTrail</A> - Setting and Unsetting Audit Trail.</P>
<P><A HREF="#srbModifyDataset">srbModifyDataset</A> - Modify a SRB data set</P>
<P><A HREF="#srbChkMdasAuth">srbChkMdasAuth</A> - Authenticate a userName/passwd.</P>
<P><A HREF="#srbChkMdasSysAuth">srbChkMdasSysAuth</A> - Authenticate a userName/passwd for sys admin access.</P>
<P><A HREF="#srbRegisterUserGrp">srbRegisterUserGrp</A> - Register a user group</P>
<P><A HREF="#srbRegisterUser">srbRegisterUser</A> - Register a user.</P>
<P><A HREF="#srbModifyUser">srbModifyUser</A> - Modify a user info.</P>
<P><A HREF="#srbGetPrivUsers">srbGetPrivUsers</A> - Read the privileged users list.</P>
<P><A HREF="#srbGetMoreRows">srbGetMoreRows</A> - Get more rows of result from a srbGetDatasetInfo, srbGetDataDirInfo, srbListCollect or srbGetPrivUsers call.</P>
<P><A HREF="#freeSqlResult">freeSqlResult</A> - Free any memory associated with a SQL result struct including the SQL result struct itself.</P>
<P><A HREF="#clearSqlResult">clearSqlResult</A> - Clear the memory associated with a SQL result struct, but the SQL result struct is not freed.</P>
<P><A HREF="#printSqlResult">printSqlResult</A> - Print the content of a SQL result struct.</P>
<P><A HREF="#srbGetContainerInfo">srbGetContainerInfo</A> - Query metadata associated with a container.</P>

<P><A HREF="#srbRegisterLocation">srbRegisterLocation</A> - Register/create a new location.</P>
<P><A HREF="#srbIngestToken">srbIngestToken</A> - Ingest/create a new Token of type ResourceType, DataType,UserType, Domain, or Action.</P>
<P><A HREF="#srbRegisterResource">srbRegisterResource</A> - Register/create a new resource (physical or compound).</P>
<P><A HREF="#srbRegisterLogicalResource">srbRegisterLogicalResource</A> - Register/create a new logical resource.</P>
<P><A HREF="#srbRegisterReplicateResourceInfo">srbRegisterReplicateResourceInfo</A> - Add another physical resource to a logical or compound resource.</P>
<P><A HREF="#srbDeleteValue">srbDeleteValue</A> - Delete/remove a value of type location, user, or resource (other types are implemented but untested).</P>

<P><A HREF="#srbSetupSessionPublicKey">srbSetupSessionPublicKey</A> - Get the MCAT-enabled server's public key in preparation for transferring encryptioned information.</P>
<P><A HREF="#srbSetupSession">srbSetupSession</A> - set up a session (for encryption) with the MCAT-enabled server.</P>

<P>&nbsp;</P>
<B><P>6) Miscellaneous SRB API:</P>
</B><P><A HREF="#srb_perror">srb_perror</A> - Emits an SRB error message string corresponding to the input error code.</P>
<P><A HREF="#srbVaultInfo">srbVaultInfo</A> - Get Info on the SRB storage vault.</P>
<P><A HREF="#srbFreeVaultInfo">srbFreeVaultInfo</A> - Free memory taken by the vaultQueElement link list.</P>
<P><A HREF="#srbPrintVaultInfo">srbPrintVaultInfo</A> - Print out the VaultInfo link list.</P>
<P><A HREF="#srbHostConfig">srbHostConfig</A> - Get the storage vault information on a SRB host.</P>
<P><A HREF="#srbPrintHostInfo">srbPrintHostInfo</A> - Print the HostInfo link list.</P>
<P><A HREF="#srbFreeHostInfo">srbFreeHostInfo</A> - Free memory taken by the clHostElement link list.</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><P>&nbsp;</P>
<P>&nbsp;</P>
</B><P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Setting up Client Environment"></A>
<B><P>3.0 Setting up Client Environment</P>
</B><P>&nbsp;</P>
<A NAME="Building and installing the SRB client library"></A>
<B><P>3.1 Building and installing the SRB client library</P>
</B><P>This section describes the steps for building and installing the SRB client library – libSrbClient.a.</P>
<P>It should be noted that if the SEA authentication scheme is to be used and if the SEA library (libsea.a) does not already exist on your build platform, the SEA software which can be obtained at the URL <A HREF="http://www.npaci.edu/DICE/Software/SEA/index.html">http://www.npaci.edu/DICE/Software/SEA/index.html</A>, must be built first.</P>
<P>1) Edit the mk/mk.config file. All configurable parameters for building the SRB server and the client library are defined in this file. The parameters are self-explanatory through the comments given in this file. Some of the more important parameters are discussed below:</P>
<DIR>
<DIR>
<P>installDir - The absolute path of the SRB install directory. </P>
<P>PORTNAME - The OS platform of this SRB port. Currently, the SRB software runs on 8 platforms. i.e., valid PORTNAME's are : PORTNAME_solaris, PORTNAME_sunos, PORTNAME_aix, PORTNAME_linux, PORTNAME_osx, PORTNAME_alpha, PORTNAME_c90 and PORTNAME_sgi.</P>
<P>SRB_LARGEFILE64 - defines whether the 64 bit file size is supported by the
underlining driver of this SRB server.  Current, 64 bit file size is
supported by the PORTNAME_solaris, PORTNAME_aix, PORTNAME_linux and
PORTNAME_c90 platforms..</P>
<P>MDAS_AUTH - defines whether the MDAS authorization scheme will be supported for authentication. If used, the user/passwd pair registered with the MDAS catalog will be used to authenticate a user. Comment it out if your SRB server should not support MDAS authorization. It is ON (not commented out) by default. </P>
<P>SEA_AUTH - defines whether SEA authorization scheme will be supported. The software can be configured to support both SEA_AUTH and MDAS_AUTH. This is OFF (commented out) by default.</P>
<P>LIB_SEA - Is needed only if SEA_AUTH is defined. LIB_SEA specifies where the SEA client library is located. This library can be built from the SEA source branch in this package. This is commented out by default. </P>
<P>GSI_AUTH - defines whether GSI authorization scheme will be supported. The software can be configured to support GSI_AUTH, SEA_AUTH and MDAS_AUTH. This is OFF (commented out) by default.</P>
<P>LIB_GSI_AUTH - Is needed only if GSI_AUTH is defined. GSI_AUTH specifies where the GSI client library is located. This is commented out by default. </P>
<P>ADR_PROXY - defines whether the ADR DataCutter proxy operation will be supported.</P>
<P>JAVA_GUI and javaDir - JAVA_GUI defines whether the srbBrowser should be built. javaDir specifies the directory where the JDK software is installed. (e.g. /usr/local/apps/Java). In addition, if JAVA_GUI and javaDir are set, you must setenv CLASSPATH to "." and the path where the swing.jar is installed on your machine. e.g.  setenv CLASSPATH /local/generic/lib/java/swing/swing.jar:.</P>
<P>Note: This software must be built using JDK 1.1.6 or 1.1.7 and swing 1.0.2.</P>
</DIR>
</DIR>
<P>2) "cd" to the the main SRB directory and type in "gmake clean" and then "gmake" to make the SRB software.</P>
<P>3) Type in "gmake install" to install the software in the $(installDir) directory. This procedure installs the following module in the $(installDir) directory:</P>
<P>&#9;bin/libSrbClient.a - The client library.</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Setting up the client user environment"></A>
<B><P>3.2 Setting up the client user environment</B> </P>
<P>&nbsp;</P>
<P>Before a user can connect to the SRB server, the following user environment setup must be carried out:</P>
<P>1) The ~/.srb/..MdasEnv file - A template of the file can be found in utilities/envFiles/.MdasEnv of the distribution package. This file contains four parameters:</P><DIR>
<DIR>

<P>a) mdasCollectionHome - This is equivalent to the user's home directory (collect) and is created by the MCAT administrator at the time of the user registration.</P>
<P>b) mdasDomainHome - This is the domain name associated with the user. This domain name is assigned to the user at the time of the user registration.</P>
<P>c) srbUser - This is the user name of the user. This name is assigned to the user at the time of the user registration.</P>
<P>d) srbHost - This is the default host address of the SRB server when a SRB client initiates a SRB connection.</P>
<P>e) AUTH_SCHEME - This parameter defines the authentication scheme to use.  Valid input values are:</P><DIR>
<P>'PASSWD_AUTH' - Use the plain text password Mdas Authentication. If this option is chosen, an additional file containing the password the the .MdasAuth is required.</P>
<P>'ENCRYPT1' - Same as PASSWD_AUTH except the passwords are encrypted using a self contained scheme.</P>
<P>'SEA_AUTH' - Use the SEA authentication scheme.</P>
<P>'SEA_ENCRYPT' - Use the SEA authentication scheme plus encryption.</P>
<P>'GSI_AUTH' - Use the GSI authentication scheme. If this option is chosen, an additional  parameter SERVER_DN given below is required.</P>
<P>'GSI_SECURE_COMM' - Use the GSI authentication scheme and use the GSI I/O library for all socket communication between client and server. If this option is chosen, an additional  parameter SERVER_DN given below is required.</P>
<P>If this parameter is not defined, the Mdas Authentication scheme will be used.</P></DIR>
</DIR>
<P>2) Setting up user authentication - The SRB software can be built to support the GSI, SEA and password authentication schemes. The AUTH_SCHEME parameter in the .MdasEnv file is used to define the authentication scheme to use. Each authentication scheme requires a different setup by the user.</P><DIR>
<DIR>

<P>a) SEA authentication setup – A client needs to register him/herself with the SEA server by running the following command:</P>
<P>seaauth reg</P>
<P>This is a one time exercise which in effect, triggers the registration of the user and obtaining a password encrypted private key which will be placed in a file named ~/.SEAuuuuu@ddddd (where uuuuu is the user ID and ddddd is the user domain name). Then type in the following command:</P>
<P>seaauth auto</P>
<P>to generate an unencrypted private key in the /tmp directory which can be used directly by the SEA library routines to authenticate the user.</P>
<P>b) Password authentication setup - This is a plain text password setup where the password is generated at the time of user registration with the MCAT catalog. Upon receiving this password from the MCAT administrator, a user should place it in a file named ~/.srb/.MdasAuth which will be used directly by the SRB library to authenticate the user.</P>
<P>c) GSI authentication setup - Please read <A HREF="README.gsi.htm">README.gsi</A> and follow the HTTP links for GSI client environment setup suggested by in the document. Once the certification/key has been obtained and converted to PEM format for GSI use, look into the cert pem file with a text editor and locate the user "Distinguish Name" string. The string representing the "Distinguish Name" should look like the following:</P>

<P>subject=/C=US/O=NPACI/OU=SDSC/UID=srb/CN=Storage Resource Broker/Email=srb@sdsc.edu</P>

<P>Copy this string and send it to the SRB administrator for registration.<P>

<P>NOTE: Currently, the SDSC SRB servers are configured to handle both Mdas and SEA authentication.</P>
<P>&nbsp;</P></DIR>
</DIR>

<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Locations of the SRB client library and header files"></A>
<B><P>3.3 Locations of the SRB client library and header files </P>
</B><P>The SRB client library is installed in $(installDir)/bin/libSrbClient.a.</P>
<P>A client program should include the header file "srbClient.h" and the compilation header file search directive should include the following directories:</P>
<P>&#9;$(buildDir)/src/include</P>
<P>&#9;$(buildDir)/src/catalog/include</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Client Programming"></A>
<B><P>4.0 Client Programming</P>
</B><P>&nbsp;</P>
<A NAME="Connecting and disconnecting to the SRB Server"></A>
<B><P>4.1 Connecting and disconnecting to the SRB Server</P>
</B><P>The client uses the clConnect(char* srbHost, char* srbPort, char* srbAuth) call to connect to the SRB server. srbHost specifies the host where the SRB server is running. If the input value in NULL, it will use the env variable "srbHost" if it is defined. If it is not defined, the ~/.srb/.MdasEnv file will be checked next. If not, it will use the hostname of the client machine.</P>
<P>The srbPort input defines the port number (in character string) to connect to the SRB server. If the input value in NULL, it will use the env variable "srbPort" if it is defined. If not, it defaults to "5558". </P>
<P>The srbAuth input is used to define the password for MDAS or SEA authentication. For SEA authentication, this is the password used by the SEA library to decrypt the encrypted private key stored in the file ~/.SEAuuuuu@ddddd (where uuuuu is the user ID and ddddd is the user domain name). This input is not needed if an unencrypted private key is available in the /tmp directory (generated using the 'seaauth auto' command). To provide additional flexibility, a client may also use the env variable "srbAuth" to specify the password. A client may also supply the password in the ~.srb/.MdasAuth file. This file should only be readable by the file owner. If a client uses more than one method to specify the password, the value given in the clConnect () call will take precedent, then the env variable "srbAuth", and lastly, the ~.srb/.MdasAuth file.</P>
<P>After a connection to the SRB server has been opened, the client can then use the connection to issue requests to the SRB server.</P>
<P>Upon completion, the client should issue a clFinish(conn) call to </P>
<P>close the connection to the SRB server.</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Error handling"></A>
<B><P>4.2 Error handling</P>
</B><P>The SRB uses two methods to return error conditions to the client. The first is the commonly used method of returning a value with the client API. In general, for integer type return values, a negative returned value implies error. For string type returns, a NULL returned value implies error. The error code for integer type returns are given in include/srb_error.h . Typically, these are error codes that are internally generated by the SRB and MCAT. Given the integer error code, an error message string can be generated using the srb_perror() API or the Serror utility.</P>
<P>The SRB server can also return a more informative error conditions in the form of a text string, but the client must use the clErrorMessage(conn) call to retrieve the message. Typically, it contains a short message describing the error condition and often times, the error codes from the underlying storage system (e.g., HPSS, UniTree, etc) is also included.</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Client programming examples"></A>
<B><P>4.3 Client programming examples:</P>
</B><P>&nbsp;</P>
<P>Examples of SRB client can be found in the test/examples/src directory of the distribution.</P>
<P>The following are examples of using the High-Level Object API:</P>
<P>&#9;testsrb.c - Example of using a mixed bag of High Level Object API - &#9;<A HREF="#srbSetAuditTrail">srbSetAuditTrail</A>, <A HREF="#srbObjOpen">srbObjOpen</A>, <A HREF="#srbObjRead">srbObjRead</A>, <A HREF="#srbObjClose">srbObjClose</A>, <A HREF="#srbListCollect">srbListCollect</A>, &#9;<A HREF="#srbGetMoreRows">srbGetMoreRows</A>, <A HREF="#srbGetDatasetInfo">srbGetDatasetInfo</A>, etc. </P>
<P>&#9;srbcat.c - Cat a High Level Object - <A HREF="#srbObjOpen">srbObjOpen</A>, <A HREF="#srbObjRead">srbObjRead</A>, &#9;<A HREF="#srbObjClose">srbObjClose</A>.</P>
<P>&#9;testcoll.c - Example of using High Level Object API to manipulate &#9;collections - <A HREF="#srbListCollect">srbListCollect</A>, <A HREF="#srbGetMoreRows">srbGetMoreRows</A>, <A HREF="#srbCreateCollect">srbCreateCollect</A>, &#9;<A HREF="#srbModifyCollect">srbModifyCollect</A>, etc.</P>
<P>&#9;testcre.c - Example of creating High Level Object - <A HREF="#srbObjCreate">srbObjCreate</A>, &#9;<A HREF="#srbObjWrite">srbObjWrite</A>, <A HREF="#srbObjClose">srbObjClose</A>, etc.</P>
<P>&#9;testunlink.c - Example of removing High Level Object - <A HREF="#srbObjUnlink">srbObjUnlink</A>.</P>
<P>&#9;testrepl.c - Example of making replicate of an object - &#9;<A HREF="#srbObjReplicate">srbObjReplicate</A>.</P>
<P>&#9;testmove.c - Example of moving a High Level Object from one physical &#9;location to another - <A HREF="#srbObjMove">srbObjMove</A>.</P>
<P>&#9;testproxy.c - Example of a proxy copy operation - <A HREF="#srbObjOpen">srbObjOpen</A>, &#9;<A HREF="#srbObjCreate">srbObjCreate</A>, <A HREF="#srbObjProxyOpr">srbObjProxyOpr</A>.</P>
<P>&#9;issuetick.c - Example of issuing a ticket - <A HREF="#srbIssueTicket">srbIssueTicket</A>.</P>
<P>&#9;rmtick.c - Example of removing a ticket - <A HREF="#srbRemoveTicket">srbRemoveTicket</A>.</P>
<P>&#9;usetick.c - Example of using a ticket to read a dataset - &#9;<A HREF="#srbObjOpenWithTicket">srbObjOpenWithTicket</A> and <A HREF="#srbObjRead">srbObjRead</A>.</P>
<P>&#9;testtick.c - Example of a using a mixed bag of ticket type API - &#9;<A HREF="#srbIssueTicket">srbIssueTicket</A>, <A HREF="#tiUserConnect">tiUserConnect</A>, <A HREF="#clConnect">clConnect</A>, <A HREF="#srbObjOpenWithTicket">srbObjOpenWithTicket</A>, &#9;<A HREF="#srbRemoveTicket">srbRemoveTicket</A>, <A HREF="#srbObjRead">srbObjRead</A>, <A HREF="#srbObjClose">srbObjClose</A>.</P>
<P>&#9;testddir.c - Example of using the srbGetDataDirInfo call to query &#9;MCAT information - <A HREF="#srbGetDataDirInfo">srbGetDataDirInfo</A>.</P>
<P>&#9;testuser.c - Example of using sys admin API to query and manipulate &#9;MCAT user information - <A HREF="#srbChkMdasSysAuth">srbChkMdasSysAuth</A>, <A HREF="#srbRegisterUser">srbRegisterUser</A>, &#9;<A HREF="#srbRegisterUserGrp">srbRegisterUserGrp</A> and <A HREF="#srbRegisterUser">srbRegisterUser</A>.</P>
<P>&nbsp;</P>
<P>The following are examples of using the Low-Level File-type API:</P>
<P>&#9;testexf.c - Example of using a mixed bag of Extended File API - &#9;<A HREF="#srbFileMkdir">srbFileMkdir</A>, <A HREF="#srbFileRmdir">srbFileRmdir</A>, <A HREF="#srbFileChmod">srbFileChmod</A>, <A HREF="#srbFileUnlink">srbFileUnlink</A>, &#9;<A HREF="#srbFileCreate">srbFileCreate</A>, <A HREF="#srbFileWrite">srbFileWrite</A>, <A HREF="#srbFileClose">srbFileClose</A>, <A HREF="#srbFileStat">srbFileStat</A>, etc.</P>
<P>&#9;exfls.c - Example of using <A HREF="#srbOpendir">srbOpendir</A>, <A HREF="#srbReaddir">srbReaddir</A> and <A HREF="#srbFileStat">srbFileStat</A>.</P>
<P>&#9;exfrm.c - Remove an extended file - <A HREF="#srbFileUnlink">srbFileUnlink</A>.</P>
<P>&#9;testftp.c - Example of using the File-type API for the FTP &#9;file type.</P>
<P>&#9;testhttp.c - Example of using the File-type API for the HTTP &#9;file type.</P>
<P>&nbsp;</P>
<P>The following are examples of using the Low-Level DB-type Large Object API:</P>
<P>&#9;testLobj.c - Example of using the DB-type Large Object calls - &#9;<A HREF="#srbDbLobjCreate">srbDbLobjCreate</A>, <A HREF="#srbDbLobjUnlink">srbDbLobjUnlink</A>, <A HREF="#srbDbLobjOpen">srbDbLobjOpen</A> and <A HREF="#srbDbLobjClose">srbDbLobjClose</A>.</P>
<P>Other examples can be found in the test/testsuite and utilities/src directories.</P>
<P>The following gives a few specific examples of using the SRB client API:</P>
<P>1) <B>An example for using <A HREF="#clConnect">clConnect()</A>, <A HREF="#clFinish">clFinish()</A> and <A HREF="#clErrorMessage">clErrorMessage()</A>:<P>
</B><P>#include "srbClient.h"</P>
<P>/* Use the srbAuth and srbHost values defined in ~/.srb/.MdasEnv */</P>
<P>#define SRB_AUTH&#9;&#9;NULL</P>
<P>#define HOST_ADDR&#9;&#9;NULL</P>
<P>main(int argc, char **argv)</P>
<P>{</P>
<P>srbConn *conn;</P>
<P>int dirDesc;</P>
<P>int storSysType;</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>/* Connect to the SRB server */</P>
<P>conn = clConnect (HOST_ADDR, NULL ,SRB_AUTH);</P>
<P>/* check to see if the connection was successful */</P>
<P>if (clStatus(conn) != CLI_CONNECTION_OK) {</P>
<DIR>
<P>&#9;&#9;fprintf(stderr,"Connection to SRB server failed.\n");</P>
<P>&#9;&#9;fprintf(stderr,"%s",clErrorMessage(conn));</P>
<P>&#9;&#9;exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Open a file-type directory */</P>
<P>dirDesc = srbOpendir (conn, storSysType, HOST_ADDR, ".");</P>
<P>if (dirDesc &lt; 0) {</P>
<DIR>
<P>fprintf(stderr,"Unable to srbOpendir . \n");</P>
<P>fprintf(stderr,"%s",clErrorMessage(conn));</P>
<P>&#9;&#9;exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Disconnect */</P>
<P>clFinish(conn);</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><P>2) An example for creating a high-level data object and writing to it.</P>
</B><P>This example assumed a connection has already been made using example 1). The object is created in a storage resource named "unix-sdsc". This resource must have already been registered in MCAT. <P>
<P>#define DATATYPE&#9;&#9;"ascii text"</P>
<P>#define RESOURCE&#9;&#9;"unix-sdsc"</P>
<P>#define COLLECTION&#9;"/srbtest"</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>int in_fd, out_fd;</P>
<P>int nbytes, tmp;</P>
<P>char buf[BUFSIZE];</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>/* Create a data object with objID = argv[1] */</P>
<P>out_fd = srbObjCreate (conn, MDAS_CATALOG, argv[1],</P>
<P>DATATYPE, RESOURCE ,COLLECTION, NULL, 0);</P>
<P>if (out_fd &lt; 0) { /* error */</P>
<DIR>
<P>fprintf(stderr, "can't create obj \"%s\", status = %d\n", argv[1], </P>
<P>&#9;&#9;out_fd);</P>
<P>&#9;fprintf(stderr,"%s",clErrorMessage(conn));</P>
<P>&#9;exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Open a local file with filename = inFileName. */</P>
<P>in_fd = open (inFileName, O_RDONLY, 0);</P>
<P>if (in_fd &lt; 0) { /* error */</P>
<DIR>
<P>fprintf(stderr, "can't open file\"%s\"\n",</P>
<P>inFileName);</P>
<P>exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Read from the local file and write to the just created data object */</P>
<P>while ((nbytes = read(in_fd, buf, BUFSIZE)) &gt; 0) {</P>
<DIR>
<P>/* Write to the data object */</P>
<P>tmp = srbObjWrite(conn, out_fd, buf, nbytes);</P>
<P>if (tmp &lt; nbytes) {</P>
<DIR>
<P>fprintf(stderr, "Error: Read %d bytes, Wrote %d bytes.\n ",</P>
<P>nbytes, tmp);</P>
<P>exit_nicely(conn);</P>
</DIR>
<P>}</P>
</DIR>
<P>}</P>
<P>srbObjClose (conn, out_fd);</P>
<P>close (in_fd);</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><P>3) An example for creating and listing collections.</P>
</B><P>This example creates a new collection in a parent collection, and then the parent collection is listed.</P>
<P>&#9;</P>
<P>&#9;#Include "srbClient.h"</P>
<P>#define PARRENT_COLLECTION "/srbtest"</P>
<P>#define NEW_COLLECTION&#9;&#9; "foo"</P>
<P>#define ROWS_WANTED &#9; 2</P>
<P>char * parentCollection, newCollection;</P>
<P>int status;</P>
<P>mdasC_sql_result_struct *collResult;</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>parentCollection = PARRENT_COLLECTION;</P>
<P>newCollection = NEW_COLLECTION;</P>
<P>/* Create a new collection */</P>
<P>if ((status = srbCreateCollect (conn, MDAS_CATALOG, parentCollection,</P>
<P>newCollection)) &lt; 0) {</P>
<DIR>
<P>fprintf(stderr, "can't srbCreateCollect, status = %d\n", status);</P>
<P>exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* List the parent collection */</P>
<P>collResult = malloc (sizeof (mdasC_sql_result_struct));</P>
<P>if ((status = srbListCollect (conn, 0, COLLECTION, "R",</P>
<P>collResult, ROWS_WANTED)) &lt; 0) {</P>
<DIR>
<P>fprintf(stderr, "can't srbListCollect, status = %d\n", status);</P>
<P>exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>&nbsp;</P>
<P>printSqlResult (collResult);&#9;/* print the result */</P>
<P>clearSqlResult (collResult); /* clear the content of collResult */</P>
<P>/* Any more result ? */</P>
<P>while (collResult-&gt;continuation_index &gt;= 0) {</P>
<DIR>
<P>&#9; /* Yes, we have more. Get the next ROWS_WANTED rows */</P>
<P>if ((status = srbGetMoreRows(conn, 0,</P>
<P>collResult-&gt;continuation_index, collResult, ROWS_WANTED)) &lt; 0)</P>
<DIR>
<P>break;</P>
</DIR>
<P>/* Dump the result */</P>
<P>printSqlResult (collResult);</P>
<P>clearSqlResult (collResult); </P>
</DIR>
<P>}</P>
<P>&nbsp;</P>
<B><P>4) An example for a proxy copy operation.</P>
</B><P>This example performs a proxy copy operation. The source data object is opened and the destination data object is created first. Then a proxy copy operation is initiated.</P>
<P>#include "srbClient.h"</P>
<P>#define DATATYPE&#9;"ascii text"</P>
<P>#define RESOURCE&#9;"unix-sdsc"</P>
<P>#define COLLECTION&#9;"/srbtest"</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>int i, nbytes, tmp, in_fd, out_fd;</P>
<P>char in_fd_str[SML_BUF_SZ], out_fd_str[SML_BUF_SZ];</P>
<P>int status, nbytes;</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>/* open the source object with objID = argv[1] */</P>
<P>in_fd = srbObjOpen (conn, argv[1], O_RDONLY, COLLECTION); </P>
<P>if (in_fd &lt; 0) { /* error */</P>
<DIR>
<P>fprintf(stderr, "can't open obj\"%s\"\n", argv[1]);</P>
<P>exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Create the destination object with objID = argv[2] */</P>
<P>out_fd = srbObjCreate (conn, MDAS_CATALOG, argv[2],</P>
<P>DATATYPE, RESOURCE, COLLECTION, NULL, 0);</P>
<P>if (out_fd &lt; 0) { /* error */</P>
<DIR>
<P>fprintf(stderr, "can't create obj \"%s\", status = %d\n", argv[2],</P>
<P>&#9;out_fd);</P>
<P>&#9;fprintf(stderr,"%s",clErrorMessage(conn));</P>
<P>&#9;exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Convert fd to string */</P>
<P>sprintf (in_fd_str, "%d", in_fd);</P>
<P>sprintf (out_fd_str, "%d", out_fd);</P>
<P>/* Do a proxy copy operation */</P>
<P>nbytes = srbObjProxyOpr (conn, OPR_COPY, in_fd_str, out_fd_str);</P>
<P>printf ("\n\nBytes written: %d\n", nbytes);</P>
<P>srbObjClose (conn, out_fd);</P>
<P>srbObjClose (conn, in_fd);</P>
<P>&#9;</P>
<B><P>5) An example for issuing tickets and using tickets to open and read data objects.</P>
</B><P>A ticket can be issued to either MCAT registered or unregistered users. Unregistered users who wish to use a ticket to access a data object must use a special call to connect to the SRB sever. The normal user authentication will then be bypassed but the resulting connection has only limited privileges. </P>
<P>In this example, the client issues a ticket on a data object to unregistered users meaning any user may use the ticket to open and read the data object. This example then makes a second connection to the SRB as an unregistered user ("ticketuser") and use the ticket to open and read the data object.</P>
<P>#include "srbClient.h"</P>
<P>#define BUFSIZE&#9;&#9;4096</P>
<P>#define srbAuth&#9;&#9;NULL</P>
<P>#define HOST_ADDR&#9;&#9;NULL</P>
<P>#define COLLECTION "/srbtest"</P>
<P>#define BEGINTIME &#9;NULL</P>
<P>#define ENDTIME&#9;&#9;NULL</P>
<P>#define ACCESSCNT&#9;&#9;1&#9;/* Ticket is only good for 1 time access */</P>
<P>#define ROWS_WANTED 2 </P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>srbConn *conn, *conn1;</P>
<P>int nbytes, in_fd, out_fd;</P>
<P>char buf[BUFSIZE];</P>
<P>int status;</P>
<P>char *ticket;</P>
<P>char *ticketUser;</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>&#9;</P>
<P>/* Set up the first connection to issue a ticket */</P>
<P>conn = clConnect (HOST_ADDR, NULL, srbAuth);</P>
<P>/* check to see that the backend connection was successfully made */</P>
<P>if ((status = clStatus(conn)) != CLI_CONNECTION_OK) {</P>
<DIR>
<P>&#9;fprintf(stderr,"Connection to SRB server failed.\n");</P>
<P>&#9;fprintf(stderr,"%s",clErrorMessage(conn));</P>
<P>&#9;exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Issue a ticket on objID = argv[1] to any user, even unregistered */</P>
<P>ticketUser = "";&#9;/* Any user */</P>
<P>if ((status = srbIssueTicket (conn, argv[1], COLLECTION, COLLFLAG, </P>
<P>BEGINTIME, ENDTIME, ACCESSCNT, ticketUser, &amp;ticket)) &lt; 0) {</P>
<DIR>
<P>fprintf(stderr, "can't srbIssueTicket obj\"%s\", %d\n", </P>
<P>&#9; argv[1], status);</P>
<P>exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Print the ticket */</P>
<P>printf ("ticket = %s\n", ticket);</P>
<P>/* Make a second connection as a unregistered user ("ticketuser") */ </P>
<P>conn1 = tiUserConnect (HOST_ADDR, NULL);</P>
<P>if ((status = clStatus(conn1)) != CLI_CONNECTION_OK) {</P>
<DIR>
<P>fprintf(stderr,"Connection to srbMaster failed.\n");</P>
<P>fprintf(stderr,"%s",clErrorMessage(conn));</P>
<P>&#9; srbRemoveTicket (conn, ticket);</P>
<P>exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Use the 2nd connection and open the data object with the ticket */</P>
<P>in_fd = srbObjOpenWithTicket (conn1, argv[1], O_RDONLY, COLLECTION,</P>
<P>ticket);</P>
<P>if (in_fd &lt; 0) { /* error */</P>
<DIR>
<P>fprintf(stderr, "can't open obj\"%s\"\n", argv[1]);</P>
<P>&#9; srbRemoveTicket (conn, ticket);</P>
<P>&#9; exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Read the data object */</P>
<P>while ((nbytes = srbObjRead (conn1, in_fd, buf, BUFSIZE)) &gt; 0) {</P>
<DIR>
<P>&#9; printf ("Content of the object: \n%s\n", buf);</P>
</DIR>
<P>}</P>
<P>srbObjClose (conn1, in_fd);</P>
<P>clFinish(conn1);&#9;&#9;/* Close the second connection */</P>
<P>/* remove the ticket */</P>
<P>status = srbRemoveTicket (conn, ticket);</P>
<P>if (status &lt; 0) {</P>
<DIR>
<P>fprintf(stderr, "srbRemoveTicket error. status = %d\n", status);</P>
<P>fprintf(stderr,"%s",clErrorMessage(conn));</P>
</DIR>
<P>}</P>
<P>ClFinish(conn);&#9;&#9;/* Close the first connection */</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><P>6) An example for querying the MCAT catalog for information.</P>
</B><P>This example uses the <A HREF="#srbGetDataDirInfo">srbGetDataDirInfo()</A> call to query the MCAT catalog. This query selects the resource name, resource type, network address and path name, given the name of a data object.</P>
<P>&nbsp;</P>
<P>#include "srbClient.h"</P>
<P>#define srbAuth&#9;&#9;NULL</P>
<P>#define HOST_ADDR&#9;&#9;NULL</P>
<P>#define COLLECTION&#9;"/srbtest"</P>
<P>#define ROWS_WANTED 2</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>mdasC_sql_result_struct *myresult;</P>
<P>char qval[MAX_DCS_NUM][MAX_TOKEN];</P>
<P>int selval[MAX_DCS_NUM];</P>
<P>int i;</P>
<P>int status;</P>
<P>/* Initialize the selval and qval array. */</P>
<P>for (i = 0; i &lt; MAX_DCS_NUM; i++) {</P>
<DIR>
<P>&#9;&#9;selval[i] = 0;</P>
<P>&#9;&#9;sprintf(qval[i],"");</P>
</DIR>
<P>}</P>
<P>/* set up the query: Given the Data Object Name, select the path name,</P>
<P>* resource name, the network address and the resource type.</P>
<P>*/</P>
<P>sprintf(qval[DATA_NAME]," = '%s'",argv[1]);</P>
<P>selval[PATH_NAME] = 1;</P>
<P>selval[RSRC_NAME] = 1;</P>
<P>selval[RSRC_ADDR_NETPREFIX] = 1;</P>
<P>selval[RSRC_TYP_NAME] = 1;</P>
<P>myresult = malloc (sizeof (mdasC_sql_result_struct));</P>
<P>/* Send the query request */</P>
<P>if ((status = srbGetDataDirInfo(conn, 0, qval, selval, myresult, </P>
<P>ROWS_WANTED)) &lt; 0) {</P><DIR>
<P>fprintf(stderr, "can't srbGetDataDirInfo. status = %d.\n", </P>
<P>status);</P>
<P>&#9;exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Dump the result */</P>
<P>printSqlResult (myresult);</P>
<P>clearSqlResult (myresult); /* clear the content of myresult */</P>
<P>/* Print any additional rows */</P>
<P>while (myresult-&gt;continuation_index &gt;= 0) {</P>
<DIR>
<P>&#9;if ((status = srbGetMoreRows(conn, 0,</P>
<P>&#9; myresult-&gt;continuation_index, myresult, ROWS_WANTED)) &lt; 0)</P>
<DIR>
<P>break;</P>
</DIR>
<P>&#9;/* Dump the result */</P>

<P>printSqlResult (myresult);</P>
<P>clearSqlResult (myresult); </P>
</DIR>
<P>}</P>
<P>freeSqlResult (myresult);</P>
<P>&nbsp;</P></DIR>
</DIR>
<B><P>7) An example for creating a container and put an object in the container.</P>
</B><P>This example uses the <A HREF="#srbContainerCreate">srbContainerCreate()</A> call to create a container and the <A HREF="#srbObjCreate">srbObjCreate()</A> call to create an inContainer object. </P>
<P>&nbsp;</P>
<P>#include "srbClient.h"</P>
<P>#define srbAuth&#9;&#9;NULL</P>
<P>#define HOST_ADDR&#9;&#9;NULL</P>
<P>#define COLLECTION&#9;"/srbtest"</P>
<P>#define DATATYPE&#9;"generic"</P>
<P>#define LOG_RESC&#9;"test-log-resc"</P>
<P>#define CONTAINER_NAME&#9;"testContainer"</P>
<P>#define CONTAINER_SZ&#9;1000000</P>
<P>#define OBJECT_NAME&#9;"foo"</P>
<P>&#9;</P>
<P>char objName[MAX_TOKEN];</P>
<P>int status, fd;</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P></P>
<P>/* Create the container */</P>
<P>if ((status = srbContainerCreate (conn, MDAS_CATALOG, CONTAINER_NAME,</P>
<P>DATATYPE, LOG_RESC, CONTAINER_SZ)) &lt; 0) {</P><DIR>
<P>fprintf(stderr, "can't srbContainerCreate. status = %d.\n", </P>
<P>status);</P>
<P>&#9;exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>/* Create the inContainer obj */</P>
<P>&#9;</P>
<P>sprintf (objName, "%s&CONTAINER=%-s", OBJECT_NAME, CONTAINER_NAME);</P>
<P>out_fd = srbObjCreate (conn, MDAS_CATALOG, objName,</P>
<P>DATATYPE, "" ,COLLECTION, NULL, 0);</P>
<P>if (fd &lt; 0) { /* error */</P>
<DIR>
<P>fprintf(stderr, "can't create obj \"%s\", status = %d\n", OBJECT_NAME, </P>
<P>&#9;&#9;fd);</P>
<P>&#9;fprintf(stderr,"%s",clErrorMessage(conn));</P>
<P>&#9;exit_nicely(conn);</P>
</DIR>
<P>}</P>
<P>&#9;.</P>
<P>&#9;.</P>
<P>&#9;.</P>
</DIR>

<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Installing and configuring the SRB servers"></A>
<B><P>5.0 Installing and configuring the SRB servers</P>
</B><P>This section describes the steps for installing and configuring the SRB servers. The SRB architecture supports multiple SRB servers running on various hosts. Metadata of data sets, resources and users managed by the SRB is stored in the MCAT catalog maintained in a relational database (DBMS). Therefore, a SRB installation may consist of multiple SRB servers running on various hosts, but only one SRB server is designated to interface with the MCAT database server. This server is built by defining the ORAMCAT or DB2MCAT keyword (see section <B><A HREF="#Building and installing the SRB server">5.1</A> </B>for definition) in the mk/mk.config file. This server is marked by the MDAS_ENABLED keyword in the data/hostConfig file.</P>
<P>Before any SRB server can be started, the MCAT catalog must be built and the MCAT server (DBMS) running. In addition, the user starting the SRB servers must have already been registered as a privileged user in MCAT. Currently at SDSC, we are running the MCAT server on a Oracle DBMS and the MDAS_ENABLED SRB server running on host gabor.sdsc.edu. Please email srb@sdsc.edu if a site wishes to use our MCAT server for its SRB metadata. If a site wants to setup and run its own MCAT catalog, the installation and configuration of the MCAT and the MCAT server are given in <B><A HREF="http://www.npaci.edu/DICE/Software/SRB/mcat.html">http://www.npaci.edu/DICE/Software/SRB/mcat.html</A></B>.</P>
<P>If the SEA authentication scheme is to be used, and if the SEA library (libsea.a) does not already exist on your build platform, the SEA software which can be obtained at URL <A HREF="http://www.npaci.edu/DICE/Software/SEA/index.html">http://www.npaci.edu/DICE/Software/SEA/index.html</A>, must be built first.</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Building and installing the SRB server"></A>
<B><P>5.1 Building and installing the SRB server</P>
</B><P>The following describes the steps for building and installing the SRB server software:</P>
<P>1) Edit the mk/mk.config file. All configurable parameters for building the SRB server and the client library are defined in this file.</P>
<P>The SRB architecture supports multiple SRB servers running on various hosts. Each SRB server may be built with different options defined in the mk/mk.config file. For example, the SRB server on host A may include the driver for accessing HPPS and the SRB server on host B may include the driver for accessing the Lobj stored in DB2, etc.</P>
<P>The parameters are self-explanatory through the comments given in this file. Some of the more important parameters are discussed below:</P>

<DIR>
<P>a) Basic build configuration:</P>

<DIR>
<P>installDir - The absolute path of the SRB install directory. </P>
<P>PORTNAME - The OS platform of this SRB port. Currently, the SRB software runs on 8 platforms. Valid PORTNAMEs are: PORTNAME_solaris, PORTNAME_sunos, PORTNAME_linux, PORTNAME_aix, PORTNAME_alpha, PORTNAME_osx, PORTNAME_c90 and PORTNAME_sgi.</P>
</DIR>
<P>b) MCAT flags – Enable any MCAT service that would be controlled by this SRB server.</P>
<DIR>
<P>ORAMCAT - defines that this SRB server being built is MDAS enabled and the MCAT is stored in Oracle DBMS. Normally, only one SRB server is MDAS enabled. Commented out by default.</P>
<P>DB2MCAT - defines that this SRB server being built is MDAS enabled and the MCAT is stored in Oracle DBMS. Normally, only one SRB server is MDAS enabled. Commented out by default.</P>
<P>NOTE: Both ORAMCAT and DB2MCAT cannot be defined at the same time.</P>
</DIR>
<P>c) Authentication flags</P>
<DIR>
<P>MDAS_AUTH - defines whether the MDAS authorization scheme will be supported for authentication. If used, the user/passwd pair registered with the MCAT catalog will be used to authenticate a user. Comment it out if the SRB server does not support MDAS authorization.</P>
<P>SEA_AUTH - defines whether SEA authorization scheme will be supported. The software can be configured to support both SEA_AUTH and MDAS_AUTH.</P>
<P>LIB_SEA - Is needed only if SEA_AUTH is defined. LIB_SEA specifies where the SEA client library is located. This library can be built from the SEA source branch in this package.</P>
<P>GSI_AUTH - defines whether GSI authorization scheme will be supported. The software can be configured to support GSI_AUTH, SEA_AUTH and MDAS_AUTH. This is OFF (commented out) by default.</P>
<P>LIB_GSI_AUTH - Is needed only if GSI_AUTH is defined. GSI_AUTH specifies where the GSI client library is located. This is commented out by default. </P>
<P>NOTE: Currently, the SDSC SRB servers are configured to handle all three authentication.</P>
</DIR>
<P>d) ADR_PROXY - defines whether the ADR DataCutter proxy operation will be supported.</P>
<P>e) JAVA_GUI and javaDir - JAVA_GUI defines whether the srbBrowser should be built. javaDir specifies the directory where the JDK software is installed. (e.g. /usr/local/apps/Java). In addition, if JAVA_GUI and javaDir are set, you must setenv CLASSPATH to "." and the path where the swing.jar is installed on your machine. e.g.  setenv CLASSPATH /local/generic/lib/java/swing/swing.jar:.</P>
<P>Note: This software must be built using JDK 1.1.6 or 1.1.7 and swing 1.0.2.</P>
<P>f) Storage system flags – Flags such as HPSS, UTREE, FTP, DB_DB2, DB_Illustra, etc define whether a particular storage system will be supported by this SRB server. UNIX, FTP and HTTP are enabled by default. Other flags related to storage system:</P>
<DIR>
<P>SRB_LARGEFILE64 - defines whether the 64 bit file size is supported by the underlining driver of this SRB server.  Current, 64 bit file size is supported by the PORTNAME_solaris, PORTNAME_aix, PORTNAME_linux and PORTNAME_c90 platforms.:</P>

<P> If the HPSS flag is set, the NO_DCE flag specifies whether the DCEless client library developed by Mike Gleicher will be used.  Please contact Mike at mkg@san.rr.com for informations regarding licensing this library. If this flag is not set, the regular DCE authentication is assumed. In addition, a number of HPSS library and header directory paths including HPSS_LIB_DIR, HPSS_HDR_DIR, etc need to be specified for the build.</P>
</DIR>
<P>2) "cd" to the main SRB directory and type in "gmake clean" and then "gmake" to make the SRB software. The Makefile contains various options to make and clean all or a subset of the build.</P>
<DIR>
<DIR>
<P>&#9;gmake --- build all.</P>
<P>&#9;gmake clean --- clean all.</P>
<P>&#9;gmake srb --- build only the SRB server and client.</P>
<P>&#9;gmake clean_srb --- clean only the SRB server and client.</P>
<P>&#9;gmake util --- build only the utilities (S commands).</P>
<P>&#9;gmake clean_util ---  clean only the utilities.</P>
<P>&#9;gmake browser - build only the java srbBrowser GUI.</P>
<P>&#9;gmake clean_browser - clean only the java srbBrowser.</P>
</DIR>
</DIR>
<P>3) Type in "gmake install" to install the software in the $(installDir) directory. This procedure installs the following modules in the $(installDir) directory:</P>
<DIR>
<DIR>
<P>&#9;bin/runsrb - The script that starts the SRB </P>
<P>&#9;bin/srbMaster-2.0.0 - The frontend server.</P>
<P>&#9;bin/srbServer - The backend server (forked by the srbMaster-2.0.0 for each client connection).</P>

<P>&#9;bin/libSrbClient.a - The client library.</P>
<P>&#9;data/hostAuthConfig - The optional (needed only if HOST_BASED_AUTH in the mk.config file is set) host based authorization configuration file.</P>
<P>&#9;data/mcatHost - This file identifies the host on which the MCAT enabled SRB server and the authentication scheme to use to connect to this server.</P>
<P>&#9;data/hostConfig -  This is the optional SRB host configuration file. It is only needed when when you want to add aliases to your local hostName.</P>
<P>&#9;data/hpssCosConfig - This is the optional HPSS Class of Services configuration file. It is only needed if HPSS in the mk.config file is set.</P>
<P>&#9;data/hpssNodceAuth - The file contains authentication info for non-dce HPSS. It is only needed if the HPSS and NO_DCE flags in the mk.config file are set.</P>
<P>&#9;data/MdasConfig - The MDAS configuration file.</P>
<P>&#9;data/metadata.fkrel - This file defines the foreign key relationship between the MDAS catalog tables and is used internally by the SRB for query generation. This file should not be changed between releases.</P>
<P>&#9;data/LobjConfig - The database configuration file for the DB Large Object driver. Basically, it contains the userID and password for accessing each database server.</P>
</DIR>
</DIR>
<P>Files installed in the data/ directory are templates for various configuration files. Details for configuring these files are given in the next section.</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Configuring the SRB servers"></A>
<B><P>5.2 Configuring the SRB servers</P>
<A NAME="Quick server setup"></A>
<P>5.2.1 Quick server setup</P>
</B><P>This section provides short notes on quick setup and startup of the SRB server. For more detail descriptions of setup, please read section <B><A HREF="#Detailed server setup">5.2.2</A></B></P>
<P>A) Setup for servers with UNIX driver only:</P>
<DIR>
<DIR>
<P>&#9;1) Configure the SRB user environment with the  ~/.srb/.MdasEnv and ~/.srb/.MdasAuth files. Templates of these files can be found in the utilities/envFiles directory.</P>
<P>&#9;2) Configure the data/mcatHost file. If you are going to use SDSC MCAT, no change is needed.</P>
<P>&#9;3) To run the SRB server, type in:</P>
<DIR>
<P>&#9;cd bin</P>
<P>&#9;runsrb</P>
</DIR>
<P>&#9;This should start the SRB server. If it is not running,the data/srbLog file should give hints on why it is not running.</P>
<P>&#9;4) Check the data/srbLog file - The first line should contain something like: </P>
<P>&#9;LocalHostName:  ghidorah, localhost, .....</P>
<P>&#9;followed by:</P>
<P>&#9;Local storage vault conf:</P>
<P>&#9;storSysType: 0, vaultPath: /projects/mdas/srb/SRBVaultTest</P>
<DIR>
<P>&#9;.</P>
<P>&#9;.</P>
</DIR>
<P>&#9;The LocalHostName list shows all the addresses of your local host recognized by the SRB server. It uses the gethostbyname() call to get the local addresses. There are situations where the local host address registered with MCAT may not show up with this call. Then, the "Local storage vault conf" will be empty.  In this case, use the data/hostConfig file to include the MCAT registered host address to your local addresses. </P>
</DIR>
</DIR>
<P>&#9;B) Setup for servers with HPSS driver:</P>
<DIR>
<DIR>
<P>&#9;1) Build the SRB server with the HPSS flag set in the mk/mk.config file. In addition, the HPSS driver can use either the normally used DCE authentication or the NON-DCE implementation developed by Mike Gleicher. Please contact Mike at mkg@san.rr.com for informations regarding the licensing of the Non-DCE HPSS client/server software.  If the NON-DCE authentication is used, the NO_DCE flag in mk/mk.config should be set before the build. If it is not set, DCE authentication is assumed. </P>

<P>&#9;2) Go through same procedures as A).</P>
<P>&#9;3) Configure the data/hpssCosConfig file.</P>
<P>&#9;4a) For NON-DCE authentication, configure the data/hpssNodceAuth file as described in the comment fields in the file. Basically, this file should contain the HPSS userID/password pair of the SRB user (the userID under which the SRB server runs).
<P>&#9;NOTE: The NON-DCE authentication works only with the Non-DCE HPSS client/server implemented by Mike Gleicher.
<P>&#9;4b) For DCE authentication, create a DCE keytab file and change the srbKeytabName parameter in bin/runsrb to point to this file path and the srbPrincipalName to the UserId associated with this keytab file.</P>
</DIR>
</DIR>
<P>&#9;C) Setup for servers with DB large object drivers:</P>
<DIR>
<DIR>
<P>&#9;1) Go through same procedures as A).</P>
<P>&#9;2) Configure the data/LobjConfig file.</P>
</DIR>
</DIR>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Detailed server setup"></A>
<B><P>5.2.2 Detailed server setup</P>
</B><P>1) Setting up the SRB user environment - Before a user can start the SRB server, the procedures for setting up user environment given in section <B><A HREF="#Building and installing the SRB client library">3.1</A> </B>must be carried out. For GSI authentication, please read the section on " Steps to set up SRB Server certificates" in <A HREF="README.gsi.htm">README.gsi</A>.</P>
<P>2) Setting up the SRB configuration files - Modifications to the following configuration files are needed for each SRB server installation:</P><DIR>
<DIR>

<P>data/mcatHost - This file identifies the host on which the MCAT enabled server and the authentication scheme to use to connect to this server.</P>
<P>data/hostAuthConfig - The optional host based authorization configuration file. This file specifies who and from which IP address/domain the client connection may come from. The parameters are self-explanatory through the comments given in this file. It is needed only if HOST_BASED_AUTH is enabled in mk/mk.config</P>
<P>data/hostConfig - This is the optional SRB host configuration file. It is only needed when when you want to add aliases to your local hostName.</P>
<P>data/MdasConfig - The MDAS configuration file. Only the MDAS_ENABLED SRB server requires this file. The current MCAT catalog is kept in a Oracle database. This file contains basic informations required for SRB to interface with the MCAT catalog. Configurable parameters include SRB's Oracle userid, password and log file location. </P>
<P>data/LobjConfig - The configuration file for the DBMS Large Object drivers. Basically, it contains the userID and password required for authenticating the SRB server with DBMS where the large objects are stored. The parameters defined in this file are Db2User, Db2Passwd for DB2), IllusUser, IllusPasswd (for Illustra), OracleUser and OraclePasswd (for Oracle). Input to some of these parameters can be blank if the SRB server being started does not support a particular DBMS. </P>
<P>data/hpssCosConfig - This file configures the HPSS Class Of Service (COS). Basically, this file contains a table with two columns - "COS ID" and "Maximum file size in KBytes". It is used by the HPSS driver for choosing the appropriate COS based on the "dataSize" input parameter of the srbObjCreate() call.</P>
<P>bin/runsrb - This is the startup script for the SRB server. Modifications of some env variables defined in this file may be required. The parameters are self-explanatory through the comments given in this file.</P>
<P>data/hpssNodceAuth - This file specifies the userID/passwd pair for authenticating the SRB server with the NON-DCE HPSS system.  This file is needed only when the NO_DCE in the mk.config file is set. Otherwise, for DCE HPSS authentication, create a DCE keytab file and change the srbKeytabName parameter in bin/runsrb to point to this file path. </P>

<P>&nbsp;</P>
<P>&nbsp;</P></DIR>
</DIR>

<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Starting the SRB server"></A>
<B><P>5.3 Starting the SRB server</P>
</B><P>The servers in the SRB environment must be started in the following order:</P>
<P>&#9;1) The MCAT DBMS server.</P>
<P>&#9;2) The MDAS_ENABLED SRB server.</P>
<P>&#9;3) The rest of the SRB servers.</P>
<P>The script bin/runsrb is used to start the SRB server. To start the SRB server, type in:</P>
<P>&#9;. cd bin</P>
<P>&#9;. runsrb</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Running the test suite"></A>
<B><P>5.4 Running the test suite</B> </P>
<P>After installing the SRB server for the first time, the test suite given in the test/testsuite directory should be run. To run the test suite, modify inputs such as AUTH, DOMAIN, HOST and PORT as required in the "testsuite" script file in the test/testsuite directory and type in the following:</P>
<P>&#9;. cd test/testsuite</P>
<P>&#9;. gmake clean</P>
<P>&#9;. gmake</P>
<P>&#9;. testsuite</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Building and Running the srbBrowser"></A>
<B><P>6.0 Building and Running the JAVA based srbBrowser</B> </P>
<P>This section describes the steps for Building and Running the JAVA based srbBrowser. The srbBrowser is a JAVA based SRB client GUI. It can be used to perform a variety of client level operations including replication, copy and paste, registration of datasets and metadata manipulation and query, etc.</P>
<A NAME="Building the srbBrowser"></A>
<B><P>6.1 Building the JAVA based srbBrowser</B> </P>
<P>Section <A HREF="#Building and installing the SRB client library"> <B>3.1</B></A> gives a brief description of building the srbBrowser software as part of the client library build. The following gives a more detailed descriptions of the build:</P>
<P>1) The SRB client library (e.g., gmake srb) and utilities (e.g., gmake util) must be built before building the srbBrowser.</P>
<P>2) setenv CLASSPATH to the path where the swing.jar is installed on your
machine and ".". e.g.,</P>
<P>setenv CLASSPATH /local/generic/lib/java/swing/swing.jar:.</P>
<P>3) Edit the data/mk.config file and define the "JAVA_GUI" parameter and set the "javaDir" parameter to the directory where your JDK is installed.</P>
<P>4) "cd" to the main SRB directory and type in "gmake clean_browser" and then "gmake browser" or, "cd java" and type in "gmake clean" and then "gmake".  </P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Running the srbBrowser"></A>
<B><P>6.2 Running the JAVA based srbBrowser</B> </P>
<P>To run the srbBrowser, setenv DISPLAY to your workstation, "cd java/bin" and type in "srbBrowser".  </P>
<P>The following lists the SRB operations that can be carried out using the srbBrowser GUI:</P>
<P>1) The "Default" pull down menu allow a client to select the default storage resource and set the default comment. The default resource will be used for all subsequent dataset creation until it is changed. The default comment can be used for creating new comments for datasets.</P>
<P>2) The "Operations" menu shows the type of operations that can be performed depending what was selected. The following operations have been implemented: </P>
<DIR>
<P>"New" - make a new  "Collection"</P>
<P>"Replicate" - Replicate a dataset or collection (recursively).  Two choices are allowed: replicate to the default storage resource or choose a resource for replication.</P>
<P>"Copy" a dataset or collection - The following steps should be taken:</P>
<DIR>
<P>1) Select a dataset or a collection to be copied (source).</P>
<P>2) Select the "Copy" menu from the "Operation" pulldown menu.</P>
<P>3) Select the destination dataset or collection.  </P>
<P>4) Select the "Paste" menu from the "Operation" pulldown menu.</P>
</DIR>
<P>"Delete" - Delete a dataset or a collection recursively.</P>
<P>"Import" - Import a file or directory from a local file system. The following steps should be taken: </P>
<DIR>
<P>1) Select the destination dataset or collection.</P>
<P>2) Select the "Import from Local FS" menu from the "Operation" pulldown menu.</P>
<P>3) A file chooser dialog box should appear. Browse through the local FS and selection a file or a directory to be imported from (source). Click on the "Open" button of the file chooser dialog box.</P>
</DIR>
<P>"Export" - Export a dataset or collection to a local file system. The following steps should be taken:
</P>
<DIR>
<P>1) Select the source dataset or collection to be exported.</P>
<P>2) Select the "Export to Local FS" menu from the "Operation" pulldown menu.</P>
<P>3) A file chooser dialog box should appear. Browse through the local FS and selection a file or a directory to export to (destination). Click on the "Open" button of the file chooser dialog box.</P>
</DIR>
<P>"Register" and "Unregister" - Register and Unregister local files and directory. These functions may be recursive. Comparing to the "Import" and "Export" functions, registering a local file does not involve the the copying of the file physically. Rather, the file is registered with MCAT and hence becomes visible to the SRB world. For "Register" to work, your local file must be accessible by one of the SRB server in the federation. The following three steps must be taken to register a local file:</P>
<DIR>
<P>1) Set the default resource (through the "Default" menu) to the resource controlled by the SRB server that can access your local file.</P>
<P>2) Select a collection where you want this registered dataset or collection to reside.</P>
<P>3) Select the "Register Local FS" menu item from the "Operation" pull down menu and then selection the local file or directory you wish to register.</P>
</DIR>
<P>"Rename" - Rename a dataset.</P>
<P>"Display" - Display allows graphical (jpeg, gif, etc) and text (C, html, etc) files to be displayed in the srbBrowser window. This can also be achieved by double clicking the file displayed in the metadata window.  </P>
</DIR>
<P>3) The "Metadata" menu allows the manipulation and querying of system level metadata. Manipulation of two attributes - "Access Control" and "Comments" has been implemented thus far.</P>
<DIR>
<P>The "Set Access Cntl" menu can be used to grant access permission of a dataset or a collection to individual users or group of users. Recursive operation is allowed for setting the access permission of a collection.  </P>
<P>The "List Access Cntl" menu can be used to list the access permission of datasets and collections.</P>
<P>The "New Comment" menu can be used to attach a new "comment" to a dataset. A new comment can be created completely new or by adding to the default comment.  </P>
<P>The "Modify Comment" menu can be used to modify an existing comment. Modification can be done by replacing the entire comment or appending to the current comment. The menu also allows the deletion of a comment.  </P>
<P>The "Query Comment" menu can be used to query datasets based on the content of these comments. If a collection is selected for querying, the query will be done for all descendants of the collection. If a dataset is selected for querying, the content the comment for this dataset will be listed.  </P>
</DIR>
<P>4) The "View" menu has only one sub-menu - "Refresh". The srbBrowser always try to update the tree structure and the metadata displayed in the window whenever changes were made by the srbBrowser. The "Refresh" function allowed the display to be refreshed after changes were made external to the srbBrowser.</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<A NAME="Building and Running the srbMon"></A>
<B><P>7.0 Building and Running srbMon - a SRB server monitoring program</B> </P>
<P>This section describes the steps for Building and Running the srbMon daemon. The srbMon daemon is a SRB monitoring daemon which remotely monitors and logs all SRB servers belonging to a federation, and attempts to restart any servers that were found to be down..</P>
<P>To build srbMon, "cd admin" and type in "gmake clean" and then "gmake".  </P>
<P>To run srbMon, the following steps should be carried out:</P>
<P>1) srbMon should be run on a host which does not belong to the SRB federation to be monitored. </P>
<P>2) Configure the admin/data/srbHostFile file. This file should contain all the hosts in the federation to be monitored. </P>
<P>3) srbMon uses "rsh" to start any SRB servers that were found to be down.  Therefore, SRB admin must make sure that remote shell type permissions are properly setup (i.e., .rhosts and /etc/hosts.equiv files, etc) on each host being monitored.  </P>
<P>4) To run the daemon, "cd admin/bin" and type in "srbMon1_1_2". This daemon will sleep most of the time, waking up every 10 minutes to monitor the SRB servers.  </P>
<P>5) The srbMon daemon generates a log file - admin/data/monLog, logging the status of each server and action performed.</P>

<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="Appendix A"></A>
<B><P>Appendix A – Descriptions of the SRB Client API</P>
<B><P>1) Client/Server connection API:<P></B>
<DIR>
<A HREF="#srbConnect">srbConnect</A><BR>
<A HREF="#clConnect">clConnect</A><BR>
<A HREF="#tiUserConnect">tiUserConnect</A><BR>
<A HREF="#clFinish">clFinish</A><BR>
<A HREF="#clErrorMessage">clErrorMessage</A><BR>
</DIR>
<B><P>2) High-level API:</P></B>
<DIR>
<A HREF="#srbObjOpen">srbObjOpen</A><BR>
<A HREF="#srbObjOpenWithTicket">srbObjOpenWithTicket</A><BR>
<A HREF="#srbObjCreate">srbObjCreate</A><BR>
<A HREF="#srbObjClose">srbObjClose</A><BR>
<A HREF="#srbObjUnlink">srbObjUnlink</A><BR>
<A HREF="#srbObjRead">srbObjRead</A><BR>
<A HREF="#srbObjSeek">srbObjSeek</A><BR>
<A HREF="#srbObjSync">srbObjSync</A><BR>
<A HREF="#srbObjStat">srbObjStat</A><BR>
<A HREF="#srbObjStat64">srbObjStat64</A><BR>
<A HREF="#srbObjGetdents">srbObjGetdents</A><BR>
<A HREF="#srbObjGetdents64">srbObjGetdents64</A><BR>
<A HREF="#srbObjProxyOpr">srbObjProxyOpr</A><BR>
<A HREF="#srbExecCommand">srbExecCommand</A><BR>
<A HREF="#srbObjReplicate">srbObjReplicate</A><BR>
<A HREF="#srbObjMove">srbObjMove</A><BR>
<A HREF="#srbObjWrite">srbObjWrite</A><BR>
<A HREF="#srbCreateCollect">srbCreateCollect</A><BR>
<A HREF="#srbListCollect">srbListCollect</A><BR>
<A HREF="#srbModifyCollect">srbModifyCollect</A><BR>
<A HREF="#srbIssueTicket">srbIssueTicket</A><BR>
<A HREF="#srbRemoveTicket">srbRemoveTicket</A><BR>
<A HREF="#srbContainerCreate">srbContainerCreate</A><BR>
<A HREF="#srbRmContainer">srbRmContainer</A><BR>
<A HREF="#srbSyncContainer">srbSyncContainer</A><BR>
<A HREF="#srbReplContainer">srbReplContainer</A><BR>
<A HREF="#srbObjGet">srbObjGet</A><BR>
<A HREF="#srbObjPut">srbObjPut</A><BR>
<A HREF="#srbSyncData">srbSyncData</A><BR>
</DIR>
<B><P>3) Low-level File-type API:</B></P>
<DIR>
<A HREF="#srbFileOpen">srbFileOpen</A><BR>
<A HREF="#srbFileCreate">srbFileCreate</A><BR>
<A HREF="#srbFileUnlink">srbFileUnlink</A><BR>
<A HREF="#srbFileClose">srbFileClose</A><BR>
<A HREF="#srbFileRead">srbFileRead</A><BR>
<A HREF="#srbFileWrite">srbFileWrite</A><BR>
<A HREF="#srbFileSeek">srbFileSeek</A><BR>
<A HREF="#srbFileSync">srbFileSync</A><BR>
<A HREF="#srbFileStat">srbFileStat</A><BR>
<A HREF="#srbFileFstat">srbFileFstat</A><BR>
<A HREF="#srbFileMkdir">srbFileMkdir</A><BR>
<A HREF="#srbFileChmod">srbFileChmod</A><BR>
<A HREF="#srbFileRmdir">srbFileRmdir</A><BR>
<A HREF="#srbSetStorAttri">srbSetStorAttri</A><BR>
<A HREF="#srbOpendir">srbOpendir</A><BR>
<A HREF="#srbClosedir">srbClosedir</A><BR>
<A HREF="#srbReaddir">srbReaddir</A><BR>
</DIR>
<B><P>4) Low-level DB-type API:</B></P>
<DIR>
<A HREF="#srbDbLobjOpen">srbDbLobjOpen</A><BR>
<A HREF="#srbDbLobjCreate">srbDbLobjCreate</A><BR>
<A HREF="#srbDbLobjClose">srbDbLobjClose</A><BR>
<A HREF="#srbDbLobjRead">srbDbLobjRead</A><BR>
<A HREF="#srbDbLobjWrite">srbDbLobjWrite</A><BR>
<A HREF="#srbDbLobjSeek">srbDbLobjSeek</A><BR>
<A HREF="#srbDbLobjUnlink">srbDbLobjUnlink</A><BR>
</DIR>
<B><P>5) Low-level DB Table API:</B></P>
<DIR>
<A HREF="#srbDbTableOpen">srbDbTableOpen</A><BR>
<A HREF="#srbDbTableCreate">srbDbTableCreate</A><BR>
<A HREF="#srbDbTableClose">srbDbTableClose</A><BR>
<A HREF="#srbDbTableRead">srbDbTableRead</A><BR>
<A HREF="#srbDbTableWrite">srbDbTableWrite</A><BR>
<A HREF="#srbDbTableSeek">srbDbTableSeek</A><BR>
<A HREF="#srbDbTableUnlink">srbDbTableUnlink</A><BR>
</DIR>
<B><P>6) MCAT related API:</B></P>
<DIR>
<A HREF="#srbGetDatasetInfo">srbGetDatasetInfo</A><BR>
<A HREF="#srbGetDataDirInfo">srbGetDataDirInfo</A><BR>
<A HREF="#srbRegisterDataset">srbRegisterDataset</A><BR>
<A HREF="#srbUnregisterDataset">srbUnregisterDataset</A><BR>
<A HREF="#srbSetAuditTrail">srbSetAuditTrail</A><BR>
<A HREF="#srbModifyDataset">srbModifyDataset</A><BR>
<A HREF="#srbChkMdasAuth">srbChkMdasAuth</A><BR>
<A HREF="#srbChkMdasSysAuth">srbChkMdasSysAuth</A><BR>
<A HREF="#srbRegisterUserGrp">srbRegisterUserGrp</A><BR>
<A HREF="#srbRegisterUser">srbRegisterUser</A><BR>
<A HREF="#srbModifyUser">srbModifyUser</A><BR>
<A HREF="#srbGetPrivUsers">srbGetPrivUsers</A><BR>
<A HREF="#srbGetMoreRows">srbGetMoreRows</A><BR>
<A HREF="#freeSqlResult">freeSqlResult</A><BR>
<A HREF="#clearSqlResult">clearSqlResult</A><BR>
<A HREF="#printSqlResult">printSqlResult</A><BR>
<A HREF="#srbGetContainerInfo">srbGetContainerInfo</A><BR>
<A HREF="#srbRegisterLocation">srbRegisterLocation</A><BR>
<A HREF="#srbIngestToken">srbIngestToken</A><BR>
<A HREF="#srbRegisterResource">srbRegisterResource</A><BR>
<A HREF="#srbRegisterLogicalResource">srbRegisterLogicalResource</A><BR>
<A HREF="#srbRegisterReplicateResourceInfo">srbRegisterReplicateResourceInfo</A><BR>
<A HREF="#srbDeleteValue">srbDeleteValue</A><BR>
<A HREF="#srbSetupSessionPublicKey">srbSetupSessionPublicKey</A><BR>
<A HREF="#srbSetupSession">srbSetupSession</A><BR>

</DIR>
<B><P>6) Miscellaneous SRB API.</B></P>
<DIR>
<A HREF="#srb_perror">srb_perror</A><BR>
<A HREF="#srbVaultInfo">srbVaultInfo</A><BR>
<A HREF="#srbFreeVaultInfo">srbFreeVaultInfo</A><BR>
<A HREF="#srbPrintVaultInfo">srbPrintVaultInfo</A><BR>
<A HREF="#srbHostConfig">srbHostConfig</A><BR>
<A HREF="#srbPrintHostInfo">srbPrintHostInfo</A><BR>
<A HREF="#srbFreeHostInfo">srbFreeHostInfo</A><BR>
</DIR>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<P>&nbsp;</P>
<A NAME="Appendix B"></A>
<B><P>Appendix B - Descriptions of the dataCutter Client API</P>
<DIR>
<A HREF="#sfoCreateIndex">sfoCreateIndex</A><BR>
<A HREF="#sfoDeleteIndex">sfoDeleteIndex</A><BR>
<A HREF="#sfoSearchIndex">sfoSearchIndex</A><BR>
<A HREF="#sfoGetMoreSearchResult">sfoGetMoreSearchResult</A><BR>
<A HREF="#sfoApplyFilter">sfoApplyFilter</A><BR>
<A HREF="#sfoGetMoreFilterResult">sfoGetMoreFilterResult</A><BR>
<A HREF="#sfoFreeIndexResults">sfoFreeIndexResults</A><BR>
<A HREF="#sfoFreeFilterResults">sfoFreeFilterResults</A><BR>
<A HREF="#sfoFreeSegmentInfo">sfoFreeSegmentInfo</A><BR>
</DIR>
<P>&nbsp;</P>
<P><A HREF="#Beginning"><IMG SRC="top.gif" WIDTH="22" HEIGHT="22"></A>
<P>&nbsp;</P>
<P>&nbsp;</P></B>
<A NAME="srbConnect"></A>
<P>NAME</P>
<P>srbConnect</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>srbConn* srbConnect(char *srbHost, char* srbPort, char* srbAuth, char *userName, char *domainName, char *authScheme,  char *serverDn);</P>
<B><P>DESCRIPTION</P>
</B><P>Establish a connection to a srbServer through the srbMaster at the specified host and port. This API replaces the clConnect () API.</P>
<DL>
<DT>SrbHost
<DD>The host address of srbMaster. If the input value in NULL, it will use the env variable "srbHost" if it is defined. If it is not defined, the ~/.srb/.MdasEnv file will be checked next. If not, it will use the hostname of the client machine.<P>
<DT>SrbPort
<DD>The port number of srbMaster. If the input value in NULL, it will use the env variable "srbPort" if it is defined. Otherwise, the value defined in the ~/.srb/.MdasEnv file will be used. <P>
<DT>SrbAuth
<DD>The auth string. It is used to define the password for MDAS or SEA authentication. For SEA authentication, this is the password used by the SEA library to decrypt the encrypted private key stored in the file ~/.SEAuuuuu@ddddd (where uuuuu is the user ID and ddddd is the user domain name). This input is not needed if an unencrypted private key is available in the /tmp directory (generated using the 'seaauth auto' command). To provide additional flexibility, a client may also use the env variable "srbAuth" to specify the password. A client may also supply the password in the ~.srb/.MdasAuth file. If a client uses more than one method to specify the password, the value given in this function call will take precedent, then the env variable "srbAuth", and lastly, the ~.srb/.MdasAuth file.
</DL>
<DT>UserName
<DD>The user ID of the user. If the input value in NULL, it will use the env variable "srbUser" if it is defined. Otherwise, the vaule defined in the ~/.srb/.MdasEnv file will be used.<P>
<DT>DomainName
<DD>The domain of the user. If the input value in NULL, it will use the env variable "mdasDomainHome" if it is defined. Otherwise, the vaule defined in the ~/.srb/.MdasEnv file will be used.<P>
<DT>AuthScheme
<DD>The scheme to use for authentication. If the input value in NULL, the vaule defined in the ~/.srb/.MdasEnv file will be used. Valid values are 'PASSWD_AUTH', 'ENCRYPT1', 'SEA_AUTH', 'SEA_ENCRYPT', 'GSI_AUTH' and 'GSI_SECURE_COMM'<P>
<DT>ServerDn
<DD>The distinguish name of the server user. This input is valid only for GSI authentication.</P> 
<B><P>RETURN VALUES</P>
</B><P>Returns a srbConn* which is needed for all subsequent client calls. Error if the status field of the connection returned is CONNECTION_BAD.</P>
<B><P>ERRORS</P>
</B><P>CONNECTION_BAD in the status field of srbConn.</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#clConnect">clConnect</A>, <A HREF="#tiUserConnect">tiUserConnect</A>, <A HREF="#clFinish">clFinish</A> and <A HREF="#clErrorMessage">clErrorMessage</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><P>&#9;</P>
<A NAME="clConnect"></A>
<P>NAME</P>
<P>clConnect</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>srbConn* clConnect(char* srbHost, char* srbPort, char* srbAuth);</P>
<B><P>DESCRIPTION</P>
</B><P>Establish a connection to a srbServer through the srbMaster at the specified host and port. This API is being replaced by the srbConnect () call.</P>
<DL>
<DT>SrbHost
<DD>The host address of srbMaster. If the input value in NULL, it will use the env variable "srbHost" if it is defined. If it is not defined, the ~/.srb/.MdasEnv file will be checked next. If not, it will use the hostname of the client machine.<P>
<DT>SrbPort
<DD>The port number of srbMaster. If the input value in NULL, it will use the env variable "srbPort" if it is defined. If not, it defaults to the default port 5558).<P>
<DT>SrbAuth
<DD>The auth string. It is used to define the password for MDAS or SEA authentication. For SEA authentication, this is the password used by the SEA library to decrypt the encrypted private key stored in the file ~/.SEAuuuuu@ddddd (where uuuuu is the user ID and ddddd is the user domain name). This input is not needed if an unencrypted private key is available in the /tmp directory (generated using the 'seaauth auto' command). To provide additional flexibility, a client may also use the env variable "srbAuth" to specify the password. A client may also supply the password in the ~.srb/.MdasAuth file. If a client uses more than one method to specify the password, the value given in this function call will take precedent, then the env variable "srbAuth", and lastly, the ~.srb/.MdasAuth file.
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns a srbConn* which is needed for all subsequent client calls. Error if the status field of the connection returned is CONNECTION_BAD.</P>
<B><P>ERRORS</P>
</B><P>CONNECTION_BAD in the status field of srbConn.</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbConnect">srbConnect</A>, <A HREF="#tiUserConnect">tiUserConnect</A>, <A HREF="#clFinish">clFinish</A> and <A HREF="#clErrorMessage">clErrorMessage</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><P>&#9;</P>
<A NAME="tiUserConnect"></A>
<P>NAME</P>
<P>&#9;tiUserConnect</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>srbConn* tiUserConnect(char *srbHost, char* srbPort);</P>
<B><P>DESCRIPTION</P>
</B><P>Establish a connection to a srbServer through the srbMaster at the specified host and port by a TICKET USER. Normal authentication will be bypassed for a TICKET USER.</P>
<DL>
<DT>SrbHost
<DD>The host address of srbMaster. If the input value in NULL, it will use the env variable "srbHost" if it is defined. If it is not defined, the ~/.srb/.MdasEnv file will be checked next. If not, it will use the hostname of the client machine.<P>
<DT>SrbPort
<DD>The port number of srbMaster. If the input value in NULL, it will use the env variable "srbPort" if it is defined. If not, it defaults to the default port 5558.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns a srbConn* which is needed for all subsequent client calls. Error if the status field of the connection returned is CONNECTION_BAD.</P>
<B><P>ERRORS</P>
</B><P>CONNECTION_BAD in the status field of srbConn.</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbConnect">srbConnect</A>, <A HREF="#clFinish">clFinish</A> and <A HREF="#clErrorMessage">clErrorMessage</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><P>&#9;</P>
<A NAME="clFinish"></A>
<P>NAME</P>
<P>&#9;clFinish</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>void clFinish (srbConn* conn);</P>
<P>&#9;</P>
<B><P>DESCRIPTION</P>
</B><P>Close the current connection and free the srbConn data structure.</P>
<DL>
<DT>Conn
<DD>The connect to close.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;None.</P>
<B><P>ERRORS</P>
</B><P>&#9;None.</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbConnect">srbConnect</A>, <A HREF="#tiUserConnect">tiUserConnect</A> and <A HREF="#clErrorMessage">clErrorMessage</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="clErrorMessage"></A>
<B><P>NAME</P>
<P>&#9;clErrorMessage</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>char* clErrorMessage(srbConn* conn);</P>
<B><P>DESCRIPTION</P>
</B><P>Return the ErrorMessage of a connection. This is the error message from the current client call returned by the SRB server. On encountering error on most client calls, in addition to returning an error code (usually a negative value), a text string describing the error is returned to the caller. The caller must use the clErrorMessage() call to retrieve the error message. </P>
<DL>
<DT>Conn
<DD>From the clConnect() call.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the pointer to the error message string. Returns a NULL if there is no error message.</P>
<B><P>ERRORS</P>
<P>SEE ALSO</P>
</B><P><A HREF="#srbConnect">srbConnect</A>, <A HREF="#tiUserConnect">tiUserConnect</A> and <A HREF="#clFinish">clFinish</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjOpen"></A>
<B><P>NAME</P>
<P>&#9;srbObjOpen</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjOpen(srbConn* conn, char *objID, int oflag, char *collectionName);</P>
<B><P>DESCRIPTION</P>
</B><P>Open a SRB data object for I/O operation.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>ObjID
<DD>The SRB object ID to open. The objID to be opened must have already been registered with MCAT (through srbObjCreate call or by explicit registration). One or more conditions can be appended to the objID. Each condition must be preceded by the '&amp;' character. Currently, only one condition is supported. i.e., COPY=n (where n = replica number beginning with 0). e.g. foo&amp;COPY=1 specifies opening replica number 1 of data object "foo".<P>
<DT>oflag
<DD>Unix type open flag. O_CREAT is not supported.<P>
<DT>collectionName
<DD>The name of the collection this objID belongs.<P>
</DL>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the object descriptor. Returns a negative value upon failure.</P>
<B><P>ERRORS</P>
<P>SEE ALSO</P>
</B><P><A HREF="#srbObjOpenWithTicket">srbObjOpenWithTicket</A> and <A HREF="#srbObjClose">srbObjClose</A>. </P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjOpenWithTicket"></A>
<B><P>NAME</P>
<P>&#9;srbObjOpenWithTicket</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjOpenWithTicket (srbConn* conn, char *objID, int oflag, </P>
<P>char *collectionName, char *ticket);</P>
<B><P>DESCRIPTION</P>
</B><P>Open a SRB data object using a ticket.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>ObjID
<DD>The SRB object ID to open. The objID to be opened must have already been registered with MCAT (through srbObjCreate call or by explicit registration). One or more conditions can be appended to the objID. Each condition must be preceded by the '&amp;' character. Currently, only one condition is supported. i.e., COPY=n (where n = replica number beginning with 0). e.g. foo&amp;COPY=1 specifies opening replica number 1 of data object "foo".<P>
<DT>Oflag
<DD>Unix type open flag. O_CREAT is not supported.<P>
<DT>collectionName 
<DD>The name of the collection this objIDbelongs.<P>
<DT>Ticket
<DD>The ticket for the object.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the object descriptor. Returns a negative value upon failure.</P>
<B><P>ERRORS</P>
<P>SEE ALSO</P>
</B><P><A HREF="#srbObjOpen">srbObjOpen</A> and <A HREF="#srbObjClose">srbObjClose</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjCreate"></A>
<B><P>NAME</P>
<P>&#9;srbObjCreate</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjCreate(srbConn* conn, int catType, char *objID,</P>
<P>char *dataTypeName, char *resourceName, char *collectionName, </P><DIR>
<DIR>

<P>char *pathName, int dataSize);</P></DIR>
</DIR>

<B><P>DESCRIPTION</P>
</B><P>Create a SRB data object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG.<P>
<DT>ObjID
<DD>The SRB object ID to create. The objID is a user-defined name to be registered with MCAT. This ID will be used for subsequent reference of the data object. One or more conditions can be appended to the objID. Each condition must be preceded by the '&amp;' character. Currently, two conditions are supported:<P> 
<DD>1) COPIES=MMM where MMM may be:</P>
<DD>a) an integer n which means n replica should be created. The "resourceName" input is the logical resource in which this object is to be stored. This logical resource must consist of at least n physical resources. e.g. foo&COPIES=2 specifies the creation of two replica of data object "foo".</P>
<DD>b) the keyword RR which means a single copy should be created in one of the physical resources belonging to the input logical resource ("resourceName") chosen in a Round-Robin fashion. e.g. foo&COPIES=RR.</P>
<DD>c) the keyword RANDOM produces similar effect as the RR keyword. The only difference is the selection algorithm is random rather than Round-Robin. e.g. foo&COPIES=RANDOM.</P>
<P>&nbsp;</P>
<DD>2) CONTAINER=containerName. This keyword specifies the object is to be placed in the given container. The container must have already been created using the srbContainerCreate() call.
<P>&nbsp;</P>
<DT>dataTypeName 
<DD>Data type. e.g. "generic"<P>
<DT>resourceName 
<DD>The storage resource name. This may be the name of a single resource or a resource group (or logical resource) consisting of two or more physical resources. e.g. "mda18-unix-sdsc"<P>
<DT>collectionName
<DD>The collection name.<P>
<DT>PathName
<DD>The file/DB path of the data. If the input is NULL, the SRB server will generate one.<P>
<DT>dataSize
<DD>The size of the data set if known. 0 = unknown.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the object descriptor. Returns a negative value upon failure.</P>
<B><P>ERRORS</P>
</B><P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjUnlink">srbObjUnlink</A>, <A HREF="#srbContainerCreate">srbContainerCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjClose"></A>
<B><P>NAME</P>
<P>&#9;srbObjClose</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjClose (srbConn* conn, int desc);</P>
<B><P>DESCRIPTION</P>
</B><P>Close an opened data object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Desc
<DD>The object descriptor (from the srbObjOpen call) to close.<P>
</DL>
<P>&nbsp;</P>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</P>
<P>SEE ALSO</P>
</B><P><A HREF="#srbObjOpen">srbObjOpen</A> and <A HREF="#srbObjOpenWithTicket">srbObjOpenWithTicket</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjUnlink"></A>
<B><P>NAME</P>
<P>&#9;srbObjUnlink</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjUnlink (srbConn* conn, char *objID, char *collectionName);</P>
<B><P>DESCRIPTION</P>
</B><P>Delete a SRB data object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>ObjID
<DD>The SRB object ID to unlink. <P>
<DT>collectionName
<DD>The name of the collection this objID belongs.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</P>
<P>SEE ALSO</P>
</B><P><A HREF="#srbObjCreate">srbObjCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjRead"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbObjRead</P>
<P>SYNOPSIS</P>
</B><P>&#9;#include "srbClient.h"</P>
<P>int srbObjRead(srbConn *conn, int desc, char *buf, int len);</P>
<B><P>DESCRIPTION</P>
</B><P>Read len bytes of the SRB data object into buf. The caller must have allocated enough space to hold the data read.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Desc
<DD>The object descriptor (from a srbObjOpen call) to read.<P>
<DT>Buf
<DD>The input buffer.<P>
<DT>Len
<DD>The number of bytes to read.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the length of bytes read. Returns a negative value upon failure. </P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
<P>&#9;</B><A HREF="#srbObjOpen">srbObjOpen</A>and <A HREF="#srbObjWrite">srbObjWrite</A></P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjSeek"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbObjSeek</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjSeek(srbConn *conn, int desc, int offset, int whence);</P>
<B><P>DESCRIPTION</P>
</B><P>Change the current read or write location on an opened SRB data object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Desc
<DD>The object descriptor (from the srbObjOpen call) to seek.<P>
<DT>Offset
<DD>The position of the next operation.<P>
<DT>Whence
<DD>Same definition as in Unix.
<P>SEEK_SET - pointer is set to the value of the Offset parameter.
<P>SEEK_CUR - pointer is set to its current location plus the value of the Offset parameter.
<P>SEEK_END - pointer is set to the size of the file plus the value of the Offset parameter.
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><P>SEE ALSO</B> </P>
<P><A HREF="#srbObjOpen">srbObjOpen</A>, <A HREF="#srbObjWrite">srbObjWrite</A> and <A HREF="#srbObjRead">srbObjRead</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjSync"></A>
<B><P>NAME</P>
<P>srbObjSync</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjSync(srbConn* conn, int desc);</P>
<B><P>DESCRIPTION</P>
</B><P>Sync a SRB object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Desc
<DD>The SRB object descriptor to sync (from srbObjOpen or srbObjCreate).<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjOpen">srbObjOpen</A>, <A HREF="#srbObjCreate">srbObjCreate</A>, <A HREF="#srbObjUnlink">srbObjUnlink</A>, <A HREF="#srbObjClose">srbObjClose</A>, <A HREF="#srbObjRead">srbObjRead</A> and <A HREF="#srbObjWrite">srbObjWrite</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjStat"></A>
<B><P>NAME</P>
<P>srbObjStat</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjStat(srbConn* conn, int catType, </P>
<P>char *path, struct stat *statbuf);</P>
<B><P>DESCRIPTION</P>
</B><P>Get the status of an SRB object. The result is placed in statbuf.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG. <P>
<DT>path
<DD>The full Path name of the SRB object to stat. The path must be an absolute path.<P>
<DT>Statbuf
<DD>Pointer to a user-supplied local FS stat struct where the stat result will be put.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Stat result in statbuf.</P>
<P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjStat64">srbObjStat64</A>, <A HREF="#srbObjOpen">srbObjOpen</A> and <A HREF="#srbObjCreate">srbObjCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjStat64"></A>
<B><P>NAME</P>
<P>srbObjStat64</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjStat64 (srbConn* conn, int catType, </P>
<P>char *path, struct stat64 *statbuf);</P>
<B><P>DESCRIPTION</P>
</B><P>Get the status of an SRB object. The result is placed in statbuf.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG. <P>
<DT>path
<DD>The full Path name of the SRB object to stat. The path must be an absolute path.<P>
<DT>Statbuf
<DD>Pointer to a user-supplied local FS stat struct where the stat result will be put.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Stat result in statbuf.</P>
<P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjStat">srbObjStat</A>, <A HREF="#srbObjOpen">srbObjOpen</A> and <A HREF="#srbObjCreate">srbObjCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjGetdents"></A>
<B><P>NAME</P>
<P>srbObjGetdents</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjGetdents(srbConn* conn, int catType, </P>
<P>int fd, dirent_t *buf, size_t nbyte);</P>
<B><P>DESCRIPTION</P>
</B><P>The SRB equivalent of the UNIX getdents call. The function attempts to read "nbyte" bytes from the collection associated with the descriptor "fd" and to format them as file system independent directory  entries in the buffer pointed to by buf. Since the collection entries are of variable lengths, in most cases the actual number of bytes returned will be less than "nbyte".</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG. <P>
<DT>Fd
<DD>The descriptor of the opened collection from the srbObjOpen() call.<P>
<DT>Buf
<DD>Pointer to a user-supplied local FS dirent_t struct where the getdents result will be put.<P>
<DT>Nbyte
<DD>The maximum number of bytes to output to buf.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Getdents result in buf.</P>
<P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjOpen">srbObjOpen</A>, <A HREF="#srbObjGetdents64">srbObjGetdents64</A> and <A HREF="#srbObjCreate">srbObjCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjGetdents64"></A>
<B><P>NAME</P>
<P>srbObjGetdents64</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjGetdents64(srbConn* conn, int catType, </P>
<P>int fd, dirent64_t *buf, size_t nbyte);</P>
<B><P>DESCRIPTION</P>
</B><P>The SRB equivalent of the UNIX getdents64 call which is the same as srbObjGetdents except the results are given in dirent64_t instead of dirent_t. The function attempts to read "nbyte" bytes from the collection associated with the descriptor "fd" and to format them as file system independent directory  entries in the buffer pointed to by buf. Since the collection entries are of variable lengths, in most cases the actual number of bytes returned will be less than "nbyte".</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG. <P>
<DT>Fd
<DD>The descriptor of the opened collection from the srbObjOpen() call.<P>
<DT>Buf
<DD>Pointer to a user-supplied local FS dirent64_t struct where the getdents64 result will be put.<P>
<DT>Nbyte
<DD>The maximum number of bytes to output to buf.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Getdents64 result in buf.</P>
<P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjOpen">srbObjOpen</A>, <A HREF="#srbObjGetdents">srbObjGetdents</A> and <A HREF="#srbObjCreate">srbObjCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjProxyOpr"></A>
<B><P>NAME</P>
<P>srbObjProxyOpr</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjProxyOpr (srbConn *conn, ProxyOprId operation, </P>
<P>char *inputStr1, char *inputStr2);</P>
<B><P>DESCRIPTION</P>
</B><P>Perform a proxy Operation. Some operations can be more efficiently done by the SRB server without much involvement by the client. An example is the copy operation where it is more efficient for the server to do all the read and write operations on behalf of the client than passing the data read to the client and then for the client passing it back to the server for the write operation. A general framework for handling proxy operations has been set up to facilitate the building of new proxy functions. The input of the API consists of a ProxyOprId which identifies the type of proxy operation to be carried out and two input strings. The current implementation supports only one type of proxy operation, i.e., the "Copy" operation. Additional proxy operations can be implemented within this framework.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Operation
<DD>The type of proxy operation. Valid operations:<P>
<DT>OPR_COPY
<DD>Copy from the object descriptor given in InputStr1 to the object descriptor given in inputStr2. If successful, the number of bytes copied is returned. A negative value means failure. Normally, InputStr1 contains the object descriptor obtained from a srbObjOpen() call and inputStr2 contains the object descriptor obtained from a srbobjCreate call.<P>
<DT>InputStr1
<DD>Input String 1.<P>
<DT>InputStr2
<DD>Input String 2.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 or a positive value upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</P>
</B><P>&#9;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjReplicate">srbObjReplicate</A>, <A HREF="#srbObjMove">srbObjMove</A>, <A HREF="#srbObjOpen">srbObjOpen</A> and <A HREF="#srbObjCreate">srbObjCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbExecCommand"></A>
<B><P>NAME</P>
<P>srbExecCommand</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbExecCommand (srbConn *conn, char *command, </P>
<P>char *commandArgv, char *proxyAddr, int portalFlag);</P>
<B><P>DESCRIPTION</P>
</B><P>This is a special case of proxy operation. It performs the remote execution of arbitrary commands(executables) installed in a specific predefined directory on the remote host. Currently, this predefined directory is hard-coded as "commands" in the directory where the srbMaster and srbServer executables are installed. For example, if the  srbMaster is installed in the /usr/local/srb/bin directory, the proxy commands should be installed in  the  /usr/local/srb/bin/commands directory.</P>
<P>The input argument "command" specifies the proxy command to be executed. Input arguments for the command is specified with the "commandArgv" argument. The argument "proxyAddr" specifies the host address where the proxy command is to be executed. If no address is specified, the default is the host where the client is connected to.</P>
<P>The input argument "portalFlag" specifies the mode of communication between the proxy command and the client. Valid values are PORTAL_OFF, PORTAL_ON and PORTAL_STD_IN_OUT. A value of PORTAL_OFF means there will be no communication between the proxy command and the client. PORTAL_ON means a socket will be created between the proxy command and the client. This call returns the descriptor of the socket which can be used by the client to communicate with the proxy command. On the server side, the socket descriptor is passed onto the proxy command through the environment variable defined by PORTAL_ENV. The proxy command can use this socket to communicate with the client. A value of PORTAL_STD_IN_OUT has a similar effect as PORTAL_ON except on the server side, this socket is now associated with the stdin, stdout and stderr of the proxy command. i.e., all stdout and stderr of the proxy command will be sent to the client through this socket and the client can use this socket to send messages to the stdin of the proxy command.</P> 
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>command
<DD>the proxy command to be executed.<P>
<DT>commandArgv
<DD>Input arguments for the proxy command.<p>
<DT>proxyAddr
<DD>the host address where the proxy command is to be executed. A NULL value means on the host where the client is currently connected to.<p>
<DT>portalFlag
<DD>The portal flag. Valid flags are - PORTAL_OFF, PORTAL_ON and PORTAL_STD_IN_OUT.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Upon success, returns 0 if the "portalFlag" is PORTAL_OFF, and the portal socket descriptor if the "portalFlag" is PORTAL_ON or PORTAL_STD_IN_OUT. Returns a negative value upon failure.</P>
<B><P>ERRORS</P>
</B><P>&#9;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjReplicate">srbObjReplicate</A>, <A HREF="#srbObjMove">srbObjMove</A>, <A HREF="#srbObjOpen">srbObjOpen</A> and <A HREF="#srbObjCreate">srbObjCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjReplicate"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbObjReplicate</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjReplicate (srbConn* conn, int catType, char *objID, </P>
<P>char *collectionName, char *newResourceName, char *newPathName);</P>
<P>&nbsp;</P>
<B><P>DESCRIPTION</P>
</B><P>Replicate a SRB data object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>catalog type. e,g., MDAS_CATALOG.<P>
<DT>ObjID
<DD>The SRB object ID to replicate. <P>
<DT>collectionName
<DD>The name of the collection this objID belongs.<P>
<DT>newResourceName
<DD>The storage resource name of the new copy. e.g. "mda18-unix-sdsc"</P>
<DT>newPathName
<DD>The file/DB path of the new copy. If the input is NULL, the SRB server will generate one for the client.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF=#srbSyncData">srbSyncData</A>, <A HREF="#srbObjMove">srbObjMove</A> and <A HREF="#srbObjProxyOpr">srbObjProxyOpr</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjMove"></A>
<B><P>NAME</P>
<P>srbObjMove</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjMove (srbConn* conn, int catType, char *objID, char *collectionName,</P>
<P>char *newResourceName, char *newPathName);</P>
<B><P>DESCRIPTION</P>
</B><P>Move a copy of an SRB object to a new location.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>catalog type. e,g., MDAS_CATALOG.<P>
<DT>ObjID
<DD>The SRB object ID to move. <P>
<DT>collectionName
<DD>The name of the collection this objID belongs.<P>
<DT>newResourceName
<DD>The storage resource name of the new copy. e.g. "mda18-unix-sdsc"<P>
<DT>newPathName
<DD>The file/DB path of the new copy. If the input is NULL, the SRB server will generate one for the client.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjReplicate">srbObjReplicate</A> and <A HREF="#srbObjProxyOpr">srbObjProxyOpr</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbObjWrite"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbObjWrite</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjWrite(srbConn *conn, int desc, char *buf, int len);</P>
<B><P>DESCRIPTION</P>
</B><P>Write len bytes of buf into the Object fd</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Desc
<DD>The Object descriptor to write (from svrObjOpen or svrObjCreate).<P>
<DT>Buf
<DD>The output buffer.<P>
<DT>Len
<DD>The length to write.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the number of bytes written. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjOpen">srbObjOpen</A>, <A HREF="#srbObjCreate">srbObjCreate</A> and <A HREF="#srbObjRead">srbObjRead</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbCreateCollect"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbCreateCollect</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbCreateCollect (srbConn* conn, int catType, char *parentCollect,</P>
<P>char *newCollect);</P>
<B><P>DESCRIPTION</P>
<P>&#9;</B>Create a new collect.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG.<P>
<DT>ParentCollect
<DD>The parent collection in which to create the new collection.<P>
<DT>newCollect
<DD>The name of the collection to create.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbModifyCollect">srbModifyCollect</A> and <A HREF="#srbListCollect">srbListCollect</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbListCollect"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbListCollect</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbListCollect (srbConn* conn, int catType, char *collectionName, </P>
<P>char *flag, mdasC_sql_result_struct *listResult, int rowsWanted);</P>
<B><P>DESCRIPTION</P>
</B><P>List the content of a SRB collection.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG.<P>
<DT>CollectionName
<DD>The collection to list.<P>
<DT>Flag
<DD>The list flag. "C" - non-recursive. "R" – recursive.<P>
<DT>ListResult
<DD>A pointer to a user supplied mdasC_sql_result_struct. This is where the result of the srbListCollect operation will be put.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjCreate">srbObjCreate</A> and <A HREF="#srbModifyCollect">srbModifyCollect</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbModifyCollect"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbModifyCollect</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbModifyCollect (srbConn* conn, int catType, char *collectionName, </P>
<P>char *dataValue1, char *dataValue2, char *dataValue3, int retractionType);</P>
<B><P>DESCRIPTION</P>
</B><P>Modify a SRB collection.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>catalog type. e,g., MDAS_CATALOG.<P>
<DT>collectionName
<DD>The name of the collection this objID belongs.<P>
<DT>dataValue1
<DD>Input value 1.<P>
<DT>dataValue2
<DD>Input value 2.<P>
<DT>dataValue3
<DD>Input value 3.<P>
<DT>retractionType
<DD>The type of retraction. See srbC_mdas_externs.h for the retractionType definition.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns negative value - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjCreate">srbObjCreate</A>, <A HREF="#srbListCollect">srbListCollect</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbIssueTicket"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbIssueTicket</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbIssueTicket (srbConn* conn, char *objID, char *collectionName,</P>
<P>char *collectionFlag, char *beginTime, char *endTime, int accessCnt,</P><DIR>

<P>char *ticketUser, char **ticket);</P></DIR>

<B><P>DESCRIPTION</P>
</B><P>Issue a ticket for a SRB data object or collection.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>ObjID
<DD>The data object ID. NULL if the ticket is for a collection.<P>
<DT>collectionName
<DD>The collection name. NULL if the ticket is for a data object.<P>
<DT>collectionFlag
<DD>The collect flag if CollectionName is non NULL. "R" - the ticket is for all dataset and sub-collection recursively. "D" - the ticket is for the datasets directly beneath the collection.<P>
<DT>BeginTime
<DD>The beginning time when the ticket becomes effective. A NULL means no time limit.<P>
<DT>EndTime
<DD>The ending time of the ticket.<P>
<DT>AccessCnt
<DD>The number of time the ticket can be used to access the dataset.<P>
<DT>TicketUser
<DD>The user/userGroup that will use the ticket. Multiply users can be specified with the following format:<P>
<DIR>
<P>user1@domain1&amp;user2@domain2 ....<P>
<P>If it is NULL, =&gt; all users.</P></DIR>
<DT>Ticket
<DD>The address to put the output ticket.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbRemoveTicket">srbRemoveTicket</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbRemoveTicket"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbRemoveTicket</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbRemoveTicket (srbConn* conn, char *ticket);</P>
<B><P>DESCRIPTION</P>
</B><P>Cancel a ticket.</P>
<DL>
<DT>Conn
<DD>From clConnect call. <P>
<DT>Ticket
<DD>The ticket to remove.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbIssueTicket">srbIssueTicket</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbContainerCreate"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbContainerCreate</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbContainerCreate (srbConn* conn, int catType, char *containerName, char *containerType, char *resourceName, int containerSize);</P>
<B><P>DESCRIPTION</P>
</B><P>Create a container with the given container name in the given logical resource. The logical resource should contain two physical resources: a "permanent" (e.g., HPSS) and a "temporary" or "cache" (e.g., UNIX disk file system) resource. Once a container has been created, the srbObjCreate() call may be used to create objects in the container using the CONATINER keyword. The normal srbObjWrite() and srbObjRead() calls can be used to perform write/read operations to the container. Internally, all I/O are done only to the "cache" copy of the container. If the "cache" copy does not exist (e.g., purged), a replicate of the "permanent" copy will be made to the "cache" resource before any I/O operation can be made. The srbSyncContainer() call is used to synchronize the "cache" copy with the permanent copy. When a container is full (max container size exceeded), the SRB server automatically renames the full container by appending a unique integer (clock in seconds) to the container name and creates a new container with the original name. This way, the client does not have to worry about filling up containers.</P>
<DL>
<DT>Conn
<DD>From clConnect call. <P>
<DT>catType
<DD>The catalog type. e,g., MDAS_CATALOG.<P>
<DT>containName
<DD>The name of the container to be created.<P>
<DT>containerType
<DD>The Data type of the container. e.g. "generic".<P>
<DT>resourceName
<DD>The storage resource name. This should be is a logical resource (resource group) consisting of two physical resources, a TEMPORARY_RES_CL and a PERMANENT_RES_CL class.<P>
<DT>containerSize
<DD>The size of the container to be created. A zero value means the default size should be used<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbRmContainer">srbRmContainer, <A HREF="#srbSyncContainer">srbSyncContainer, <A HREF="#srbReplContainer">srbReplContainer and <A HREF="#srbGetContainerInfo">srbGetContainerInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbRmContainer"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbRmContainer</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbRmContainer (srbConn* conn, int catType, char *containerName);</P>
<B><P>DESCRIPTION</P>
</B><P>Remove an existing container. All inContainer objects stored in the given container must be removed first before making this call</P>
<DL>
<DT>Conn
<DD>From clConnect call. <P>
<DT>catType
<DD>catalog type. e,g., MDAS_CATALOG. <P>
<DT>containName
<DD>The container to remove.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbContainerCreate">srbContainerCreate, <A HREF="#srbSyncContainer">srbSyncContainer, <A HREF="#srbReplContainer">srbReplContainer and <A HREF="#srbGetContainerInfo">srbGetContainerInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbSyncContainer"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbSyncContainer</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbSyncContainer (srbConn* conn, int catType, char *containerName, int syncFlag);</P>
<B><P>DESCRIPTION</P>
</B><P>Synchronize the "permanent" copies of the container with the "cache" copy. When an inContainer object is created or opened for I/O, all I/O are done only to the "cache" copy. This call allows the synchronization of different copies. Valid values of the syncFlag are PURGE_FLAG and PRIMARY_FLAG. If PURGE_FLAG is set, the "cache" copy will be purged once the copies has been synchronized. If PRIMARY_FLAG is set, synchronization is done only to the primary archival resource. The default is to synchronize all archival resources.</P>
<DL>
<DT>Conn
<DD>From clConnect call. <P>
<DT>catType
<DD>catalog type. e,g., MDAS_CATALOG. <P>
<DT>containName
<DD>The container to sync.<P>
<DT>syncFlag
<DD>valid values are: PURGE_FLAG and PRIMARY_FLAG. Both can be set at the same time by ORing the 2 flags. e.g., PURGE_FLAG|PRIMARY_FLAG.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbContainerCreate">srbContainerCreate, <A HREF="#srbRmContainer">srbRmContainer and <A HREF="#srbGetContainerInfo">srbGetContainerInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbReplContainer"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbReplContainer</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbReplContainer (srbConn* conn, int catType, char *containerName, char *resourceName);</P>
<B><P>DESCRIPTION</P>
</B><P>Replicate or stage a copy of a container onto the specified physical resource. The specified physical resource must be a member of the logical resource associated with the container. The srbSyncContainer() call can be used to replicate copies to either the primary archival resource or to all resources, but not to a specific non-primary resource. This call can be used to synchronize a container to a specific non-primary archival resource or stage a container to a specific non-primary cache resource.
<DL>
<DT>Conn
<DD>From clConnect call. <P>
<DT>catType
<DD>catalog type. e,g., MDAS_CATALOG. <P>
<DT>containerName
<DD>The name of the container to replicate.<P>
<DT>resourceName
<DD>The physical resource to replicate to.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbContainerCreate">srbContainerCreate, <A HREF="#srbRmContainer">srbRmContainer, <A HREF="#srbSyncContainer">srbSyncContainer and <A HREF="#srbGetContainerInfo">srbGetContainerInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>

<A NAME="srbObjGet"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbObjGet</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjGet (srbConn* conn, char *srcObjID, char *srcCollection,
char *locFilePath);</P>
<B><P>DESCRIPTION</P>
</B><P>Download a dataset from SRB to the local file system using server-directed parallel I/O
<DL>
<DT>Conn
<DD>From clConnect call. <P>
<DT>srcObjID
<DD>The SRB file to be downloaded <P>
<DT>srcCollection
<DD>The collection of the SRB file.<P>
<DT>locFilePath
<DD>The local UNIX file path of the downloaded file.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns: the number of bytes downloaded - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjPut">srbObjPut</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>

<A NAME="srbObjPut"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbObjPut</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbObjPut (srbConn* conn, char *destObjID, char *destCollection,
char *destResLoc, char *dataType, char *destPath, char *locFilePath,
srb_long_t size);</P>
<B><P>DESCRIPTION</P>
</B><P>Upload a dataset from the local file system to SRB using server-directed parallel I/O
<DL>
<DT>Conn
<DD>From clConnect call. <P>
<DT>destObjID
<DD>The SRB file name of the uploaded file. <P>
<DT>destCollection
<DD>The SRB collection of the uploaded file.<P>
<DT>destResLoc
<DD>The destination resource.<P>
<DT>dataType
<DD>Data type. e.g. "generic".<P>
<DT>destPath
<DD>The UNIX file path of the uploaded file. If the input is NULL, the SRB server will generate one.<P>
<DT>locFilePath
<DD>The UNIX file path of the local file to be uploaded..<P>
<DT>size
<DD>The size of the file being uploaded.<P>

</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns: the number of bytes uploaded - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjGet">srbObjGet</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>

<A NAME="srbSyncData"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbSyncData</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbSyncData (srbConn* conn, int catType, char *objID, char *collectionName, char *resource);</P>
<B><P>DESCRIPTION</P>
</B><P>Synchronize all copies (replica) of an SRB object with the most recently modified version.
<DL>
<DT>Conn
<DD>From clConnect call. <P>
<DT>catType
<DD>catalog type. e,g., MDAS_CATALOG. <P>
<DT>objID
<DD>The SRB file to be synchronized.<P>
<DT>collectionName
<DD>The collection of the SRB file to be synchronized.<P>
<DT>resource
<DD>The resource for the object to synchronize to. A NULL or empty string means synchronize the existing copies with the most recently modified version.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbObjReplicate">srbObjReplicate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>

<A NAME="srbGetContainerInfo"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbGetContainerInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbGetContainerInfo (srbConn* conn, int catType, char *containerName, mdasC_sql_result_struct *myresult, int rowsWanted);</P>
<B><P>DESCRIPTION</P>
</B><P>Query the metadata associated with a container.</P>
<DL>
<DT>Conn
<DD>From clConnect call. <P>
<DT>catType
<DD>catalog type. e,g., MDAS_CATALOG. <P>
<DT>containName
<DD>The container to query.<P>
<DT>Myresult
<DD>A pointer to a user supplied mdasC_sql_result_struct where result of the query will be placed.<P>
<DT>RowsWanted
<DD>The number of rows to be returned.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbContainerCreate">srbContainerCreate, <A HREF="#srbRmContainer">srbRmContainer and <A HREF="#srbSyncContainer">srbSyncContainer</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>

<A NAME="srbRegisterLocation"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbRegisterLocation</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int
srbRegisterLocation(srbConn* conn, char *locName, char *fullAddr, char *parentLoc, char *serverUser, char *serverUserDomain);
</P>
<B><P>DESCRIPTION</P>
</B><P>Register location information</P>
<DL>
<DT>conn
<DD>From clConnect call. <P>
<DT>locName
<DD>The location name.<P>
<DT>fullAddr
<DD>Full Address.<P>
<DT>parentLoc
<DD>Parent location.<P>
<DT>serverUser
<DD>Server User.<P>
<DT>serverUserDomain
<DD>Server User Domain.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P> 
<A HREF="#srbIngestToken">srbIngestToken,
<A HREF="#srbRegisterResource">srbRegisterResource,
<A HREF="#srbRegisterLogicalResource">srbRegisterLogicalResource,
<A HREF="#srbRegisterReplicateResourceInfo">srbRegisterReplicateResourceInfo</A>, and
<A HREF="#srbDeleteValue">srbDeleteValue</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>

<A NAME="srbIngestToken"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbIngestToken</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbIngestToken(srbConn* conn, char *typeName, char *newValue, char *parentValue);
</P>
<B><P>DESCRIPTION</P>
</B><P>Ingest Token</P>
<DL>
<DT>conn
<DD>From clConnect call. <P>
<DT>typeName
<DD>The type name for the type of token being inserted.<P>
<DT>newValue
<DD>The new token name.<P>
<DT>parentValue
<DD>The parent token.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P> 
<A HREF="#srbRegisterLocation">srbRegisterLocation,
<A HREF="#srbRegisterResource">srbRegisterResource,
<A HREF="#srbRegisterLogicalResource">srbRegisterLogicalResource,
<A HREF="#srbRegisterReplicateResourceInfo">srbRegisterReplicateResourceInfo</A>, and
<A HREF="#srbDeleteValue">srbDeleteValue</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>

<A NAME="srbRegisterResource"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbRegisterResource</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbRegisterResource(srbConn* conn, char *rescName, char *rescType, char *location, char *phyPath, char *class, int size);
</P>
<B><P>DESCRIPTION</P>
</B><P>Register/create a new resource (physical or compound)</P>
<DL>
<DT>conn
<DD>From clConnect call. <P>
<DT>rescName
<DD>The resource name.<P>
<DT>rescType
<DD>Resource type.<P>
<DT>location
<DD>The location of the new resource.<P>
<DT>phyPath
<DD>The default physical path.<P>
<DT>class
<DD>The resource class.<P>
<DT>size
<DD>The maximum object size in the resource.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P> 
<A HREF="#srbRegisterLocation">srbRegisterLocation,
<A HREF="#srbIngestToken">srbIngestToken,
<A HREF="#srbRegisterLogicalResource">srbRegisterLogicalResource,
<A HREF="#srbRegisterReplicateResourceInfo">srbRegisterReplicateResourceInfo</A>, and
<A HREF="#srbDeleteValue">srbDeleteValue</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>

<A NAME="srbRegisterLogicalResource"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbRegisterLogicalResource</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbRegisterLogicalResource(srbConn* conn, char *rescName, char *rescType, char *phyResc, char *phyPath);
</P>
<B><P>DESCRIPTION</P>
</B><P>Register/create a new logical resource</P>
<DL>
<DT>conn
<DD>From clConnect call. <P>
<DT>rescName
<DD>The resource name.<P>
<DT>rescType
<DD>Resource type.<P>
<DT>phyResc
<DD>The physical resource that is part of this logical resource.<P>
<DT>phyPath
<DD>The default physical path.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P> 
<A HREF="#srbRegisterLocation">srbRegisterLocation,
<A HREF="#srbIngestToken">srbIngestToken,
<A HREF="#srbRegisterResource">srbRegisterResource,
<A HREF="#srbRegisterReplicateResourceInfo">srbRegisterReplicateResourceInfo</A>, and
<A HREF="#srbDeleteValue">srbDeleteValue</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>

<A NAME="srbRegisterReplicateResourceInfo"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbRegisterReplicateResourceInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbRegisterReplicateResourceInfo( srbConn* conn, char *physicalRescName, char *rescType, char *oldLogicalRescName, char *indefaultPath);
</P>
<B><P>DESCRIPTION</P>
</B><P>Add another physical resource to a logical or compound resource</P>
<DL>
<DT>conn
<DD>From clConnect call. <P>
<DT>physicalRescName
<DD>The physical resource name.<P>
<DT>rescType
<DD>Resource type.<P>
<DT>oldLogicalRescName
<DD>The existing logical or compound resource name.
<DT>indefaultPath
<DD>The default path.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P> 
<A HREF="#srbRegisterLocation">srbRegisterLocation,
<A HREF="#srbIngestToken">srbIngestToken,
<A HREF="#srbRegisterResource">srbRegisterResource,
<A HREF="#srbRegisterLogicalResource">srbRegisterLogicalResource</A>, and
<A HREF="#srbDeleteValue">srbDeleteValue</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>


<A NAME="srbDeleteValue"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbDeleteValue</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbDeleteValue(srbConn* conn, int valueType, char *deleteValue);
</P>
<B><P>DESCRIPTION</P>
</B><P> Delete/remove a value of type location, user, or resource (other types are implemented but untested).</P>
<DL>
<DT>conn
<DD>From clConnect call. <P>
<DT>valueType
<DD>the value (token) type.<P>
<DT>deleteValue
<DD>The value (name) that is being deleted.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P> 
<A HREF="#srbRegisterLocation">srbRegisterLocation,
<A HREF="#srbIngestToken">srbIngestToken,
<A HREF="#srbRegisterResource">srbRegisterResource,
<A HREF="#srbRegisterLogicalResource">srbRegisterLogicalResource</A>, and
<A HREF="#srbRegisterReplicateResourceInfo">srbRegisterReplicateResourceInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>


<A NAME="srbSetupSessionPublicKey"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbSetupSessionPublicKey</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbSetupSessionPublicKey (srbConn *conn, char *publicKey);
</P>
<B><P>DESCRIPTION</P>
</B><P> 
Get the MCAT-enabled server's public key
in preparation for transferring encryptioned information.
Also see the sscSetupSessionPublicKey library routine.
</P>
<DL>
<DT>conn
<DD>From clConnect call. <P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns positive - success or not-supported, negative - for some failures.</P>
<p>Returns a string representation of the publicKey in publicKey.
If Secure Communications is not supported on the server side, an
error message is returned in publicKey.
</p>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P> 
<A HREF="#srbSetupSession">srbSetupSession</a>.</p>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>


<A NAME="srbSetupSession"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbSetupSession</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbSetupSession (srbConn *conn, char *sessionKey);
</P>
<B><P>DESCRIPTION</P>
Set up a session (for encryption) with the
MCAT-enabled server.
Also see the sscSetupSession library routine.
</B><P> 
</P>
<DL>
<DT>conn
<DD>From clConnect call. <P>
</DL>
<DL>
<DT>sessionKey
<DD>A string representation of the session key
   from sscSetupSession (which is encrypted in the public key returned by
   srbSetupSessionPublicKey).
<DD>
<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success, negative - failure.</P>

<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P> 
<A HREF="#srbSetupSessionPublicKey">srbSetupSessionPublicKey</a>.</p>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>




<A NAME="srbFileOpen"></A>
<B><P>NAME</P>
<P>srbFileOpen</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileOpen(srbConn* conn, int storSysType, char *hostAddr, </P>
<P>char *filename, int flags, int mode);</P>
<B><P>DESCRIPTION</P>
</B><P>Opens a file-type file.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type. <P>
0 = Unix, 1 = UniTree, 2 = HPSS, 3 = FTP, 4 = HTTP.<P>
<DT>HostAddr
<DD>The SRB Server address followed by optional ":" and port, eg "ftp.sdsc.edu:5556"<P>
<DT>Filename
<DD>The file Path name to open. The path must be an absolute path.<P>
<DT>Flags
<DD>Same definition as in unix.<P>
<DT>Mode
<DD>Same definition as in unix.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the file descriptor for use in subsequent calls. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileCreate">srbFileCreate</A>, <A HREF="#srbFileClose">srbFileClose</A>, <A HREF="#srbFileRead">srbFileRead</A> and <A HREF="#srbFileWrite">srbFileWrite</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileCreate"></A>
<B><P>NAME</P>
<P>srbFileCreate</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileCreate(srbConn* conn, int storSysType, char *hostAddr, </P>
<P>char *filename, int mode, int size);</P>
<B><P>DESCRIPTION</P>
</B><P>Create a File-type file.</P>
<DL>
<DT>Conn
<DD>From clConnect function.<P>
<DT>StorSysType
<DD>Storage system type. 
0 = Unix, 1 = UniTree, 2 = HPSS, 3 = FTP (not supported for HTTP).<P>
<DT>HostAddr
<DD>The SRB Server address followed by optional ":" and port, eg "ftp.sdsc.edu:5556"<P>
<DT>Filename
<DD>The file Path name to create. The path must be an absolute path.<P>
<DT>Mode
<DD>Same definition as in unix.<P>
<DT>Size
<DD>File size. Only valid for HPSS storage system type for determining the Class Of Service (COS). -1 => don't know and the default COS will be used.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the file descriptor for use in subsequent calls. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A>, <A HREF="#srbFileUnlink">srbFileUnlink</A>, <A HREF="#srbFileClose">srbFileClose</A>, <A HREF="#srbFileRead">srbFileRead</A> and <A HREF="#srbFileWrite">srbFileWrite</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileUnlink"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbFileUnlink</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileUnlink(srbConn* conn, int storSysType, char *hostAddr, </P>
<P>char *filename);</P>
<B><P>DESCRIPTION</P>
</B><P>Unlink a File-type file.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type. <P>
0 = Unix, 1 = UniTree, 2 = HPSS, 3 = FTP (not supported for HTTP).<P>
<DT>HostAddr
<DD>The SRB Server address followed by optional ":" and port, eg "ftp.sdsc.edu:5556"<P>
<DT>Filename
<DD>The file Path name to unlink. The path must be an absolute path.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A>, <A HREF="#srbFileCreate">srbFileCreate</A>, <A HREF="#srbFileClose">srbFileClose</A>, <A HREF="#srbFileRead">srbFileRead</A> and <A HREF="#srbFileWrite">srbFileWrite</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileClose"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbFileClose</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileClose(srbConn* conn, int fd);</P>
<P>&nbsp;</P>
<B><P>DESCRIPTION</P>
</B><P>Close a File-type file.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Fd
<DD>The file descriptor to close (from srbFileOpen or srbFileCreate).<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A>, <A HREF="#srbFileCreate">srbFileCreate</A>, <A HREF="#srbFileUnlink">srbFileUnlink</A>, <A HREF="#srbFileRead">srbFileRead</A> and <A HREF="#srbFileWrite">srbFileWrite</A>.</P>
<B><P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileRead"></A>
<P>NAME</P>
</B><P>&#9;<B>srbFileRead</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileRead(srbConn *conn, int fd, char *buf, int len);</P>
<B><P>DESCRIPTION</P>
</B><P>Read len bytes of the File-type file into buf. The caller must have allocated enough space to hold the data read.</P>
<DL>
<DT>Conn
<DD>From clConnect ().<P>
<DT>Fd
<DD>The file descriptor to read (from srbFileOpen or srbFileCreate).<P>
<DT>Buf
<DD>The input buffer.<P>
<DT>Len
<DD>The length to read.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the number of bytes read. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A>, <A HREF="#srbFileCreate">srbFileCreate</A>, <A HREF="#srbFileUnlink">srbFileUnlink</A>, <A HREF="#srbFileClose">srbFileClose</A> and <A HREF="#srbFileWrite">srbFileWrite</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileWrite"></A>
<B><P>NAME</P>
<P>srbFileWrite</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileWrite(srbConn *conn, int fd, char *buf, int len);</P>
<B><P>DESCRIPTION</P>
</B><P>Write len bytes of buf into the File-type file fd.</P>
<DL>
<DT>Conn
<DD>From clConnect ().<P>
<DT>Fd
<DD>The file descriptor to write (from srbFileOpen or srbFileCreate).<P>
<DT>Buf
<DD>The output buffer.<P>
<DT>Len
<DD>The length to write.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the number of bytes written. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A>, <A HREF="#srbFileCreate">srbFileCreate</A>, <A HREF="#srbFileUnlink">srbFileUnlink</A>, <A HREF="#srbFileClose">srbFileClose</A>, <A HREF="#srbFileRead">srbFileRead</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileSeek"></A>
<B><P>NAME</P>
<P>srbFileSeek</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileSeek(srbConn *conn, int fd, int offset, int whence);</P>
<B><P>DESCRIPTION</P>
</B><P>Change the current read or write location on a File-type file.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Fd
<DD>The file descriptor to seek (from srbFileOpen or srbFileCreate).<P>
<DT>Offset
<DD>The position of the next operation<P>
<DT>Whence
<DD>Same definition as in Unix.<P>
SEEK_SET - pointer is set to the value of the Offset parameter.<P>
SEEK_CUR - pointer is set to its current location plus the value of the Offset parameter.<P>
SEEK_END - Pointer is set to the size of the file plus the value of the Offset parameter.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the resulting pointer location, measured in bytes from the beginning of the file upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A>, <A HREF="#srbFileCreate">srbFileCreate</A>, <A HREF="#srbFileUnlink">srbFileUnlink</A>, <A HREF="#srbFileClose">srbFileClose</A>, <A HREF="#srbFileRead">srbFileRead</A> and <A HREF="#srbFileWrite">srbFileWrite</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileSync"></A>
<B><P>NAME</P>
<P>srbFileSync</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileSync(srbConn* conn, int fd);</P>
<B><P>DESCRIPTION</P>
</B><P>Sync a File-type file.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Fd
<DD>The file descriptor to sync (from srbFileOpen or srbFileCreate).<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A>, <A HREF="#srbFileCreate">srbFileCreate</A>, <A HREF="#srbFileUnlink">srbFileUnlink</A>, <A HREF="#srbFileClose">srbFileClose</A>, <A HREF="#srbFileRead">srbFileRead</A> and <A HREF="#srbFileWrite">srbFileWrite</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileStat"></A>
<B><P>NAME</P>
<P>srbFileStat</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileStat(srbConn* conn, int storSysType, char *hostAddr, </P>
<P>char *filename, struct srbStat *statbuf);</P>
<B><P>DESCRIPTION</P>
</B><P>Get the status of a File-type file.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type. <P>
0 = Unix, 1 = UniTree, 2 = HPSS, 3 = FTP (not supported for HTTP).<P>
<DT>HostAddr
<DD>The SRB Server address followed by optional ":" and port, eg "ftp.sdsc.edu:5556"<P>
<DT>Filename
<DD>The file Path name to stat. The path must be an absolute path.<P>
<DT>Statbuf
<DD>Pointer to a user-supplied srbStat struct where the stat result is put.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Stat result in statbuf.</P>
<P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A> and <A HREF="#srbFileCreate">srbFileCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileFstat"></A>
<B><P>NAME</P>
<P>srbFileFstat</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileFstat(srbConn* conn, int storSysType, char *hostAddr, </P>
<P>int fd, struct srbStat *statbuf);</P>
<B><P>DESCRIPTION</P>
</B><P>Get the status of a File-type file.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type. <P>
0 = Unix, 1 = UniTree, 2 = HPSS, 3 = FTP (not supported for HTTP).<P>
<DT>HostAddr
<DD>The SRB Server address followed by optional ":" and port, eg "ftp.sdsc.edu:5556"<P>
<DT>Fd
<DD>The file descriptor to stat (from srbFileOpen or srbFileCreate).<P>
<DT>Statbuf
<DD>Pointer to a user-supplied srbStat struct where the stat result is put.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Stat result in statbuf.</P>
<P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileOpen">srbFileOpen</A>, <A HREF="#srbFileStat">srbFileStat</A> and <A HREF="#srbFileCreate">srbFileCreate</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileMkdir"></A>
<B><P>NAME</P>
<P>srbFileMkdir</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileMkdir(srbConn* conn, int storSysType, char *hostAddr, </P>
<P>char *filename, int mode);</P>
<B><P>DESCRIPTION</P>
</B><P>Create a new file-type directory.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type. <P>
0 = Unix, 1 = UniTree, 2 = HPSS, 3 = FTP (not supported for HTTP).<P>
<DT>HostAddr
<DD>The SRB Server address followed by optional ":" and port, eg "ftp.sdsc.edu:5556"<P>
<DT>Filename
<DD>The Path name of the new directory. The path must be an absolute path.<P>
<DT>Mode
<DD>Same definition as in Unix.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileRmdir">srbFileRmdir</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileChmod"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbFileChmod</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileChmod(srbConn* conn, int storSysType, char *hostAddr, </P>
<P>char *filename, int mode);</P>
<B><P>DESCRIPTION</P>
</B><P>Change the mode of a file-type file or directory.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type. <P>
0 = Unix, 1 = UniTree, 2 = HPSS, 3 = FTP (not supported for HTTP).<P>
<DT>HostAddr
<DD>The SRB Server address followed by optional ":" and port, eg "ftp.sdsc.edu:5556"<P>
<DT>Filename
<DD>The Path name of the file or directory. The path must be an absolute path.<P>
<DT>Mode
<DD>Same definition as in Unix.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFileRmdir"></A>
<P>NAME</P>
<P>srbFileRmdir</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbFileRmdir(srbConn* conn, int storSysType, char *hostAddr, </P>
<P>char *filename);</P>
<B><P>DESCRIPTION</P>
</B><P>Remove a file-type directory.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type. <P>
0 = Unix, 1 = UniTree, 2 = HPSS, 3 = FTP (not supported for HTTP).<P>
<DT>HostAddr
<DD>The SRB Server address followed by optional ":" and port, eg "ftp.sdsc.edu:5556"<P>
<DT>Filename
<DD>The Path name of the directory to remove. The path must be an absolute path.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFileMkdir">srbFileMkdir</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbSetStorAttri"></A>
<B><P>NAME</P>
<P>srbSetStorAttri</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbSetStorAttri(srbConn* conn, int storSysType, </P>
<P>char *hostAddr, char *userAuth, char *dirPath);</P>
<B><P>DESCRIPTION</P>
</B><P>Set Attributes for a Storage System. Currently only defined for FTP files, connects to an FTP Server and/or sets the current directory.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type. <P>
3 = FTP. Currently only defined for FTP.<P>
<DT>HostAddr
<DD>The FTP Server address followed by optional ":" and port, eg "ftp.sdsc.edu:21"<P>
<DT>UserAuth
<DD>The User id and optional password, eg "anonymous:schroede@sdsc.edu"<P>
<DT>DirPath
<DD>Directory to change to (cd) (dirPath or vaultAddr may be null to leave unchanged, if both are null the SRB will disconnect from the ftp server (gracefully logout))<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbOpendir"></A>
<B><P>NAME</P>
<P>srbOpendir</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbOpendir(srbConn* conn, int storSysType, char *hostAddr, char *dirname);</P>
<B><P>DESCRIPTION</P>
</B><P>Open a file-type directory.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type.<P>
0 = Unix, 1 = UniTree, 2 = HPSS, 3 = FTP (not supported for HTTP).<P>
<DT>HostAddr
<DD>The FTP Server address followed by optional ":" and port, eg "ftp.sdsc.edu:5556"<P>
<DT>Dirname
<DD>The dir Path name to open. The path must be an absolute path.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the file descriptor for use in subsequent client calls. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbClosedir">srbClosedir</A> and <A HREF="#srbReaddir">srbReaddir</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbClosedir"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbClosedir</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>extern int srbClosedir(srbConn* conn, int fd);</P>
<B><P>DESCRIPTION</P>
</B><P>Close an opened file-type directory.</P>
<DL>
<DT>Conn
<DD>From clConnect ().<P>
<DT>Fd
<DD>The file directory descriptor to close (from srbOpendir).<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&#9;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbOpendir">srbOpendir</A> and <A HREF="#srbReaddir">srbReaddir</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbReaddir"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbReaddir</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>struct srbDirent *srbReaddir(srbConn* conn, int dirDesc);</P>
<B><P>DESCRIPTION</P>
</B><P>Read a file-type directory entry.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Fd
<DD>The file descriptor to read (from srbOpendir)<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>A pointer to struct srbDirent - The dirent read.</P>
<P>&nbsp;</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbOpendir">srbOpendir</A> and <A HREF="#srbClosedir">srbClosedir</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbDbLobjOpen"></A>
<B><P>NAME</P>
<P>&#9;srbDbLobjOpen</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbDbLobjOpen(srbConn* conn, int storSysType,</P>
<P>char *resourceLoc, char *dataPath, int flags, int mode);</P>
<B><P>DESCRIPTION</P>
</B><P>Open a DB Large Object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type.<P>
0 = DB2, 1 = Illustra, 5 = Oracle.<P>
<DT>ResourceLoc
<DD>Resource location. Format : host:database:instance.<P>
<DT>DataPath
<DD>Data path. Format : /tablename/objectID. If only the objectID is given, the tablename will default to "/srbVault".<P>
<DT>Flags
<DD>Same definition as in unix.<P>
<DT>Mode
<DD>Not currently used.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the file descriptor for use in later srbDbLobj* calls. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbDbLobjCreate">srbDbLobjCreate</A>, <A HREF="#srbDbLobjClose">srbDbLobjClose</A>, <A HREF="#srbDbLobjRead">srbDbLobjRead</A>, <A HREF="#srbDbLobjWrite">srbDbLobjWrite</A> and <A HREF="#srbDbLobjUnlink">srbDbLobjUnlink</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbDbLobjCreate"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbDbLobjCreate</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbDbLobjCreate(srbConn* conn, int storSysType,</P>
<P>char * ResourceLoc, char *filename, int mode);</P>
<B><P>DESCRIPTION</P>
</B><P>Create a DB Large Object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type.<P>
0 = DB2, 1 = Illustra, 5 = Oracle.<P>
<DT>ResourceLoc
<DD>Resource location. Format : host:database:instance.<P>
<DT>DataPath
<DD>data path. Format : /tablename/objectID. If only the objectID is given , the tablename will default to "/srbVault".<P>
<DT>Mode
<DD>Not currently used.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the file descriptor for use in later srbDbLobj* calls.</P>
<P>Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbDbLobjOpen">srbDbLobjOpen</A>, <A HREF="#srbDbLobjClose">srbDbLobjClose</A>, <A HREF="#srbDbLobjRead">srbDbLobjRead</A>, <A HREF="#srbDbLobjWrite">srbDbLobjWrite</A> and <A HREF="#srbDbLobjUnlink">srbDbLobjUnlink</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbDbLobjClose"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbDbLobjClose</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbDbLobjClose(srbConn* conn, int fd);</P>
<B><P>DESCRIPTION</P>
</B><P>Close an opened DB Large Object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Fd
<DD>The dbLobj descriptor to close (from srbDbLobjOpen or srbDbLobjCreate).<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbDbLobjOpen">srbDbLobjOpen</A>, <A HREF="#srbDbLobjCreate">srbDbLobjCreate</A>, <A HREF="#srbDbLobjRead">srbDbLobjRead</A>, <A HREF="#srbDbLobjWrite">srbDbLobjWrite</A> and <A HREF="#srbDbLobjUnlink">srbDbLobjUnlink</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbDbLobjRead"></A>
<B><P>NAME</P>
<P>&#9;srbDbLobjRead</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbDbLobjRead(srbConn *conn, int fd, char *buf, int len);</P>
<B><P>DESCRIPTION</P>
</B><P>Read len bytes of the DB large object into buf. The caller must have allocated enough space to hold the data read.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Fd
<DD>The object descriptor (from the srbDbLobjOpen call) to read.<P>
<DT>Buf
<DD>The input buffer.<P>
<DT>Len
<DD>The number of bytes to read.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the length of bytes read. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbDbLobjOpen">srbDbLobjOpen</A>, <A HREF="#srbDbLobjCreate">srbDbLobjCreate</A>, <A HREF="#srbDbLobjClose">srbDbLobjClose</A>, <A HREF="#srbDbLobjWrite">srbDbLobjWrite</A> and <A HREF="#srbDbLobjUnlink">srbDbLobjUnlink</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbDbLobjWrite"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbDbLobjWrite</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbDbLobjWrite(srbConn *conn, int fd, char *buf, int len);</P>
<B><P>DESCRIPTION</P>
</B><P>Write len bytes of buf into the dbLobj fd.</P>
<DL>
<DT>Conn
<DD>From clConnect ().<P>
<DT>Fd
<DD>The dbLobj descriptor to write (from srbDbLobjOpen or srbDbLobjCreate).
<DT>Buf
<DD>The output buffer.<P>
<DT>Len
<DD>The length to write.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the number of bytes written. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbDbLobjOpen">srbDbLobjOpen</A>, <A HREF="#srbDbLobjCreate">srbDbLobjCreate</A>, <A HREF="#srbDbLobjClose">srbDbLobjClose</A>, <A HREF="#srbDbLobjRead">srbDbLobjRead</A> and <A HREF="#srbDbLobjUnlink">srbDbLobjUnlink</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbDbLobjSeek"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbDbLobjSeek</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbDbLobjSeek(srbConn *conn, int fd, int offset, int whence);</P>
<B><P>DESCRIPTION</P>
</B><P>Change the current read or write location of dbLobj.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Fd
<DD>The dbLobj descriptor (from the srbDbLobjOpen call) to seek.<P>
<DT>Offset
<DD>The position of the next operation<P>
<DT>Whence
<DD>Same definition as in Unix.<P>
SEEK_SET - pointer is set to the value of the Offset parameter.<P>
SEEK_CUR - pointer is set to its current location plus the value of the Offset parameter.<P>
SEEK_END - pointer is set to the size of the file plus the value of the Offset parameter.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 upon success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbDbLobjOpen">srbDbLobjOpen</A>, <A HREF="#srbDbLobjCreate">srbDbLobjCreate</A>, <A HREF="#srbDbLobjClose">srbDbLobjClose</A>, <A HREF="#srbDbLobjRead">srbDbLobjRead</A>, <A HREF="#srbDbLobjWrite">srbDbLobjWrite</A> and <A HREF="#srbDbLobjUnlink">srbDbLobjUnlink</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbDbLobjUnlink"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbDbLobjUnlink</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbDbLobjUnlink(srbConn* conn, int storSysType, char *resourceLoc,</P>
<P>char *dataPath);</P>
<B><P>DESCRIPTION</P>
</B><P>Unlink a DB large object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>StorSysType
<DD>Storage system type.<P>
0 = DB2, 1 = Illustra, 5 = Oracle.<P>
<DT>ResourceLoc
<DD>Resource location Format : host:database:instance.<P>
<DT>DataPath
<DD>Data path. Format : tablename/objectID.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbDbLobjOpen">srbDbLobjOpen</A>, <A HREF="#srbDbLobjCreate">srbDbLobjCreate</A>, <A HREF="#srbDbLobjClose">srbDbLobjClose</A>, <A HREF="#srbDbLobjRead">srbDbLobjRead</A> and <A HREF="#srbDbLobjWrite">srbDbLobjWrite</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><A NAME="srbGetDatasetInfo"></A>
<P>NAME</P>
</B><P>&#9;<B>srbGetDatasetInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbGetDatasetInfo(srbConn* conn, int catType, char *objID,</P>
<P>char *collectionName, mdasC_sql_result_struct *myresult, int rowsWanted);</P>
<B><P>DESCRIPTION</P>
</B><P>Get some specific Info on a SRB data object. This call is normally used by the SRB server to check for access permission of data objects. If the permission checked out, it returns attributes such as "Resource Location", "Resource Type" and "Data Path Name" of the data object. These attributes are needed for subsequent access of the data by low-level drivers.</P>
<P>&#9;</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>The catalog type - 0 = MDAS_CATALOG.<P>
<DT>ObjID
<DD>The SRB data object ID to query. <P>
<DT>CollectionName 
<DD>The collection name.<P>
<DT>Myresult
<DD>A pointer to a user supplied mdasC_sql_result_struct where the result of the query will be put.<P>
<DT>RowsWanted
<DD>The number of rows of result wanted.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Return 0 - success; myresult-&gt;continuation_index &gt;= 0, ==&gt; more results from the query. Use srbGetMoreRows() to retrieve more rows.</P>
<P>A negative value – failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbGetDataDirInfo">srbGetDataDirInfo</A> and <A HREF="#srbGetMoreRows">srbGetMoreRows</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbGetDataDirInfo"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbGetDataDirInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbGetDataDirInfo(srbConn* conn, int catType, char qval[][MAX_TOKEN],</P>
<P>int *selval, mdasC_sql_result_struct *myresult, int rowsWanted);</P>
<B><P>DESCRIPTION</P>
</B><P>This is the general API for querying the MCAT catalog. The server uses the input qval[][] and selval[] array to generate and execute SQL queries and returns the query result in myresult. The selval[] array specifies a list of attributes to retrieve, and qval[][] specifies a lists of "=" predicates to search. Both selval[] and qval[][] must be arrays of size MAX_DCS_NUM and are indexed by values given in mdasC_db2_externs.h under the heading DCS-ATTRIBUTE-INDEX DEFINES.</P>
<P>For the selval[] array, setting an element of the array to 1 means that the attribute associated with this element is to be retrieved. e.g., selval[USER_NAME] = 1; means the "user_name" attribute is to be retrieved.</P>
<P>The qval[][] array specifies the "=" predicates to search. e.g., sprintf(qval[DATA_NAME],"'%s'", "unixFileObj1"); means that the search condition includes the term (data_name = "unixFileObj1").</P>
<P>An example of srbGetDataDirInfo:</P>
<P>&#9;mdasC_sql_result_struct myresult;</P>
<P>&#9;char qval[MAX_DCS_NUM][MAX_TOKEN];</P>
<P>&#9;int selval[MAX_DCS_NUM];</P>
<P>&#9;for (i = 0; i &lt; MAX_DCS_NUM; i++) {</P>
<P>&#9;&#9;selval[i] = 0;</P>
<P>&#9;&#9;sprintf(qval[i],"");</P>
<P>&#9;}</P>
<P>&#9;sprintf(qval[DATA_NAME],"'%s'",argv[2]);</P>
<P>&#9;selval[PATH_NAME] = 1;</P>
<P>&#9;selval[RSRC_NAME] = 1;</P>
<P>&#9;&#9;.</P>
<P>&#9;&#9;.</P>
<P>if (srbGetDataDirInfo(conn, MDAS_CATALOG, qval, selval, &amp;myresult) &lt; 0) {</P>
<P>&#9;&#9;fprintf(stderr, "can't srbGetDataDirInfo \n");</P>
<P>&#9;&#9;exit_nicely(conn);</P>
<P>&#9;}</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<DL>
<DT>conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>The catalog type - 0 = MDAS_CATALOG<P>
<DT>qval[][MAX_TOKEN]
<DD>A point to a user supplied char qval[MAX_DCS_NUM][MAX_TOKEN] array.<P>
<DT>Selval
<DD>A pointer to a user supplied selval[MAX_DCS_NUM] array.<P>
<DT>Myresult
<DD>A pointer to a user supplied mdasC_sql_result_struct where the result of the query will be put.<P>
<DT>RowsWanted
<DD>number of rows of result wanted.<P>
</DL>
<P>&nbsp;</P>
<B><P>RETURN VALUES</P>
</B><P>Return 0 - success; myresult-&gt;continuation_index &gt;= 0, ==&gt; more results from the query. Use srbGetMoreRows() to retrieve more rows.</P>
<P>A negative value means failure.</P>
<B><P>ERRORS</B> </P>
<P>&#9;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbGetMoreRows">srbGetMoreRows</A> and <A HREF="#srbGetDatasetInfo">srbGetDatasetInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbRegisterDataset"></A>
<B><P>NAME</P>
<P>srbRegisterDataset</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbRegisterDataset (srbConn* conn, int catType, char *objID, char *dataTypeName, char *resourceName, char *collectionName, char *pathName, srb_long_t dataSize);</P>
<B><P>DESCRIPTION</P>
</B><P>Register an SRB object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG.<P>
<DT>objID
<DD>The SRB data object ID.<P>
<DT>dataTypeName
<DD>The Data type. e.g. "generic".<P>
<DT>resourceName
<DD>The storage resource name. This may be the name of a single resource or a resource group (or logical resource) consisting of two or more physical resources. e.g. "mda18-unix-sdsc.<P>
<DT>collectionName
<DD>The collection name of this SRB object.<P>
<DT>pathName
<DD>The file/DB path of the data being registered.<P>
<DT>dataSize
<DD>The size in bytes of the data being registered.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. A negative value - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbUnregisterDataset">srbUnregisterDataset</A>, <A HREF="#srbModifyDataset">srbModifyDataset</A> and <A HREF="#srbGetDatasetInfo">srbGetDatasetInfo</A>.</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbUnregisterDataset"></A>
<B><P>NAME</P>
<P>srbUnregisterDataset</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbUnregisterDataset (srbConn* conn, char *objID, char *collectionName);</P>
<B><P>DESCRIPTION</P>
</B><P>Unregister an SRB object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>objID
<DD>The SRB data object ID to unregister.<P>
<DT>collectionName
<DD>The collection name of this SRB object.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. A negative value - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbRegisterDataset">srbRegisterDataset</A>, <A HREF="#srbModifyDataset">srbModifyDataset</A> and <A HREF="#srbGetDatasetInfo">srbGetDatasetInfo</A>.</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbSetAuditTrail"></A>
<B><P>NAME</P>
<P>srbSetAuditTrail</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbSetAuditTrail (srbConn* conn, int set_value);</P>
<B><P>DESCRIPTION</P>
</B><P>Set and Unset Audit Trail.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>set_value
<DD>The Audit Trail value to set.<P>
AUDIT_TRAIL_OFF - turn on audit trail.<P>
AUDIT_TRAIL_ON - turn on audit trail.<P>
GET_AUDIT_TRAIL_SETTING - return the current audit trail setting without modifying the setting.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns the currently audit trail setting (after processing the latest change request).</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbModifyDataset"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbModifyDataset</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbModifyDataset (srbConn* conn, int catType, char *objID,</P>
<P>char *collectionName, char *resourceName, char *pathName, </P><DIR>
<DIR>

<P>char *dataValue1, char *dataValue2, int retractionType);</P></DIR>
</DIR>

<B><P>DESCRIPTION</P>
</B><P>Modify a SRB data object.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG.<P>
<DT>ObjID
<DD>The SRB object ID to modify. The objID must already have been registered with the MCAT catalog.<P>
<DT>collectionName
<DD>The name of the collection this objID belongs.<P>
<DT>resourceName
<DD>The storage resource name. e.g. "mda18-unix-sdsc"<P>
<DT>pathName
<DD>The file/DB path of the data.<P>
<DT>dataValue1
<DD>Input value 1. See the prototype for the modify_dataset_info() function in catalog/include/mdasPrototypes.h for the definition of dataValue1, dataValue2 and retractionType.<P>
<DT>DataValue2
<DD>Input value 2.<P>
<DT>retractionType
<DD>The type of retraction. See srbC_mdas_externs.h for the retractionType definition.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbGetDatasetInfo">srbGetDatasetInfo</A> and <A HREF="#srbGetDataDirInfo">srbGetDataDirInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbChkMdasAuth"></A>
<B><P>NAME</P>
<P>srbChkMdasAuth</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbChkMdasAuth (srbConn* conn, char *userName, char *srbAuth, </P>
<P>char *mdasDomain);</P>
<B><P>DESCRIPTION</P>
</B><P>Authenticate a userName/passwd for normal access. This is a call normally used by the SRB server to authenticate a user.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>userName 
<DT>srbAuth
<DD>The userName/passwd pair to authenticate.<P>
<DT>MdasDomain
<DD>The user’s Domain.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 – success. The user is authenticated. </P>
<P>Returns negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbChkMdasSysAuth">srbChkMdasSysAuth</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbChkMdasSysAuth"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbChkMdasSysAuth</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbChkMdasSysAuth (srbConn* conn, char *userName, char *srbAuth,</P>
<P>char *mdasDomain);</P>
<B><P>DESCRIPTION</P>
</B><P>Authenticate a userName/passwd for sys admin access. This is a call normally used by the SRB server to authenticate a special user.</P>
<DL>
<DT>conn
<DD>From clConnect call.<P>
<DT>userName 
<DT>srbAuth
<DD>The userName/passwd pair to authenticate.<P>
<DT>MdasDomain
<DD>The user Domain.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 – success. The user is authenticated.</P>
<P>&#9;Returns negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbChkMdasAuth">srbChkMdasAuth</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbRegisterUserGrp"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbRegisterUserGrp</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbRegisterUserGrp (srbConn* conn, int catType, char *userGrpName,</P>
<DIR>char *userGrpPasswd, char *userGrpType, char* userGrpAddress, </P><DIR>
char* userGrpPhone, char* userGrpEmail);</P></DIR>
</DIR>

<B><P>DESCRIPTION</P>
</B><P>Register a user group with MCAT.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG.<P>
<DT>UserGrpName
<DD>The name of the user group to register.<P>
<DT>UserGrpPasswd
<DD>The user group passwd.<P>
<DT>UserGrpType
<DD>The user group type. Currently, at SDSC valid userType are:<P>
"staff", "sdsc staff", "sdsc staff scientist", 
"sdsc senior staff scientist", "pto staff", "ucsd staff"
"student", "sdsc student", "uva student", "project",
"umd student", "public", "sysadmin", " deleted".<P>
<DT>userGrpAddress
<DD>The mailing address of the user group.<P>
<DT>userGrpPhone
<DD>The phone number of the user group.<P>
<DT>userGrpEmail
<DD>The Email address of the user group.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbRegisterUser">srbRegisterUser</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbRegisterUser"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbRegisterUser</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbRegisterUser (srbConn* conn, int catType, char *userName,</P>
<DIR>char *userDomain, char *userPasswd, char *userType,</P><DIR>
char* userAddress, char* userPhone, char* userEmail);</P></DIR>
</DIR>
<B><P>DESCRIPTION</P>
</B><P>Register a user with MCAT.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG.<P>
<DT>UserName
<DD>The name of the user to register.<P>
<DT>UserDomain
<DD>The domain of the user to register.<P>
<DT>UserPasswd
<DD>The user passwd.<P>
<DT>UserType
<DD>The user type. Currently, at SDSC valid userType are:<P>
"staff", "sdsc staff", "sdsc staff scientist",
"sdsc senior staff scientist", "pto staff", "ucsd staff",
"student", "sdsc student", "uva student", "project",
"umd student", "public", "sysadmin", " deleted"
<DT>UserAddress
<DD>The mailing address of the user.<P>
<DT>UserPhone
<DD>The phone number of the user.<P>
<DT>UserEmail
<DD>The Email address of the user.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns negative - failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbRegisterUserGrp">srbRegisterUserGrp</A> and <A HREF="#srbModifyUser">srbModifyUser</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbModifyUser"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbModifyUser</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbModifyUser (srbConn* conn, int catType, char *dataValue1,</P>
<P>char *dataValue2, int retractionType);</P>
<B><P>DESCRIPTION</P>
</B><P>Modify a user’s metadata.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>CatType
<DD>Catalog type. e,g., MDAS_CATALOG.<P>
<DT>dataValue1
<DT>dataValue2
<DT>retractionType
<DD>DataValue1, dataValue2 and retractionType are used to specify the user attributes to modify. A normal user may use it to modify his/her own passwd and a limited set of attributes. A user with MDAS sys admin privilege can also use these input values to modify other user's attributes. Descriptions of retractionType supported and the expected values for dataValue1 and dataValue2 can be found in mdasPrototypes.h.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns negative – failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbRegisterUser">srbRegisterUser</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbGetPrivUsers"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbGetPrivUsers</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int srbGetPrivUsers(srbConn *conn, int catalog, </P>
<P>mdasC_sql_result_struct *myresult, int rowsWanted);</P>
<B><P>DESCRIPTION</P>
</B><P>Read the privileged users list and put it in a user supplied char srbUserList[MAX_TOKEN][MAX_TOKEN].</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Catalog
<DD>The catalog type. e.g., MDAS_CATALOG.<P>
<DT>SrbUserList
<DD>A pointer to a user supplied mdasC_sql_result_struct where the result of the query will be placed.<P>
<DT>RowsWanted
<DD>The number of rows to be returned.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Return 0 - success; SrbUserList -&gt;continuation_index &gt;= 0, ==&gt; more results from the query. Use srbGetMoreRows() to retrieve more rows.</P>
<P>A negative value – failure.</P>
<P>&nbsp;</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
<P></B><A HREF="#srbGetMoreRows">srbGetMoreRows</A>. </P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbGetMoreRows"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbGetMoreRows</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>Int srbGetMoreRows(srbConn *conn, int catalog,</P>
<P>int contDesc, mdasC_sql_result_struct *myresult, int rowsWanted);</P>
<B><P>DESCRIPTION</P>
</B><P>Get more rows of result from a srbGetDatasetInfo, srbGetDataDirInfo, srbListCollect or srbGetPrivUsers call, and put the results in a user supplied mdasC_sql_result_struct.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Catalog
<DD>The catalog type. e.g., MDAS_CATALOG.<P>
<DT>ContDesc
<DD>The continuation descriptor. This is a non negative integer returned from a srbGetDatasetInfo, srbGetDataDirInfo, srbListCollect or srbGetPrivUsers call in myresult-&gt;continuation_index.<P>
<DT>Myresult
<DD>A pointer to a user supplied mdasC_sql_result_struct where result of the query will be placed.<P>
<DT>RowsWanted
<DD>The number of rows to be returned.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>Returns 0 - success. Returns negative – failure.</P>
<P>&nbsp;</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbGetDatasetInfo">srbGetDatasetInfo</A>, <A HREF="#srbGetDataDirInfo">srbGetDataDirInfo</A>, <A HREF="#srbListCollect">srbListCollect</A> and <A HREF="#srbGetPrivUsers">srbGetPrivUsers</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="freeSqlResult"></A>
<B><P>NAME</P>
</B><P>&#9;<B>freeSqlResult</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>void freeSqlResult (mdasC_sql_result_struct *myresult);</P>
<B><P>DESCRIPTION</P>
</B><P>Free the content of myresult and then free myresult itself.</P>
<DL>
<DT>Myresult
<DD>The mdasC_sql_result_struct to be cleared.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;None.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#clearSqlResult">clearSqlResult</A> and <A HREF="#printSqlResult">printSqlResult</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="clearSqlResult"></A>
<B><P>NAME</P>
</B><P>&#9;<B>clearSqlResult</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>void clearSqlResult (mdasC_sql_result_struct *myresult);</P>
<B><P>DESCRIPTION</P>
</B><P>Clear the content of myresult. Myresult is not freed itself.</P>
<DL>
<DT>Myresult
<DD>The mdasC_sql_result_struct to be cleared.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;None</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#freeSqlResult">freeSqlResult</A> and <A HREF="#printSqlResult">printSqlResult</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="printSqlResult"></A>
<B><P>NAME</P>
</B><P>&#9;<B>printSqlResult</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>void printSqlResult (mdasC_sql_result_struct *myresult);</P>
<B><P>DESCRIPTION</P>
</B><P>Print the content of myresult.</P>
<DL>
<DT>Myresult
<DD>The mdasC_sql_result_struct to be printed.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;None.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#freeSqlResult">freeSqlResult</A> and <A HREF="#clearSqlResult">clearSqlResult</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srb_perror"></A>
<B><P>NAME</P>
<P>srb_perror</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>void srb_perror(int fd, int error_id, char *error_mnenomic, int flags);</P>
<B><P>DESCRIPTION</P>
</B><P>Print an SRB error message corresponding to the SRB error referred to by <error_id> or <error_mnenomic> (if non-null). If both <error_id> and <error_mnenomic> are passed, <error_mnenomic> will take precedence.  The message is emitted to the file descriptor referred to by <fd>. If <fd> is invalid, the error will be emitted to the stderr (fd 2). Optional behavior of srb_perror is controlled by the <flags> parameter.</P>
<DL>
<DT>fd
<DD>The file description to which the message should be emitted.  If fd is invalid, the message will be emitted to stderr.<P>
<DT>error_id
<DD>A SRB error id from the SRB error message table contained within srb_error.h.  If the error id is invalid, the error SRB_NO_ERROR will be emitted.<P>
<DT>error_mnenomic
<DD>A SRB error mnenomic from the SRB error message table contained within srb_error.h. If the error_mnenomic is invalid, the error SRB_NO_ERROR will be emitted.<P>
<DT>flags
<DD>Contains the OR'ed value of the flags. SRB_LONG_MSG = Emit the SRB error long message. SRB_RCMD_ACTION = Emit the SRB recommended action.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P> None.</P>
<P>&nbsp;</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#clErrorMessage">clErrorMessage</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbVaultInfo"></A>
<B><P>NAME</P>
<P>srbVaultInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>struct vaultQueElement *srbVaultInfo(srbConn* conn);</P>
<B><P>DESCRIPTION</P>
</B><P>Get Info on the SRB storage vault of a SRB server. The output is the head element of a link list of struct vaultQueElement. This call basically returns the content of the data/vaultConfig file.</P>
<DL>
<DT>Conn
</DL>
<DD>From clConnect call.<P>
<B><P>RETURN VALUES</P>
</B><P>A pointer to the vaultQueElement struct. This is the head of a link list of struct vaultQueElement.</P>
<P>A NULL return means no result.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbFreeVaultInfo">srbFreeVaultInfo</A> and <A HREF="#srbPrintVaultInfo">srbPrintVaultInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFreeVaultInfo"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbFreeVaultInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>void srbFreeVaultInfo(struct vaultQueElement *vaultQueHead);</P>
<B><P>DESCRIPTION</P>
</B><P>Free the memory taken by the vaultQueElement link list obtained from a vaultInfo call.</P>
<DL>
<DT>VaultQueHead
<DD>The head of the link list to be freed.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;None.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbVaultInfo">srbVaultInfo</A> and <A HREF="#srbPrintVaultInfo">srbPrintVaultInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbPrintVaultInfo"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbPrintVaultInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>void srbPrintVaultInfo(struct vaultQueElement *vaultQueHead);</P>
<B><P>DESCRIPTION</P>
</B><P>Print the info represented by the vaultQueElement link list obtained from a vaultInfo call.</P>
<DL>
<DT>VaultQueHead
<DD>The head of the vaultQueElement link list to be printed.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;None.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbVaultInfo">srbVaultInfo</A> and <A HREF="#srbFreeVaultInfo">srbFreeVaultInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbHostConfig"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbHostConfig</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>struct clHostElement *srbHostConfig(srbConn* conn);</P>
<B><P>DESCRIPTION</P>
</B><P>Get the host configuration of the SRB server. This call basically returns the content of the data/hostConfig file. The output is the head of a link list of clHostElement struct.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>A pointer to the clHostElement struct. This is the head of a link list of clHostElement struct.</P>
<P>A NULL return means no result.</P>
<P>&nbsp;</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
<P>&#9;</B><A HREF="#srbPrintVaultInfo">srbPrintVaultInfo</A> and <A HREF="#srbFreeHostInfo">srbFreeHostInfo</A>.</P>
<B><P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbPrintHostInfo"></A>
<P>NAME</P>
</B><P>&#9;<B>srbPrintHostInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>void srbPrintHostInfo(struct clHostElement *vaultQueHead);</P>
<B><P>DESCRIPTION</P>
</B><P>Print the info represented by the clHostElement link list obtained from a srbHostConfig call.</P>
<DL>
<DT>VaultQueHead
<DD>The queue head of the vaultQueElement link list to be printed.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;None.</P>
<B><P>ERRORS</B> </P>
<P>&#9;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbHostConfig">srbHostConfig</A> and <A HREF="#srbFreeHostInfo">srbFreeHostInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="srbFreeHostInfo"></A>
<B><P>NAME</P>
</B><P>&#9;<B>srbFreeHostInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>void srbFreeHostInfo(struct clHostElement *hostQueHead);</P>
<B><P>DESCRIPTION</P>
</B><P>Free memory taken by the clHostElement link list obtained from a srbHostConfig call.</P>
<DL>
<DT>VaultQueHead
<DD>The queue head of the vaultQueElement link list to be freed.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns a 0 upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#srbVaultInfo">srbVaultInfo</A> and <A HREF="#srbPrintHostInfo">srbPrintHostInfo</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix A">Top of Client API Table</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="sfoCreateIndex"></A>
<B><P>NAME</P>
</B><P>&#9;<B>sfoCreateIndex</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int sfoCreateIndex (srbConn *conn, sfoClass class, int catType, char *hostName, char *inIndexName, char *outIndexName, char *resourceName)</P>
<B><P>DESCRIPTION</P>
</B><P>Creates an index for a set of data files stored in the SRB. Metadata about the data files to be indexed and the linear index files must have already been created in the collection "inIndexName" in the SRB. The resulting index files are stored in the collection "outIndexName" in the SRB. If the collection "outIndexName" does not exist, it will be created by the indexing service.</P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Class
<DD>Subsetting class. Currently, the only valid class is DC_CLASS - dataCutter.<P>
<DT>CatType
<DD>The catalog type. e.g., MDAS_CATALOG.<P>
<DT>hostName
<DD>The the host address where this operation is to be performed. A NULL value means on the host where the client is currently connected to.<P>
<DT>inIndexName
<DD>The SRB collection containing the input linear index files.<P>
<DT>outIndexName
<DD>The SRB collection where the output index files to be created will be stored.<P>
<DT>resourceName
<DD>The SRB resource on which the output index files will be created.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns DC_OK upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<DL>
<DD>DC_DATACAT_ERR - Cannot access/read dataset catalog file.<P>
<DD>DC_INDEXCAT_ERR - Cannot access/read index catalog file.<P>
<DD>DC_RTREE_ERR - Cannot create the R-tree index file.<P>
<DD>DC_INTER_ERR - Datacutter internal error - buffer allocation, internal state, etc.<P>
</DL>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#sfoDeleteIndex">sfoDeleteIndex</A> and <A HREF="#sfoSearchIndex">sfoSearchIndex</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix B">Top of Client API Table - Appendix B</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="sfoDeleteIndex"></A>
<B><P>NAME</P>
</B><P>&#9;<B>sfoDeleteIndex</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int sfoDeleteIndex (srbConn *conn, sfoClass class, int catType, char *hostName, char *indexName)</P>
<B><P>DESCRIPTION</P>
</B>Deletes an index that has been created by the sfoCreateIndex() call.<P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Class
<DD>Subsetting class. Currently, the only valid class is DC_CLASS - dataCutter.<P>
<DT>CatType
<DD>The catalog type. e.g., MDAS_CATALOG.<P>
<DT>hostName
<DD>The the host address where this operation is to be performed. A NULL value means on the host where the client is currently connected to.<P>
<DT>indexName
<DD>The SRB collection containing the index files.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns DC_OK upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<DL>
<DD>DC_INDEXDEL_ERR - Cannot delete the index.<P>
<DD>DC_INTER_ERR - Datacutter internal error - buffer allocation, internal state, etc.<P>
</DL>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#sfoCreateIndex">sfoCreateIndex</A> and <A HREF="#sfoSearchIndex">sfoSearchIndex</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix B">Top of Client API Table  - Appendix B</A>
<P>&nbsp;</P>
<P>&nbsp;</P>
<A NAME="sfoSearchIndex"></A>
<B><P>NAME</P>
</B><P>&#9;<B>sfoSearchIndex</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int sfoDeleteIndex (srbConn *conn, sfoClass class, char *hostName, char *indexName, void *query, indexSearchResult **myresult, int maxSegCount)</P>
<B><P>DESCRIPTION</P>
</B>Performs a search in the "indexName" to find the segments that intersect the range query given in the query parameter. The resulting segment metadata is written in a indexSearchResult type struct and the pointer to this struct is returned in the "myresult" parameter. The segment metadata is stored in the segments array of the "segmentInfo" struct of "myresult". The segments array is allocated by the indexing service of the server and the calling program is responsible for freeing the segment array. The "segmentCount" of "myresult" gives the number of entries in the segments array which may be less than "maxSegCount" input parameter. The returned "continueIndex" field of "myresult" will be greater than or equal to zero if there are more results to return; a -1 is returned if there is no more result. The DataCutter indexing service maintains an internal state for the query so that subsequent call of sfoGetMoreSearchResult() can return more results. If there are no more results to return, the indexing service deletes the internal query state and sets the "continueIndex" field of myresult to -1. "maxSegCount" limits the maximum number of segments to be returned from a single call to the sfoSearchIndex() function.<P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Class
<DD>Subsetting class. Currently, the only valid class is DC_CLASS - dataCutter.<P>
<DT>hostName
<DD>The the host address where this operation is to be performed. A NULL value means on the host where the client is currently connected to.<P>
<DT>indexName
<DD>The SRB collection containing the index files.<P>
<DT>query
<DD>The spatial query input - a pointer to a "rangeQuery" type<P>
<DT>myresult
<DD>The output of the spatial query - a double pointer to a indexSearchResult type.<P>
<DT>maxSegCount
<DD>The maximum number of seqments to return. If the query result contains more than "maxSegCount" segments, "maxSegCount" segments will be returned in the current call and the "continueIndex" will be set to greater than or equal to 0. The sfoGetMoreSearchResult() function should be used subsequently to get the remaining segments.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns DC_OK upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<DL>
<DD>DC_DATACAT_ERR - Cannot read the dataset catalog file.<P>
<DD>DC_INDEXCAT_ERR - Cannot read the index catalog file.<P>
<DD>DC_RTREE_ERR - Cannot access the R-tree index file.<P>
<DD>DC_QUERY_ERR - The number of query dimensions does not match the number of dataset dimensions.<P>
<DD>DC_SEGINFO_ERR - Cannot create segment information data structures - e.g., memory allocation error.<P>
<DD>DC_INTER_ERR - Datacutter internal error - buffer allocation, internal state, etc.<P>
</DL>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#sfoCreateIndex">sfoCreateIndex</A>, <A HREF="#sfoGetMoreSearchResult">sfoGetMoreSearchResult</A> and <A HREF="#sfoDeleteIndex">sfoDeleteIndex</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix B">Top of Client API Table - Appendix B</A>
<P>&nbsp;</P>
<A NAME="sfoGetMoreSearchResult"></A>
<B><P>NAME</P>
</B><P>&#9;<B>sfoGetMoreSearchResult</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int sfoGetMoreSearchResult (srbConn *conn, sfoClass class, char *hostName, int continueIndex, indexSearchResult **myresult, int maxSegCount)</P>
<B><P>DESCRIPTION</P>
</B>Used to get more results after calling the sfoSearchIndex() function. The input parameter "continueIndex" should be greater than or equal to zero and set to the returned "continueIndex" value of a previous sfoSearchIndex() call to get more results. If it is set to -1, the DataCutter indexing service should close out the internal state of this query and return no more result. The definitions of the "myresult" and "maxSegCount" are the same as those of the sfoSearchIndex() function. 
<P>It should be noted that in the current implementation, the dataCutter service maintains an internal state of the current query. Thus, only one query can be active at a time for a given client connection. Another call to sfoSearchIndex() will replace the state of the current query and any subsequent calls to sfoGetMoreSearchResult() will return results for the last query.<P> 

<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Class
<DD>Subsetting class. Currently, the only valid class is DC_CLASS - dataCutter.<P>
<DT>hostName
<DD>The the host address where this operation is to be performed. A NULL value means on the host where the client is currently connected to.<P>
<DT>continueIndex
<DD>If set to greater than or equal to zero, returns more query results(up to "maxSegCount"). A -1 means the dataCutter service should close out the state of the current query.<P>
<DT>myresult
<DD>The output of the spatial query - a double pointer to a indexSearchResult type<P>
<DT>maxSegCount
<DD>The maximum number of seqments to return in the current call. If the query result contains more than "maxSegCount" segments, "maxSegCount" segments will be returned in the current call and the "continueIndex" will be set to greater than or equal to 0. The sfoGetMoreSearchResult() function should be called repeatedly to get the remaining segments.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns DC_OK upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<DL>
<DD>DC_RTREE_ERR - Cannot access the R-tree index file.<P>
<DD>DC_QUERY_ERR - The number of query dimensions does not match the number of dataset dimensions.<P>
<DD>DC_SEGINFO_ERR - Cannot create segment information data structures - e.g., memory allocation error.<P>
<DD>DC_NOTINIT_ERR - The sfoSearchIndex() function has not yet been called. It must be called before the sfoGetMoreSearchResult() call is made.<P>
<DD>DC_INTER_ERR - Datacutter internal error - buffer allocation, internal state, etc.<P>
</DL>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#sfoCreateIndex">sfoCreateIndex</A>, <A HREF="#sfoSearchIndex">sfoSearchIndex</A> and <A HREF="#sfoDeleteIndex">sfoDeleteIndex</A>.</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix B">Top of Client API Table - Appendix B</A>
<P>&nbsp;</P>
<A NAME="sfoApplyFilter"></A>
<B><P>NAME</P>
</B><P>&#9;<B>sfoApplyFilter</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int sfoApplyFilter (srbConn *conn, sfoClass class, char *hostName, int filterID, char *filterArg, int numberOfInputSeg, segmentInfo *inputSeg, filterDataResult **myresult, int maxSegCount)</P>
<B><P>DESCRIPTION</P>
</B>Applies the filtering operation represented by the "filterID" input parameter to the segments given in the "inputSeg" input. The parameter "numberOfInputSeg" specifies the number of segments in the "inputSeg". Results of the filtering operation is written in a filterDataResult type struct and the pointer to this struct is returned in the "myresult" parameter. The returned "continueIndex" field of "myresult" will be greater than zero if there are more results to return; a -1 is returned if there is no more result. The DataCutter indexing service maintains an internal state for the operation so that subsequent call of sfoGetMoreFilterResult() can return more results. If there are no more results to return, the indexing service deletes the internal query state and sets the "continueIndex" field of myresult to -1. "maxSegCount" limits the maximum number of segments to be returned from a single call to the sfoApplyFilter() function.<P>
<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Class
<DD>Subsetting class. Currently, the only valid class is DC_CLASS - dataCutter.<P>
<DT>hostName
<DD>The the host address where this operation is to be performed. A NULL value means on the host where the client is currently connected to.<P>
<DT>filterID
<DD>The ID of the filtering operation to perform.<P>
<DT>filterArg
<DD>The argument string for the filtering operation<P>
<DT>myresult
<DD>Results of the filtering operation - a double pointer to a filterDataResult type<P>
<DT>maxSegCount
<DD>The maximum number of seqments to return. If the filtering result contains more than "maxSegCount" segments, "maxSegCount" segments will be returned in the current call and the "continueIndex" will be set to greater than or equal to 0. The sfoGetMoreFilterResult() function should be used subsequently to get the remaining segments.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns DC_OK upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<DL>
<DD>DC_FILTERID_ERR - Invalid filterID.<P>
<DD>DC_FILTER_ERR - Error in carrying the filtering operation.<P>
<DD>DC_SEGMENT_ERR - Cannot read or process a segment in the input list.<P>
<DD>DC_INTER_ERR - Datacutter internal error - buffer allocation, internal state, etc.<P>
</DL>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#sfoSearchIndex">sfoSearchIndex</A>, and <A HREF="#sfoGetMoreFilterResult">sfoGetMoreFilterResult</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix B">Top of Client API Table - Appendix B</A>
<P>&nbsp;</P>
<A NAME="sfoGetMoreFilterResult"></A>
<B><P>NAME</P>
</B><P>&#9;<B>sfoGetMoreFilterResult</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int sfoGetMoreFilterResult (srbConn *conn, sfoClass class, char *hostName, int continueIndex, filterDataResult **myresult, int maxSegCount)</P>
<B><P>DESCRIPTION</P>
</B>Used to get more results after calling the sfoApplyFilter() function. The input parameter "continueIndex" should be greate than or equal to zero and set to the returned "continueIndex" value of a previous sfoApplyFilter() call to get more results. If it is set to -1, the DataCutter indexing service would close out the internal state of this operation and return no more result. The definitions of the "myresult" and "maxSegCount" are the same as those of the sfoApplyFilter() function. 
<P>It should be noted that in the current implementation, the dataCutter service manintains an internal state of the current filtering operation. Thus, only one operation can be active at a time for a given client connection. Another call to sfoApplyFilter() will replace the state of the current operation and any subsequent calls to sfoGetMoreFilterResult() will return results for the last filtering operation.<P> 

<DL>
<DT>Conn
<DD>From clConnect call.<P>
<DT>Class
<DD>Subsetting class. Currently, the only valid class is DC_CLASS - dataCutter.<P>
<DT>hostName
<DD>The the host address where this operation is to be performed. A NULL value means on the host where the client is currently connected to.<P>
<DT>continueIndex
<DD>If set to greater than or equal to zero, returns more results(up to "maxSegCount"). A -1 means the dataCutter service should close out the state of the current operation.<P>
<DT>myresult
<DD>The output of the filtering operation - a double pointer to a indexSearchResult type.<P>
<DT>maxSegCount
<DD>The maximum number of seqments to return in the current call. If the result contains more than "maxSegCount" segments, "maxSegCount" segments will be returned in the current call and the "continueIndex" will be set to greater than or equal to 0. The sfoFreeFilterResults() function should be called repeatedly to get the remaining segments.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns DC_OK upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<DL>
<DD>DC_NOTINIT_ERR - The sfoApplyFilter() function has not yet been called. It must be called before the sfoGetMoreFilterResult() call is made.<P>
<DD>DC_FILTER_ERR - Error in carrying the filtering operation.<P>
<DD>DC_SEGMENT_ERR - Cannot read or process a segment in the input list.<P>
<DD>DC_INTER_ERR - Datacutter internal error - buffer allocation, internal state, etc.<P>
</DL>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#sfoGetMoreSearchResult">sfoGetMoreSearchResult</A> and <A HREF="#sfoSearchIndex">sfoSearchIndex</A>.</P>
<P>&nbsp;</P>
rP>&nbsp;</P>
<P><A HREF="#Appendix B">Top of Client API Table - Appendix B</A>
<P>&nbsp;</P>
<A NAME="sfoFreeIndexResults"></A>
<B><P>NAME</P>
</B><P>&#9;<B>sfoFreeIndexResults</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int sfoFreeIndexResults (indexSearchResult *myresult)</P>
<B><P>DESCRIPTION</P>
</B>Free all memory associated with a indexSearchResult type struct.<P>
<DL>
<DT>myresult
<DD>The indexSearchResult type struct to free.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns 0 upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#sfoApplyFilter">sfoApplyFilter</A> and <A HREF="#sfoSearchIndex">sfoSearchIndex</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix B">Top of Client API Table - Appendix B</A>
<P>&nbsp;</P>
<A NAME="sfoFreeFilterResults"></A>
<B><P>NAME</P>
</B><P>&#9;<B>sfoFreeFilterResults</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int sfoFreeIndexResults (filterDataResult *myresult)</P>
<B><P>DESCRIPTION</P>
</B>Free all memory associated with a filterDataResult type struct.<P>
<DL>
<DT>myresult
<DD>The filterDataResult type struct to free.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns 0 upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#sfoApplyFilter">sfoApplyFilter</A> and <A HREF="#sfoGetMoreFilterResult">sfoGetMoreFilterResult</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix B">Top of Client API Table - Appendix B</A>
<P>&nbsp;</P>
<A NAME="sfoFreeSegmentInfo"></A>
<B><P>NAME</P>
</B><P>&#9;<B>sfoFreeSegmentInfo</P>
<P>SYNOPSIS</P>
</B><P>#include "srbClient.h"</P>
<P>int sfoFreeSegmentInfo (segmentInfo *seg_i)</P>
<B><P>DESCRIPTION</P>
</B>Free all memory associated with a segmentInfo type struct.<P>
<DL>
<DT>seg_i
<DD>The segmentInfo type struct to free.<P>
</DL>
<B><P>RETURN VALUES</P>
</B><P>&#9;Returns 0 upon success, a negative value upon failure.</P>
<B><P>ERRORS</B> </P>
<P>&nbsp;</P>
<B><P>SEE ALSO</P>
</B><P><A HREF="#sfoApplyFilter">sfoApplyFilter</A> and <A HREF="#sfoSearchIndex">sfoSearchIndex</A>.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><A HREF="#Appendix B">Top of Client API Table - Appendix B</A>
</FONT></BODY><P>&nbsp;</P>
</HTML>

